/// <reference path="../../lib/types.d.ts" />
/// <reference path="./Runtime.d.ts" />

declare const NSProgressFileTotalCountKey: string;

declare const NSURLErrorKey: string;

declare const NSURLIsUserImmutableKey: string;

declare const NSBundleExecutableArchitectureARM64: number;

declare const NSURLFileResourceTypeSocket: string;

declare const NSCoderReadCorruptError: number;

declare const NSLoadedClasses: string;

declare const NSOpenStepUnicodeReservedBase: number;

declare const NSURLErrorServerCertificateHasUnknownRoot: number;

declare const NSFileHandleNotificationMonitorModes: string;

declare const NSURLFileScheme: string;

declare const NSISO2022JPStringEncoding: number;

declare const NSLinguisticTagPronoun: string;

declare const NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSWindowsCP1251StringEncoding: number;

declare const NSLocalizedDescriptionKey: string;

declare const NSLinguisticTagOtherWhitespace: string;

declare const NSExecutableRuntimeMismatchError: number;

declare const NSPersonNameComponentPrefix: string;

declare const NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSURLSessionTaskPriorityDefault: number;

declare const NSURLLocalizedTypeDescriptionKey: string;

declare const NSStringEncodingDetectionAllowLossyKey: string;

declare const NSUbiquitousUserDefaultsCompletedInitialSyncNotification: string;

declare const NSURLLabelNumberKey: string;

declare const NSDistinctUnionOfObjectsKeyValueOperator: string;

declare const NSURLFileProtectionCompleteUnlessOpen: string;

declare const NSUserActivityTypeBrowsingWeb: string;

declare const NSCoderValueNotFoundError: number;

declare const NSBundleResourceRequestLoadingPriorityUrgent: number;

declare const NSExtensionJavaScriptFinalizeArgumentKey: string;

declare const NSLinguisticTagNoun: string;

declare const NSLocaleCurrencySymbol: string;

declare const NSRangeException: string;

declare const NSUnionOfArraysKeyValueOperator: string;

declare const NSURLErrorBadServerResponse: number;

declare const NSTextCheckingAllCustomTypes: number;

declare const NSStringTransformLatinToArabic: string;

declare const NSURLErrorCancelledReasonBackgroundUpdatesDisabled: number;

declare const NSFileReadInapplicableStringEncodingError: number;

declare const NSURLVolumeResourceCountKey: string;

declare const NSURLAuthenticationMethodServerTrust: string;

declare const NSGregorianCalendar: string;

declare const NSStreamSOCKSProxyVersion5: string;

declare const NSFilePosixPermissions: string;

declare const NSMaximumKeyValueOperator: string;

declare const NSErrorFailingURLStringKey: string;

declare const NSURLUbiquitousSharedItemOwnerNameComponentsKey: string;

declare const NSURLUbiquitousItemDownloadingStatusCurrent: string;

declare const NSURLVolumeAvailableCapacityKey: string;

declare const NSHTTPCookieSameSiteStrict: string;

declare const NSMetadataUbiquitousItemDownloadingStatusKey: string;

declare const NSMultipleUnderlyingErrorsKey: string;

declare const NSDefaultRunLoopMode: string;

declare const NSURLErrorCannotRemoveFile: number;

declare const NSFileAppendOnly: string;

declare const NSFormattingError: number;

declare const NSFileSystemSize: string;

declare const NSUserDefaultsSizeLimitExceededNotification: string;

declare const NSURLUbiquitousSharedItemPermissionsReadWrite: string;

declare const NSURLUbiquitousItemDownloadingStatusNotDownloaded: string;

declare const NSURLVolumeSupportsExtendedSecurityKey: string;

declare const NSMetadataUbiquitousSharedItemPermissionsReadWrite: string;

declare const NSURLFileSecurityKey: string;

declare const NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSHTTPCookieSameSitePolicy: string;

declare const NSObjectMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSUndoManagerDidCloseUndoGroupNotification: string;

declare const NSURLTotalFileSizeKey: string;

declare const NSFileHandleReadToEndOfFileCompletionNotification: string;

declare const NSMetadataQueryAccessibleUbiquitousExternalDocumentsScope: string;

declare const NSFileHFSCreatorCode: string;

declare const NSHTTPCookieOriginURL: string;

declare const NSURLAuthenticationMethodDefault: string;

declare const NSPortReceiveException: string;

declare const NSURLVolumeIsRootFileSystemKey: string;

declare const NSMetadataQueryUpdateAddedItemsKey: string;

declare const NSDistinctUnionOfSetsKeyValueOperator: string;

declare const NSStringEncodingDetectionLikelyLanguageKey: string;

declare const NSSecureUnarchiveFromDataTransformerName: string;

declare const NSProgressFileCompletedCountKey: string;

declare const NSOSStatusErrorDomain: string;

declare const NSStringTransformLatinToHangul: string;

declare const NSMetadataUbiquitousItemUploadingErrorKey: string;

declare const NSURLUbiquitousItemHasUnresolvedConflictsKey: string;

declare const NSUnionOfObjectsKeyValueOperator: string;

declare const NSURLErrorCannotLoadFromNetwork: number;

declare const NSCompressionFailedError: number;

declare const NSProgressEstimatedTimeRemainingKey: string;

declare const NSURLErrorAppTransportSecurityRequiresSecureConnection: number;

declare const NSURLErrorDataLengthExceedsMaximum: number;

declare const NSURLErrorServerCertificateUntrusted: number;

declare const NSURLErrorRequestBodyStreamExhausted: number;

declare const NSBundleOnDemandResourceOutOfSpaceError: number;

declare const NSRegistrationDomain: string;

declare const NSCloudSharingNoPermissionError: number;

declare const NSMetadataItemFSCreationDateKey: string;

declare const NSLinguisticTagAdverb: string;

declare const NSURLErrorFailingURLPeerTrustErrorKey: string;

declare const NSCalendarIdentifierRepublicOfChina: string;

declare const NSPersonNameComponentDelimiter: string;

declare const NSURLAuthenticationMethodNTLM: string;

declare const NSInflectionReferentConceptAttributeName: string;

declare const NSIndianCalendar: string;

declare const NSWindowsCP1250StringEncoding: number;

declare const NSLocaleVariantCode: string;

declare const NSMetadataQueryResultContentRelevanceAttribute: string;

declare const NSURLCredentialStorageRemoveSynchronizableCredentials: string;

declare const NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSLinguisticTagWhitespace: string;

declare const NSFileGroupOwnerAccountName: string;

declare const NSFileSystemFreeNodes: string;

declare const NSCalendarIdentifierPersian: string;

declare const NSStreamSOCKSProxyPasswordKey: string;

declare const NSKeyValueChangeOldKey: string;

declare const NSLinguisticTagSchemeNameTypeOrLexicalClass: string;

declare const NSUbiquitousKeyValueStoreServerChange: number;

declare const NSInflectionAgreementConceptAttributeName: string;

declare const NSURLVolumeCreationDateKey: string;

declare const NSURLFileAllocatedSizeKey: string;

declare const NSTextCheckingZIPKey: string;

declare const NSMallocException: string;

declare const NSLinguisticTagParagraphBreak: string;

declare const NSExecutableNotLoadableError: number;

declare const NSLinguisticTagSchemeNameType: string;

declare const NSURLProtectionSpaceHTTP: string;

declare const NSMinimumKeyValueOperator: string;

declare const NSUserActivityErrorMinimum: number;

declare const NSCompressionErrorMaximum: number;

declare const NSWindowsNTOperatingSystem: number;

declare const NSWindows95OperatingSystem: number;

declare const NSMetadataUbiquitousItemDownloadingStatusCurrent: string;

declare const NSFileOwnerAccountName: string;

declare const NSURLErrorUserCancelledAuthentication: number;

declare const NSTextCheckingNameKey: string;

declare const NSURLFileResourceIdentifierKey: string;

declare const NSURLVolumeURLKey: string;

declare const NSFileHandleReadCompletionNotification: string;

declare const NSLinguisticTagSentenceTerminator: string;

declare const NSXPCConnectionErrorMaximum: number;

declare const NSURLMayHaveExtendedAttributesKey: string;

declare const NSURLErrorCancelled: number;

declare const NSPersonNameComponentFamilyName: string;

declare const NSStreamSocketSecurityLevelKey: string;

declare const NSTextCheckingCountryKey: string;

declare const NSTextCheckingStreetKey: string;

declare const NSLinguisticTagNumber: string;

declare const NSCloudSharingOtherError: number;

declare const NSFileHandleConnectionAcceptedNotification: string;

declare const NSCloudSharingErrorMaximum: number;

declare const NSDateComponentUndefined: number;

declare const NSBuddhistCalendar: string;

declare const NSStringTransformFullwidthToHalfwidth: string;

declare const NSURLUbiquitousSharedItemMostRecentEditorNameComponentsKey: string;

declare const NSHTTPCookieManagerCookiesChangedNotification: string;

declare const NSURLErrorCallIsActive: number;

declare const NSExtensionItemAttributedTitleKey: string;

declare const NSLocaleMeasurementSystem: string;

declare const NSURLVolumeIsJournalingKey: string;

declare const NSUbiquitousKeyValueStoreChangeReasonKey: string;

declare const NSURLErrorCannotConnectToHost: number;

declare const NSFileExtensionHidden: string;

declare const NSObjectNotAvailableException: string;

declare const NSProgressFileOperationKindKey: string;

declare const NSURLVolumeAvailableCapacityForOpportunisticUsageKey: string;

declare const NSURLVolumeSupportsCasePreservedNamesKey: string;

declare const NSPersonNameComponentGivenName: string;

declare const NSURLFileResourceTypeDirectory: string;

declare const NSMetadataUbiquitousItemIsUploadingKey: string;

declare const NSURLProtectionSpaceHTTPS: string;

declare const NSURLFileResourceTypeNamedPipe: string;

declare const NSURLUbiquitousItemContainerDisplayNameKey: string;

declare const NSMapTableStrongMemory: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSFormattingErrorMaximum: number;

declare const NSURLErrorDataNotAllowed: number;

declare const NSURLIsDirectoryKey: string;

declare const NSBundleErrorMinimum: number;

declare const NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSThumbnail1024x1024SizeKey: string;

declare const NSLinguisticTagOpenParenthesis: string;

declare const NSURLFileSizeKey: string;

declare const NSChineseCalendar: string;

declare const NSUndoManagerWillCloseUndoGroupNotification: string;

declare const NSURLCustomIconKey: string;

declare const NSURLCreationDateKey: string;

declare const NSFileReadNoPermissionError: number;

declare const NSExtensionJavaScriptPreprocessingResultsKey: string;

declare const NSInvalidArchiveOperationException: string;

declare const NSURLAuthenticationMethodHTMLForm: string;

declare const NSStringEncodingErrorKey: string;

declare const NSUserActivityHandoffUserInfoTooLargeError: number;

declare const NSURLThumbnailDictionaryKey: string;

declare const NSLinguisticTagDash: string;

declare const NSURLAuthenticationMethodNegotiate: string;

declare const NSStreamNetworkServiceType: string;

declare const NSUserDefaultsDidChangeNotification: string;

declare const NSInconsistentArchiveException: string;

declare const NSMetadataQueryDidUpdateNotification: string;

declare const NSInternalInconsistencyException: string;

declare const NSFileModificationDate: string;

declare const NSStreamSOCKSProxyPortKey: string;

declare const NSMetadataUbiquitousItemDownloadRequestedKey: string;

declare const NSStreamSOCKSErrorDomain: string;

declare const NSMetadataUbiquitousSharedItemCurrentUserPermissionsKey: string;

declare const NS_BigEndian: number;

declare const NSBundleExecutableArchitecturePPC64: number;

declare const NSDecimalNumberUnderflowException: string;

declare const NSURLUbiquitousSharedItemRoleParticipant: string;

declare const NSFileErrorMaximum: number;

declare const NSFileProtectionComplete: string;

declare const NSIntMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSURLErrorFileIsDirectory: number;

declare const NSFileType: string;

declare const NSProgressFileOperationKindReceiving: string;

declare const NSURLErrorDomain: string;

declare const NSUnicodeStringEncoding: number;

declare const NSHTTPCookieManagerAcceptPolicyChangedNotification: string;

declare const NSURLHasHiddenExtensionKey: string;

declare const NSPOSIXErrorDomain: string;

declare const NSWindowsCP1254StringEncoding: number;

declare const NSAverageKeyValueOperator: string;

declare const NSStreamNetworkServiceTypeVoIP: string;

declare const NSURLIsMountTriggerKey: string;

declare const NSFileDeviceIdentifier: string;

declare const NSURLSessionTransferSizeUnknown: number;

declare const NSURLErrorTimedOut: number;

declare const NSURLGenerationIdentifierKey: string;

declare const NSSystemClockDidChangeNotification: string;

declare const NSCalendarIdentifierISO8601: string;

declare const NSURLIsExecutableKey: string;

declare const NSUTF16LittleEndianStringEncoding: number;

declare const NSURLProtectionSpaceHTTPProxy: string;

declare const NSMetadataUbiquitousSharedItemOwnerNameComponentsKey: string;

declare const NSLinguisticTagClassifier: string;

declare const NSLinguisticTagOtherPunctuation: string;

declare const NSStreamNetworkServiceTypeBackground: string;

declare const NSBundleExecutableArchitecturePPC: number;

declare const NSTextCheckingJobTitleKey: string;

declare const NSFileReadInvalidFileNameError: number;

declare const NSFileTypeCharacterSpecial: string;

declare const NSTextCheckingAllTypes: number;

declare const NSASCIIStringEncoding: number;

declare const NSLocaleScriptCode: string;

declare const NSDecimalNumberDivideByZeroException: string;

declare const NSNegateBooleanTransformerName: string;

declare const NSURLVolumeSupportsPersistentIDsKey: string;

declare const NSURLIsSystemImmutableKey: string;

declare const NSISO8601Calendar: string;

declare const NSURLErrorNotConnectedToInternet: number;

declare const NSXPCConnectionInterrupted: number;

declare const NSURLVolumeIsReadOnlyKey: string;

declare const NSURLSessionDownloadTaskResumeData: string;

declare const NSBundleDidLoadNotification: string;

declare const NSMetadataQueryUbiquitousDataScope: string;

declare const NSStreamSocketSecurityLevelNegotiatedSSL: string;

declare const NSMetadataUbiquitousItemIsUploadedKey: string;

declare const NSPointerToStructHashCallBacks: NSHashTableCallBacks;

declare const NSStreamSOCKSProxyVersionKey: string;

declare const NSLinguisticTagConjunction: string;

declare const NSExecutableArchitectureMismatchError: number;

declare const NSMetadataItemFSContentChangeDateKey: string;

declare const NSMarkdownSourcePositionAttributeName: string;

declare const NSURLVolumeTotalCapacityKey: string;

declare const NSUserActivityHandoffFailedError: number;

declare const NSUserCancelledError: number;

declare const NSFileTypeSymbolicLink: string;

declare const NSStringTransformStripDiacritics: string;

declare const NSPropertyListWriteStreamError: number;

declare const NSProgressFileURLKey: string;

declare const NSCountKeyValueOperator: string;

declare const NSUbiquitousFileNotUploadedDueToQuotaError: number;

declare const NSBundleErrorMaximum: number;

declare const NSInflectionAgreementArgumentAttributeName: string;

declare const NSBundleResourceRequestLowDiskSpaceNotification: string;

declare const NSURLFileContentIdentifierKey: string;

declare const NSURLUbiquitousSharedItemPermissionsReadOnly: string;

declare const NS_LittleEndian: number;

declare const NSStringTransformToLatin: string;

declare const NSLocalizedFailureErrorKey: string;

declare const NSURLVolumeIsEncryptedKey: string;

declare const NSLinguisticTagSchemeLanguage: string;

declare const NSMetadataQueryUpdateChangedItemsKey: string;

declare const NSUbiquitousFileErrorMaximum: number;

declare const NSMetadataUbiquitousSharedItemMostRecentEditorNameComponentsKey: string;

declare const NSURLFileResourceTypeCharacterSpecial: string;

declare const NSStringTransformLatinToGreek: string;

declare const NSUndefinedDateComponent: number;

declare const NSCloudSharingConflictError: number;

declare const NSURLUbiquitousSharedItemCurrentUserPermissionsKey: string;

declare const NSLinguisticTagSchemeLexicalClass: string;

declare const NSUbiquityIdentityDidChangeNotification: string;

declare const NSURLIsReadableKey: string;

declare const NSLinguisticTagAdjective: string;

declare const NSURLMayShareFileContentKey: string;

declare const NSURLUbiquitousItemUploadingErrorKey: string;

declare const NSUbiquitousFileUnavailableError: number;

declare const NSSolarisOperatingSystem: number;

declare const NSExecutableErrorMaximum: number;

declare const NSPersianCalendar: string;

declare const NSURLVolumeSupportsZeroRunsKey: string;

declare const NSURLCredentialStorageChangedNotification: string;

declare const NSCalendarIdentifierHebrew: string;

declare const NSRepublicOfChinaCalendar: string;

declare const NSLocalizedRecoveryOptionsErrorKey: string;

declare const NSInvalidArgumentException: string;

declare const NSMetadataUbiquitousItemURLInLocalContainerKey: string;

declare const NSUserActivityConnectionUnavailableError: number;

declare const NSURLErrorBackgroundTaskCancelledReasonKey: string;

declare const NSURLErrorCannotFindHost: number;

declare const NSURLErrorZeroByteResource: number;

declare const NSXPCConnectionErrorMinimum: number;

declare const NSFileSystemNumber: string;

declare const NSXPCConnectionInvalid: number;

declare const NSXPCConnectionCodeSigningRequirementFailure: number;

declare const NSCloudSharingErrorMinimum: number;

declare const NSPersonNameComponentMiddleName: string;

declare const NSTextCheckingAirlineKey: string;

declare const NSURLVolumeSupportsFileProtectionKey: string;

declare const NSPortSendException: string;

declare const NSURLErrorUnknown: number;

declare const NSURLErrorClientCertificateRequired: number;

declare const NSURLProtectionSpaceHTTPSProxy: string;

declare const NSURLErrorCannotCloseFile: number;

declare const NSLinguisticTagDeterminer: string;

declare const NSExtensionItemAttachmentsKey: string;

declare const NSStringEncodingDetectionUseOnlySuggestedEncodingsKey: string;

declare const NSMetadataUbiquitousItemIsDownloadedKey: string;

declare const NSAssertionHandlerKey: string;

declare const NSURLAddedToDirectoryDateKey: string;

declare const NSURLFileProtectionComplete: string;

declare const NSURLContentModificationDateKey: string;

declare const NSTextCheckingFlightKey: string;

declare const NSBundleOnDemandResourceInvalidTagError: number;

declare const NSCoderErrorMaximum: number;

declare const NSURLProtectionSpaceSOCKSProxy: string;

declare const NSFileProtectionCompleteWhenUserInactive: string;

declare const NSFileReadUnknownError: number;

declare const NSUnderlyingErrorKey: string;

declare const NSURLVolumeSupportsSwapRenamingKey: string;

declare const NSCalendarDayChangedNotification: string;

declare const NSURLVolumeSupportsCompressionKey: string;

declare const NSMapTableWeakMemory: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSMetadataQueryUbiquitousDocumentsScope: string;

declare const NSUbiquitousKeyValueStoreInitialSyncChange: number;

declare const NSExtensionItemsAndErrorsKey: string;

declare const NSHTTPCookieComment: string;

declare const NSLinguisticTagOtherWord: string;

declare const NSLocaleCountryCode: string;

declare const NSMetadataUbiquitousSharedItemRoleOwner: string;

declare const NSMetadataUbiquitousItemPercentUploadedKey: string;

declare const NSURLDocumentIdentifierKey: string;

declare const NSURLErrorCannotWriteToFile: number;

declare const NSURLErrorHTTPTooManyRedirects: number;

declare const NSUndoManagerDidOpenUndoGroupNotification: string;

declare const NSLinguisticTagCloseQuote: string;

declare const NSUndoManagerDidRedoChangeNotification: string;

declare const NSUndoManagerDidUndoChangeNotification: string;

declare const NSNonLossyASCIIStringEncoding: number;

declare const NSUndoManagerWillRedoChangeNotification: string;

declare const NSUndoManagerWillUndoChangeNotification: string;

declare const NSObjectInaccessibleException: string;

declare const NSURLAuthenticationMethodHTTPDigest: string;

declare const NSUndoManagerCheckpointNotification: string;

declare const NSUndoManagerGroupIsDiscardableKey: string;

declare const NSUbiquitousKeyValueStoreChangedKeysKey: string;

declare const NSURLErrorCannotOpenFile: number;

declare const NSUbiquitousKeyValueStoreDidChangeExternallyNotification: string;

declare const NSNetServicesErrorDomain: string;

declare const NSNetServicesErrorCode: string;

declare const NSMACHOperatingSystem: number;

declare const NSMetadataQueryUpdateRemovedItemsKey: string;

declare const NSMetadataQueryDidStartGatheringNotification: string;

declare const NSMetadataUbiquitousSharedItemPermissionsReadOnly: string;

declare const NSHashTableStrongMemory: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSMetadataUbiquitousSharedItemRoleParticipant: string;

declare const NSPortDidBecomeInvalidNotification: string;

declare const NSMetadataUbiquitousSharedItemCurrentUserRoleKey: string;

declare const NSMetadataUbiquitousItemIsSharedKey: string;

declare const NSCloudSharingTooManyParticipantsError: number;

declare const NSURLPathKey: string;

declare const NSMetadataUbiquitousItemPercentDownloadedKey: string;

declare const NSInflectionConceptsKey: string;

declare const NSSystemTimeZoneDidChangeNotification: string;

declare const NSFileSize: string;

declare const NSCalendarIdentifierBuddhist: string;

declare const NSMetadataUbiquitousItemDownloadingStatusDownloaded: string;

declare const NSMetadataUbiquitousItemDownloadingStatusNotDownloaded: string;

declare const NSURLErrorCannotDecodeContentData: number;

declare const NSMetadataUbiquitousItemHasUnresolvedConflictsKey: string;

declare const NSMetadataQueryDidFinishGatheringNotification: string;

declare const NSFileWriteInapplicableStringEncodingError: number;

declare const NSReplacementIndexAttributeName: string;

declare const NSMetadataItemIsUbiquitousKey: string;

declare const NSMetadataQueryGatheringProgressNotification: string;

declare const NSURLAttributeModificationDateKey: string;

declare const NSMetadataItemContentTypeTreeKey: string;

declare const NSMetadataItemPathKey: string;

declare const NSMetadataItemURLKey: string;

declare const NSLinguisticTagOrganizationName: string;

declare const NSLinguisticTagPlaceName: string;

declare const NSInvocationOperationVoidResultException: string;

declare const NSRunLoopCommonModes: string;

declare const NSLinguisticTagWordJoiner: string;

declare const NSFileImmutable: string;

declare const NSHTTPCookiePath: string;

declare const NSLinguisticTagOpenQuote: string;

declare const NSDebugDescriptionErrorKey: string;

declare const NSURLAuthenticationMethodHTTPBasic: string;

declare const NSLinguisticTagIdiom: string;

declare const NSLinguisticTagInterjection: string;

declare const NSLinguisticTagPreposition: string;

declare const NSExecutableErrorMinimum: number;

declare const NSLinguisticTagVerb: string;

declare const NSStreamSOCKSProxyConfigurationKey: string;

declare const NSTextCheckingAllSystemTypes: number;

declare const NSLinguisticTagOther: string;

declare const NSLinguisticTagPunctuation: string;

declare const NSURLFileResourceTypeRegular: string;

declare const NSExtensionItemAttributedContentTextKey: string;

declare const NSExtensionHostDidBecomeActiveNotification: string;

declare const NSExtensionHostWillResignActiveNotification: string;

declare const NSExtensionHostWillEnterForegroundNotification: string;

declare const NSStringTransformMandarinToLatin: string;

declare const NSCompressionErrorMinimum: number;

declare const NSFileWriteNoPermissionError: number;

declare const NSPropertyListErrorMaximum: number;

declare const NSDecompressionFailedError: number;

declare const NSCalendarIdentifierIslamic: string;

declare const NSFileProtectionCompleteUntilFirstUserAuthentication: string;

declare const NSCloudSharingQuotaExceededError: number;

declare const NSCloudSharingNetworkFailureError: number;

declare const NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;

declare const NSBundleOnDemandResourceExceededMaximumSizeError: number;

declare const NSCoderInvalidValueError: number;

declare const NSStreamSocketSecurityLevelNone: string;

declare const NSLinguisticTagCloseParenthesis: string;

declare const NSUserActivityErrorMaximum: number;

declare const NSUserActivityRemoteApplicationTimedOutError: number;

declare const NSUbiquitousFileErrorMinimum: number;

declare const NSXPCConnectionReplyInvalid: number;

declare const NSPropertyListWriteInvalidError: number;

declare const NSPropertyListReadStreamError: number;

declare const NSURLSessionTaskPriorityLow: number;

declare const NSStringTransformToUnicodeName: string;

declare const NSPropertyListReadUnknownVersionError: number;

declare const NSLocaleQuotationEndDelimiterKey: string;

declare const NSFormattingErrorMinimum: number;

declare const NSInvocationOperationCancelledException: string;

declare const NSParseErrorException: string;

declare const NSStreamNetworkServiceTypeVideo: string;

declare const NSKeyValueValidationError: number;

declare const NSLinguisticTagParticle: string;

declare const NSUTF32BigEndianStringEncoding: number;

declare const NSFileWriteVolumeReadOnlyError: number;

declare const NSFeatureUnsupportedError: number;

declare const NSHTTPCookieVersion: string;

declare const NSStringTransformLatinToThai: string;

declare const NSFileWriteOutOfSpaceError: number;

declare const NSFileWriteInvalidFileNameError: number;

declare const NSFileReadUnknownStringEncodingError: number;

declare const NSURLFileProtectionCompleteWhenUserInactive: string;

declare const NSFileReadUnsupportedSchemeError: number;

declare const NSFileReadNoSuchFileError: number;

declare const NSLinguisticTagSchemeLemma: string;

declare const NSStringTransformLatinToKatakana: string;

declare const NSFileBusy: string;

declare const NSURLUbiquitousItemIsSharedKey: string;

declare const NSFileLockingError: number;

declare const NSURLErrorCancelledReasonInsufficientSystemResources: number;

declare const NSFileGroupOwnerAccountID: string;

declare const NSURLContentAccessDateKey: string;

declare const NSInvalidUnarchiveOperationException: string;

declare const NSXMLParserErrorDomain: string;

declare const NSIsNilTransformerName: string;

declare const NSIsNotNilTransformerName: string;

declare const NSHelpAnchorErrorKey: string;

declare const NSUbiquitousUserDefaultsNoCloudAccountNotification: string;

declare const NSArgumentDomain: string;

declare const NSGlobalDomain: string;

declare const NSURLErrorBackgroundSessionWasDisconnected: number;

declare const NSMetadataUbiquitousItemIsExternalDocumentKey: string;

declare const NSURLErrorInternationalRoamingOff: number;

declare const NSURLErrorDownloadDecodingFailedToComplete: number;

declare const NSURLVolumeSupportsRenamingKey: string;

declare const NSURLErrorDownloadDecodingFailedMidStream: number;

declare const NSHTTPCookiePort: string;

declare const NSURLErrorCannotMoveFile: number;

declare const NSURLErrorCannotCreateFile: number;

declare const NSURLErrorClientCertificateRejected: number;

declare const NSFileTypeDirectory: string;

declare const NSURLErrorServerCertificateNotYetValid: number;

declare const NSURLIsPurgeableKey: string;

declare const NSURLDirectoryEntryCountKey: string;

declare const NSURLErrorServerCertificateHasBadDate: number;

declare const NSURLErrorNoPermissionsToReadFile: number;

declare const NSURLErrorFileDoesNotExist: number;

declare const NSURLErrorCannotDecodeRawData: number;

declare const NSURLErrorUserAuthenticationRequired: number;

declare const NSPropertyListErrorMinimum: number;

declare const NSURLErrorResourceUnavailable: number;

declare const NSURLErrorNetworkConnectionLost: number;

declare const NSFileHandleOperationException: string;

declare const NSURLErrorUnsupportedURL: number;

declare const NSURLErrorBadURL: number;

declare const NSURLErrorNetworkUnavailableReasonKey: string;

declare const NSFileErrorMinimum: number;

declare const NSLocalizedRecoverySuggestionErrorKey: string;

declare const NSOSF1OperatingSystem: number;

declare const NSURLErrorCancelledReasonUserForceQuitApplication: number;

declare const NSProgressFileOperationKindCopying: string;

declare const NSURLErrorFailingURLStringErrorKey: string;

declare const NSFileReadCorruptFileError: number;

declare const NSURLErrorFailingURLErrorKey: string;

declare const NSSunOSOperatingSystem: number;

declare const NSURLVolumeSupportsSymbolicLinksKey: string;

declare const NSHPUXOperatingSystem: number;

declare const NSStringTransformLatinToCyrillic: string;

declare const NSURLProtectionSpaceFTP: string;

declare const NSLanguageIdentifierAttributeName: string;

declare const NSPropertyListReadCorruptError: number;

declare const NSStreamNetworkServiceTypeCallSignaling: string;

declare const NSStreamSocketSecurityLevelTLSv1: string;

declare const NSStreamSocketSSLErrorDomain: string;

declare const NSURLLabelColorKey: string;

declare const NSFileHandleDataAvailableNotification: string;

declare const NSStreamFileCurrentOffsetKey: string;

declare const NSStreamSOCKSProxyUserKey: string;

declare const NSStreamSOCKSProxyHostKey: string;

declare const NSValidationErrorMaximum: number;

declare const NSTextCheckingPhoneKey: string;

declare const NSTextCheckingStateKey: string;

declare const NSTextCheckingOrganizationKey: string;

declare const NSValidationErrorMinimum: number;

declare const NSURLIsUbiquitousItemKey: string;

declare const NSCalendarIdentifierJapanese: string;

declare const NSURLVolumeIdentifierKey: string;

declare const NSStreamDataWrittenToMemoryStreamKey: string;

declare const NSKeyValueChangeKindKey: string;

declare const NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSMetadataItemFSNameKey: string;

declare const NSURLVolumeIsAutomountedKey: string;

declare const NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSFileTypeBlockSpecial: string;

declare const NSMachErrorDomain: string;

declare const NSMapTableObjectPointerPersonality: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSMapTableCopyIn: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSKeyedArchiveRootObjectKey: string;

declare const NSKeyValueChangeNotificationIsPriorKey: string;

declare const NSKeyValueChangeIndexesKey: string;

declare const NSJapaneseCalendar: string;

declare const NSUnionOfSetsKeyValueOperator: string;

declare const NSFileWriteUnsupportedSchemeError: number;

declare const NSUndefinedKeyException: string;

declare const NSHTTPCookieSameSiteLax: string;

declare const NSFileProtectionCompleteUnlessOpen: string;

declare const NSHTTPCookieDiscard: string;

declare const NSHTTPCookieSecure: string;

declare const NSHTTPCookieValue: string;

declare const NSObjectHashCallBacks: NSHashTableCallBacks;

declare const NSHashTableObjectPointerPersonality: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSPersonNameComponentSuffix: string;

declare const NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;

declare const NSMetadataUbiquitousItemDownloadingErrorKey: string;

declare const NSFileSystemNodes: string;

declare const NSHTTPCookieMaximumAge: string;

declare const NSURLErrorBackgroundSessionInUseByAnotherProcess: number;

declare const NSFileSystemFreeSize: string;

declare const NSFileOwnerAccountID: string;

declare const NSURLVolumeNameKey: string;

declare const NSURLVolumeSupportsJournalingKey: string;

declare const NSInvalidReceivePortException: string;

declare const NS_UnknownByteOrder: number;

declare const NSLocaleExemplarCharacterSet: string;

declare const NSURLIsAliasFileKey: string;

declare const NSFileReferenceCount: string;

declare const NSOldStyleException: string;

declare const NSURLUbiquitousSharedItemRoleOwner: string;

declare const NSFileTypeUnknown: string;

declare const NSURLIsSymbolicLinkKey: string;

declare const NSURLVolumeIsInternalKey: string;

declare const NSGenericException: string;

declare const NSURLVolumeAvailableCapacityForImportantUsageKey: string;

declare const NSFileTypeRegular: string;

declare const NSBundleExecutableArchitectureX86_64: number;

declare const NSURLIsHiddenKey: string;

declare const NSCalendarIdentifierCoptic: string;

declare const NSFileTypeSocket: string;

declare const NSURLUbiquitousItemDownloadingStatusDownloaded: string;

declare const NSURLIsSparseKey: string;

declare const NSOperationQueueDefaultMaxConcurrentOperationCount: number;

declare const NSURLVolumeSupportsFileCloningKey: string;

declare const NSURLUbiquitousItemIsExcludedFromSyncKey: string;

declare const NSURLUbiquitousItemDownloadingStatusKey: string;

declare const NSURLUbiquitousItemPercentUploadedKey: string;

declare const NSURLUbiquitousItemIsDownloadingKey: string;

declare const NSURLVolumeSubtypeKey: string;

declare const NSURLProtectionSpaceFTPProxy: string;

declare const NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;

declare const NSProcessInfoPowerStateDidChangeNotification: string;

declare const NSURLVolumeSupportsExclusiveRenamingKey: string;

declare const NSURLVolumeIsLocalKey: string;

declare const NSCalendarIdentifierIndian: string;

declare const NSURLVolumeIsRemovableKey: string;

declare const NSURLVolumeIsBrowsableKey: string;

declare const NSURLVolumeSupportsRootDirectoryDatesKey: string;

declare const NSURLVolumeSupportsCaseSensitiveNamesKey: string;

declare const NSURLVolumeSupportsSparseFilesKey: string;

declare const NSURLUbiquitousItemPercentDownloadedKey: string;

declare const NSOwnedPointerHashCallBacks: NSHashTableCallBacks;

declare const NSDecimalNumberOverflowException: string;

declare const NSURLIsExcludedFromBackupKey: string;

declare const NSURLIsRegularFileKey: string;

declare const NSURLErrorDNSLookupFailed: number;

declare const NSExtensionHostDidEnterBackgroundNotification: string;

declare const NSURLFileProtectionKey: string;

declare const NSURLAuthenticationMethodClientCertificate: string;

declare const NSURLIsPackageKey: string;

declare const NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;

declare const NSURLUbiquitousItemDownloadingErrorKey: string;

declare const NSURLFileIdentifierKey: string;

declare const NSURLErrorCannotParseResponse: number;

declare const NSURLIsWritableKey: string;

declare const NSLocaleQuotationBeginDelimiterKey: string;

declare const NSISOLatin1StringEncoding: number;

declare const NSCalendarIdentifierGregorian: string;

declare const NSURLPreferredIOBlockSizeKey: string;

declare const NSLocaleLanguageCode: string;

declare const NSTextCheckingCityKey: string;

declare const NSURLEffectiveIconKey: string;

declare const NSDistinctUnionOfArraysKeyValueOperator: string;

declare const NSURLVolumeIsEjectableKey: string;

declare const NSURLContentTypeKey: string;

declare const NSItemProviderErrorDomain: string;

declare const NSCalendarIdentifierChinese: string;

declare const NSFileProtectionKey: string;

declare const NSURLSessionTaskPriorityHigh: number;

declare const NSURLIsApplicationKey: string;

declare const NSFileProtectionNone: string;

declare const NSURLNameKey: string;

declare const NSURLKeysOfUnsetValuesKey: string;

declare const NSURLVolumeSupportsAdvisoryFileLockingKey: string;

declare const NSFileHandleNotificationDataItem: string;

declare const NSFilePathErrorKey: string;

declare const NSLinguisticTagSchemeTokenType: string;

declare const NSHTTPCookieExpires: string;

declare const NSRecoveryAttempterErrorKey: string;

declare const NSMorphologyAttributeName: string;

declare const NSUbiquitousKeyValueStoreAccountChange: number;

declare const NSHTTPCookieCommentURL: string;

declare const NSWillBecomeMultiThreadedNotification: string;

declare const NSURLFileResourceTypeBlockSpecial: string;

declare const NSURLUbiquitousItemIsDownloadedKey: string;

declare const NSDestinationInvalidException: string;

declare const NSPersonNameComponentNickname: string;

declare const NSInflectionRuleAttributeName: string;

declare const NSExecutableLoadError: number;

declare const NSUndoCloseGroupingRunLoopOrdering: number;

declare const NSMacOSRomanStringEncoding: number;

declare const NSCalendarIdentifierEthiopicAmeteAlem: string;

declare const NSIslamicCalendar: string;

declare const NSHebrewCalendar: string;

declare const NSMetadataItemContentTypeKey: string;

declare const NSURLParentDirectoryURLKey: string;

declare const NSExecutableLinkError: number;

declare const NSPersonNameComponentKey: string;

declare const NSLocaleAlternateQuotationEndDelimiterKey: string;

declare const NSPortTimeoutException: string;

declare const NSFileReadTooLargeError: number;

declare const NSLocaleCollatorIdentifier: string;

declare const NSURLLocalizedLabelKey: string;

declare const NSLocaleCurrencyCode: string;

declare const NSLocaleAlternateQuotationBeginDelimiterKey: string;

declare const NSLocaleGroupingSeparator: string;

declare const NSLocaleUsesMetricSystem: string;

declare const NSImageURLAttributeName: string;

declare const NSLocaleCalendar: string;

declare const NSCocoaErrorDomain: string;

declare const NSProgressFileOperationKindDuplicating: string;

declare const NSFileWriteFileExistsError: number;

declare const NSCurrentLocaleDidChangeNotification: string;

declare const NSPresentationIntentAttributeName: string;

declare const NSSymbolStringEncoding: number;

declare const NSFileSystemFileNumber: string;

declare const NSInflectionAlternativeAttributeName: string;

declare const NSCalendarIdentifierIslamicUmmAlQura: string;

declare const NSURLVolumeLocalizedNameKey: string;

declare const NSAlternateDescriptionAttributeName: string;

declare const NSInlinePresentationIntentAttributeName: string;

declare const NSFileWriteUnknownError: number;

declare const NSUTF16StringEncoding: number;

declare const NSWrapCalendarComponents: number;

declare const NSLocaleIdentifier: string;

declare const NSNEXTSTEPStringEncoding: number;

declare const NSCalendarIdentifierIslamicTabular: string;

declare const NSLocaleDecimalSeparator: string;

declare const NSCalendarIdentifierIslamicCivil: string;

declare const NSUbiquitousFileUbiquityServerNotAvailable: number;

declare const NSURLUbiquitousItemIsUploadingKey: string;

declare const NSInvalidSendPortException: string;

declare const NSLocalizedFailureReasonErrorKey: string;

declare const NSURLVolumeSupportsImmutableFilesKey: string;

declare const NSProgressFileOperationKindUploading: string;

declare const NSProgressFileOperationKindDecompressingAfterDownloading: string;

declare const NSStreamSOCKSProxyVersion4: string;

declare const NSProgressFileOperationKindDownloading: string;

declare const NSProgressKindFile: string;

declare const NSURLVolumeSupportsHardLinksKey: string;

declare const NSProprietaryStringEncoding: number;

declare const NSFileCreationDate: string;

declare const NSCharacterConversionException: string;

declare const NSStringEncodingDetectionLossySubstitutionKey: string;

declare const NSDecimalNumberExactnessException: string;

declare const NSStringEncodingDetectionSuggestedEncodingsKey: string;

declare const NSStringTransformStripCombiningMarks: string;

declare const NSURLVolumeLocalizedFormatDescriptionKey: string;

declare const NSStringTransformHiraganaToKatakana: string;

declare const NSProcessInfoThermalStateDidChangeNotification: string;

declare const NSFileHandleNotificationFileHandleItem: string;

declare const NSUTF32LittleEndianStringEncoding: number;

declare const NSURLErrorFileOutsideSafeArea: number;

declare const NSURLUbiquitousItemDownloadRequestedKey: string;

declare const NSUTF32StringEncoding: number;

declare const NSNotFound: number;

declare const NSUTF16BigEndianStringEncoding: number;

declare const NSUnarchiveFromDataTransformerName: string;

declare const NSDidBecomeSingleThreadedNotification: string;

declare const NSWindowsCP1252StringEncoding: number;

declare const NSURLUbiquitousSharedItemCurrentUserRoleKey: string;

declare const NSItemProviderPreferredImageSizeKey: string;

declare const NSURLFileProtectionCompleteUntilFirstUserAuthentication: string;

declare const NSMetadataUbiquitousItemIsDownloadingKey: string;

declare const NSKeyValueChangeNewKey: string;

declare const NSHashTableWeakMemory: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSWindowsCP1253StringEncoding: number;

declare const NSURLVolumeUUIDStringKey: string;

declare const NSCalendarIdentifierEthiopicAmeteMihret: string;

declare const NSURLSessionUploadTaskResumeData: string;

declare const NSFileHFSTypeCode: string;

declare const NSSumKeyValueOperator: string;

declare const NSISOLatin2StringEncoding: number;

declare const NSHashTableCopyIn: interop.Enum<typeof NSPointerFunctionsOptions>;

declare const NSURLTypeIdentifierKey: string;

declare const NSURLVolumeSupportsAccessPermissionsKey: string;

declare const NSStringTransformLatinToHebrew: string;

declare const NSUbiquitousUserDefaultsDidChangeAccountsNotification: string;

declare const NSLinguisticTagWord: string;

declare const NSStringEncodingDetectionDisallowedEncodingsKey: string;

declare const NSThreadWillExitNotification: string;

declare const NSURLFileResourceTypeUnknown: string;

declare const NSURLFileResourceTypeKey: string;

declare const NSStringTransformLatinToHiragana: string;

declare const NSShiftJISStringEncoding: number;

declare const NSProgressThroughputKey: string;

declare const NSMetadataItemFSSizeKey: string;

declare const NSFoundationVersionNumber: number;

declare const NSJapaneseEUCStringEncoding: number;

declare const NSStringEncodingDetectionFromWindowsKey: string;

declare const NSBundleExecutableArchitectureI386: number;

declare const NSMetadataItemDisplayNameKey: string;

declare const NSURLErrorBackgroundSessionRequiresSharedContainer: number;

declare const NSURLVolumeSupportsVolumeSizesKey: string;

declare const NSHTTPCookieDomain: string;

declare const NSURLVolumeMaximumFileSizeKey: string;

declare const NSLocaleCollationIdentifier: string;

declare const NSCoderErrorMinimum: number;

declare const NSURLLocalizedNameKey: string;

declare const NSURLErrorSecureConnectionFailed: number;

declare const NSURLIsVolumeKey: string;

declare const NSURLUbiquitousItemIsUploadedKey: string;

declare const NSIslamicCivilCalendar: string;

declare const NSURLFileProtectionNone: string;

declare const NSMetadataUbiquitousItemContainerDisplayNameKey: string;

declare const NSStreamNetworkServiceTypeVoice: string;

declare const NSURLErrorRedirectToNonExistentLocation: number;

declare const NSURLFileResourceTypeSymbolicLink: string;

declare const NSIntMapValueCallBacks: NSMapTableValueCallBacks;

declare const NSStringTransformToXMLHex: string;

declare const NSKeyedUnarchiveFromDataTransformerName: string;

declare const NSURLVolumeURLForRemountingKey: string;

declare const NSLinguisticTagSchemeScript: string;

declare const NSFileNoSuchFileError: number;

declare const NSStreamSocketSecurityLevelSSLv3: string;

declare const NSStreamSocketSecurityLevelSSLv2: string;

declare const NSURLVolumeMountFromLocationKey: string;

declare const NSURLCanonicalPathKey: string;

declare const NSURLVolumeTypeNameKey: string;

declare const NSLinguisticTagPersonalName: string;

declare const NSHTTPCookieName: string;

declare const NSURLTotalFileAllocatedSizeKey: string;

declare const NSURLLinkCountKey: string;

declare const NSUTF8StringEncoding: number;

declare const NSUbiquitousKeyValueStoreQuotaViolationChange: number;

declare const NSItemProviderFileOptions: {
  NSItemProviderFileOptionOpenInPlace: 1,
};

declare const NSDateComponentsFormatterZeroFormattingBehavior: {
  None: 0,
  Default: 1,
  DropLeading: 2,
  DropMiddle: 4,
  DropTrailing: 8,
  DropAll: 14,
  Pad: 65536,
};

declare const NSInlinePresentationIntent: {
  Emphasized: 1,
  StronglyEmphasized: 2,
  Code: 4,
  Strikethrough: 32,
  SoftBreak: 64,
  LineBreak: 128,
  InlineHTML: 256,
  BlockHTML: 512,
};

declare const NSJSONReadingOptions: {
  MutableContainers: 1,
  MutableLeaves: 2,
  FragmentsAllowed: 4,
  JSON5Allowed: 8,
  TopLevelDictionaryAssumed: 16,
  AllowFragments: 4,
};

declare const NSXMLParserError: {
  Internal: 1,
  OutOfMemory: 2,
  DocumentStart: 3,
  EmptyDocument: 4,
  PrematureDocumentEnd: 5,
  InvalidHexCharacterRef: 6,
  InvalidDecimalCharacterRef: 7,
  InvalidCharacterRef: 8,
  InvalidCharacter: 9,
  CharacterRefAtEOF: 10,
  CharacterRefInProlog: 11,
  CharacterRefInEpilog: 12,
  CharacterRefInDTD: 13,
  EntityRefAtEOF: 14,
  EntityRefInProlog: 15,
  EntityRefInEpilog: 16,
  EntityRefInDTD: 17,
  ParsedEntityRefAtEOF: 18,
  ParsedEntityRefInProlog: 19,
  ParsedEntityRefInEpilog: 20,
  ParsedEntityRefInInternalSubset: 21,
  EntityReferenceWithoutName: 22,
  EntityReferenceMissingSemi: 23,
  ParsedEntityRefNoName: 24,
  ParsedEntityRefMissingSemi: 25,
  UndeclaredEntity: 26,
  UnparsedEntity: 28,
  EntityIsExternal: 29,
  EntityIsParameter: 30,
  UnknownEncoding: 31,
  EncodingNotSupported: 32,
  StringNotStarted: 33,
  StringNotClosed: 34,
  NamespaceDeclaration: 35,
  EntityNotStarted: 36,
  EntityNotFinished: 37,
  LessThanSymbolInAttribute: 38,
  AttributeNotStarted: 39,
  AttributeNotFinished: 40,
  AttributeHasNoValue: 41,
  AttributeRedefined: 42,
  LiteralNotStarted: 43,
  LiteralNotFinished: 44,
  CommentNotFinished: 45,
  ProcessingInstructionNotStarted: 46,
  ProcessingInstructionNotFinished: 47,
  NotationNotStarted: 48,
  NotationNotFinished: 49,
  AttributeListNotStarted: 50,
  AttributeListNotFinished: 51,
  MixedContentDeclNotStarted: 52,
  MixedContentDeclNotFinished: 53,
  ElementContentDeclNotStarted: 54,
  ElementContentDeclNotFinished: 55,
  XMLDeclNotStarted: 56,
  XMLDeclNotFinished: 57,
  ConditionalSectionNotStarted: 58,
  ConditionalSectionNotFinished: 59,
  ExternalSubsetNotFinished: 60,
  DOCTYPEDeclNotFinished: 61,
  MisplacedCDATAEndString: 62,
  CDATANotFinished: 63,
  MisplacedXMLDeclaration: 64,
  SpaceRequired: 65,
  SeparatorRequired: 66,
  NMTOKENRequired: 67,
  NAMERequired: 68,
  PCDATARequired: 69,
  URIRequired: 70,
  PublicIdentifierRequired: 71,
  LTRequired: 72,
  GTRequired: 73,
  LTSlashRequired: 74,
  EqualExpected: 75,
  TagNameMismatch: 76,
  UnfinishedTag: 77,
  StandaloneValue: 78,
  InvalidEncodingName: 79,
  CommentContainsDoubleHyphen: 80,
  InvalidEncoding: 81,
  ExternalStandaloneEntity: 82,
  InvalidConditionalSection: 83,
  EntityValueRequired: 84,
  NotWellBalanced: 85,
  ExtraContent: 86,
  InvalidCharacterInEntity: 87,
  ParsedEntityRefInInternal: 88,
  EntityRefLoop: 89,
  EntityBoundary: 90,
  InvalidURI: 91,
  URIFragment: 92,
  NoDTD: 94,
  DelegateAbortedParse: 512,
};

declare const NSDateComponentsFormatterUnitsStyle: {
  Positional: 0,
  Abbreviated: 1,
  Short: 2,
  Full: 3,
  SpellOut: 4,
  Brief: 5,
};

declare const NSGrammaticalNumber: {
  NotSet: 0,
  Singular: 1,
  Zero: 2,
  Plural: 3,
  PluralTwo: 4,
  PluralFew: 5,
  PluralMany: 6,
};

declare const NSMeasurementFormatterUnitOptions: {
  ProvidedUnit: 1,
  NaturalScale: 2,
  TemperatureWithoutUnit: 4,
};

declare const NSPresentationIntentKind: {
  Paragraph: 0,
  Header: 1,
  OrderedList: 2,
  UnorderedList: 3,
  ListItem: 4,
  CodeBlock: 5,
  BlockQuote: 6,
  ThematicBreak: 7,
  Table: 8,
  TableHeaderRow: 9,
  TableRow: 10,
  TableCell: 11,
};

declare const NSFileVersionAddingOptions: {
  NSFileVersionAddingByMoving: 1,
};

declare const NSSearchPathDirectory: {
  Application: 1,
  DemoApplication: 2,
  DeveloperApplication: 3,
  AdminApplication: 4,
  Library: 5,
  Developer: 6,
  User: 7,
  Documentation: 8,
  Document: 9,
  CoreService: 10,
  AutosavedInformation: 11,
  Desktop: 12,
  Caches: 13,
  ApplicationSupport: 14,
  Downloads: 15,
  InputMethods: 16,
  Movies: 17,
  Music: 18,
  Pictures: 19,
  PrinterDescription: 20,
  SharedPublic: 21,
  PreferencePanes: 22,
  ItemReplacement: 99,
  AllApplications: 100,
  AllLibraries: 101,
  Trash: 102,
};

declare const NSFileWrapperReadingOptions: {
  Immediate: 1,
  WithoutMapping: 2,
};

declare const NSVolumeEnumerationOptions: {
  SkipHiddenVolumes: 2,
  ProduceFileReferenceURLs: 4,
};

declare const NSDataBase64EncodingOptions: {
  Encoding64CharacterLineLength: 1,
  Encoding76CharacterLineLength: 2,
  EncodingEndLineWithCarriageReturn: 16,
  EncodingEndLineWithLineFeed: 32,
};

declare const NSPropertyListMutabilityOptions: {
  Immutable: 0,
  MutableContainers: 1,
  MutableContainersAndLeaves: 2,
};

declare const NSTextCheckingType: {
  Orthography: 1,
  Spelling: 2,
  Grammar: 4,
  Date: 8,
  Address: 16,
  Link: 32,
  Quote: 64,
  Dash: 128,
  Replacement: 256,
  Correction: 512,
  RegularExpression: 1024,
  PhoneNumber: 2048,
  TransitInformation: 4096,
};

declare const NSURLBookmarkResolutionOptions: {
  UI: 256,
  Mounting: 512,
  ImplicitStartAccessing: 32768,
};

declare const NSURLRequestAttribution: {
  Developer: 0,
  User: 1,
};

declare const NSNumberFormatterStyle: {
  No: 0,
  Decimal: 1,
  Currency: 2,
  Percent: 3,
  Scientific: 4,
  SpellOut: 5,
  Ordinal: 6,
  CurrencyISOCode: 8,
  CurrencyPlural: 9,
  CurrencyAccounting: 10,
};

declare const NSNumberFormatterBehavior: {
  BehaviorDefault: 0,
  Behavior10_4: 1040,
};

declare const NSMatchingFlags: {
  Progress: 1,
  Completed: 2,
  HitEnd: 4,
  RequiredEnd: 8,
  InternalError: 16,
};

declare const NSDirectoryEnumerationOptions: {
  SkipsSubdirectoryDescendants: 1,
  SkipsPackageDescendants: 2,
  SkipsHiddenFiles: 4,
  IncludesDirectoriesPostOrder: 8,
  ProducesRelativePathURLs: 16,
};

declare const NSRegularExpressionOptions: {
  CaseInsensitive: 1,
  AllowCommentsAndWhitespace: 2,
  IgnoreMetacharacters: 4,
  DotMatchesLineSeparators: 8,
  AnchorsMatchLines: 16,
  UseUnixLineSeparators: 32,
  UseUnicodeWordBoundaries: 64,
};

declare const NSStringEnumerationOptions: {
  ByLines: 0,
  ByParagraphs: 1,
  ByComposedCharacterSequences: 2,
  ByWords: 3,
  BySentences: 4,
  ByCaretPositions: 5,
  ByDeletionClusters: 6,
  Reverse: 256,
  SubstringNotRequired: 512,
  Localized: 1024,
};

declare const NSQualityOfService: {
  UserInteractive: 33,
  UserInitiated: 25,
  Utility: 17,
  Background: 9,
  Default: -1,
};

declare const NSOrderedCollectionDifferenceCalculationOptions: {
  OmitInsertedObjects: 1,
  OmitRemovedObjects: 2,
  InferMoves: 4,
};

declare const NSPostingStyle: {
  WhenIdle: 1,
  ASAP: 2,
  Now: 3,
};

declare const NSURLSessionTaskMetricsDomainResolutionProtocol: {
  Unknown: 0,
  UDP: 1,
  TCP: 2,
  TLS: 3,
  HTTPS: 4,
};

declare const NSDataReadingOptions: {
  DataReadingMappedIfSafe: 1,
  DataReadingUncached: 2,
  DataReadingMappedAlways: 8,
  DataReadingMapped: 1,
  MappedRead: 1,
  UncachedRead: 2,
};

declare const NSDataWritingOptions: {
  DataWritingAtomic: 1,
  DataWritingWithoutOverwriting: 2,
  DataWritingFileProtectionNone: 268435456,
  DataWritingFileProtectionComplete: 536870912,
  DataWritingFileProtectionCompleteUnlessOpen: 805306368,
  DataWritingFileProtectionCompleteUntilFirstUserAuthentication: 1073741824,
  DataWritingFileProtectionCompleteWhenUserInactive: 1342177280,
  DataWritingFileProtectionMask: 4026531840,
  AtomicWrite: 1,
};

declare const NSURLCredentialPersistence: {
  None: 0,
  ForSession: 1,
  Permanent: 2,
  Synchronizable: 3,
};

declare const NSFileVersionReplacingOptions: {
  NSFileVersionReplacingByMoving: 1,
};

declare const NSAttributedStringMarkdownParsingFailurePolicy: {
  Error: 0,
  PartiallyParsedIfPossible: 1,
};

declare const NSPresentationIntentTableColumnAlignment: {
  Left: 0,
  Center: 1,
  Right: 2,
};

declare const NSEnergyFormatterUnit: {
  Joule: 11,
  Kilojoule: 14,
  Calorie: 1793,
  Kilocalorie: 1794,
};

declare const NSNumberFormatterRoundingMode: {
  Ceiling: 0,
  Floor: 1,
  Down: 2,
  Up: 3,
  HalfEven: 4,
  HalfDown: 5,
  HalfUp: 6,
};

declare const NSURLErrorNetworkUnavailableReason: {
  Cellular: 0,
  Expensive: 1,
  Constrained: 2,
};

declare const NSPointerFunctionsOptions: {
  StrongMemory: 0,
  OpaqueMemory: 2,
  MallocMemory: 3,
  MachVirtualMemory: 4,
  WeakMemory: 5,
  ObjectPersonality: 0,
  OpaquePersonality: 256,
  ObjectPointerPersonality: 512,
  CStringPersonality: 768,
  StructPersonality: 1024,
  IntegerPersonality: 1280,
  CopyIn: 65536,
};

declare const NSURLRequestNetworkServiceType: {
  Default: 0,
  VoIP: 1,
  Video: 2,
  Background: 3,
  Voice: 4,
  ResponsiveData: 6,
  AVStreaming: 8,
  ResponsiveAV: 9,
  CallSignaling: 11,
};

declare const NSGrammaticalDefiniteness: {
  NotSet: 0,
  Indefinite: 1,
  Definite: 2,
};

declare const NSNetServiceOptions: {
  NoAutoRename: 1,
  ListenForConnections: 2,
};

declare const NSRelativeDateTimeFormatterUnitsStyle: {
  Full: 0,
  SpellOut: 1,
  Short: 2,
  Abbreviated: 3,
};

declare const NSGrammaticalCase: {
  NotSet: 0,
  Nominative: 1,
  Accusative: 2,
  Dative: 3,
  Genitive: 4,
  Prepositional: 5,
  Ablative: 6,
  Adessive: 7,
  Allative: 8,
  Elative: 9,
  Illative: 10,
  Essive: 11,
  Inessive: 12,
  Locative: 13,
  Translative: 14,
};

declare const NSURLSessionDelayedRequestDisposition: {
  ContinueLoading: 0,
  UseNewRequest: 1,
  Cancel: 2,
};

declare const NSDataCompressionAlgorithm: {
  LZFSE: 0,
  LZ4: 1,
  LZMA: 2,
  Zlib: 3,
};

declare const NSURLRelationship: {
  Contains: 0,
  Same: 1,
  Other: 2,
};

declare const NSURLSessionTaskState: {
  Running: 0,
  Suspended: 1,
  Canceling: 2,
  Completed: 3,
};

declare const NSByteCountFormatterUnits: {
  Default: 0,
  Bytes: 1,
  KB: 2,
  MB: 4,
  GB: 8,
  TB: 16,
  PB: 32,
  EB: 64,
  ZB: 128,
  YBOrHigher: 65280,
  All: 65535,
};

declare const NSURLCacheStoragePolicy: {
  Allowed: 0,
  AllowedInMemoryOnly: 1,
  NotAllowed: 2,
};

declare const NSItemProviderRepresentationVisibility: {
  All: 0,
  Team: 1,
  OwnProcess: 3,
};

declare const NSPersonNameComponentsFormatterOptions: {
  NSPersonNameComponentsFormatterPhonetic: 2,
};

declare const NSOperationQueuePriority: {
  VeryLow: -8,
  Low: -4,
  Normal: 0,
  High: 4,
  VeryHigh: 8,
};

declare const NSRelativeDateTimeFormatterStyle: {
  Numeric: 0,
  Named: 1,
};

declare const NSKeyValueSetMutationKind: {
  Union: 1,
  Minus: 2,
  Intersect: 3,
  Set: 4,
};

declare const NSNotificationCoalescing: {
  NoCoalescing: 0,
  CoalescingOnName: 1,
  CoalescingOnSender: 2,
};

declare const NSLocaleLanguageDirection: {
  Unknown: 0,
  LeftToRight: 1,
  RightToLeft: 2,
  TopToBottom: 3,
  BottomToTop: 4,
};

declare const NSURLSessionAuthChallengeDisposition: {
  UseCredential: 0,
  PerformDefaultHandling: 1,
  CancelAuthenticationChallenge: 2,
  RejectProtectionSpace: 3,
};

declare const NSGrammaticalDetermination: {
  NotSet: 0,
  Independent: 1,
  Dependent: 2,
};

declare const NSPropertyListFormat: {
  OpenStepFormat: 1,
  XMLFormat_v1_0: 100,
  BinaryFormat_v1_0: 200,
};

declare const NSCalendarOptions: {
  WrapComponents: 1,
  MatchStrictly: 2,
  SearchBackwards: 4,
  MatchPreviousTimePreservingSmallerUnits: 256,
  MatchNextTimePreservingSmallerUnits: 512,
  MatchNextTime: 1024,
  MatchFirst: 4096,
  MatchLast: 8192,
};

declare const NSURLSessionTaskMetricsResourceFetchType: {
  Unknown: 0,
  NetworkLoad: 1,
  ServerPush: 2,
  LocalCache: 3,
};

declare const NSItemProviderErrorCode: {
  Unknown: -1,
  ItemUnavailable: -1000,
  UnexpectedValueClass: -1100,
  UnavailableCoercion: -1200,
};

declare const NSStringEncodingConversionOptions: {
  AllowLossy: 1,
  ExternalRepresentation: 2,
};

declare const NSURLSessionWebSocketCloseCode: {
  Invalid: 0,
  NormalClosure: 1000,
  GoingAway: 1001,
  ProtocolError: 1002,
  UnsupportedData: 1003,
  NoStatusReceived: 1005,
  AbnormalClosure: 1006,
  InvalidFramePayloadData: 1007,
  PolicyViolation: 1008,
  MessageTooBig: 1009,
  MandatoryExtensionMissing: 1010,
  InternalServerError: 1011,
  TLSHandshakeFailure: 1015,
};

declare const NSURLSessionMultipathServiceType: {
  None: 0,
  Handover: 1,
  Interactive: 2,
  Aggregate: 3,
};

declare const NSComparisonPredicateModifier: {
  Direct: 0,
  All: 1,
  Any: 2,
};

declare const NSURLRequestCachePolicy: {
  UseProtocolCachePolicy: 0,
  ReloadIgnoringLocalCacheData: 1,
  ReloadIgnoringLocalAndRemoteCacheData: 4,
  ReloadIgnoringCacheData: 1,
  ReturnCacheDataElseLoad: 2,
  ReturnCacheDataDontLoad: 3,
  ReloadRevalidatingCacheData: 5,
};

declare const NSCompoundPredicateType: {
  Not: 0,
  And: 1,
  Or: 2,
};

declare const NSPredicateOperatorType: {
  LessThan: 0,
  LessThanOrEqualTo: 1,
  GreaterThan: 2,
  GreaterThanOrEqualTo: 3,
  EqualTo: 4,
  NotEqualTo: 5,
  Matches: 6,
  Like: 7,
  BeginsWith: 8,
  EndsWith: 9,
  In: 10,
  CustomSelector: 11,
  Contains: 99,
  Between: 100,
};

declare const NSByteCountFormatterCountStyle: {
  File: 0,
  Memory: 1,
  Decimal: 2,
  Binary: 3,
};

declare const NSFormattingContext: {
  Unknown: 0,
  Dynamic: 1,
  Standalone: 2,
  ListItem: 3,
  BeginningOfSentence: 4,
  MiddleOfSentence: 5,
};

declare const NSKeyValueChange: {
  Setting: 1,
  Insertion: 2,
  Removal: 3,
  Replacement: 4,
};

declare const NSExpressionType: {
  ConstantValue: 0,
  EvaluatedObject: 1,
  Variable: 2,
  KeyPath: 3,
  Function: 4,
  UnionSet: 5,
  IntersectSet: 6,
  MinusSet: 7,
  Subquery: 13,
  Aggregate: 14,
  AnyKey: 15,
  Block: 19,
  Conditional: 20,
};

declare const NSXMLParserExternalEntityResolvingPolicy: {
  Never: 0,
  NoNetwork: 1,
  SameOriginOnly: 2,
  Always: 3,
};

declare const NSFileCoordinatorReadingOptions: {
  WithoutChanges: 1,
  ResolvesSymbolicLink: 2,
  ImmediatelyAvailableMetadataOnly: 4,
  ForUploading: 8,
};

declare const NSStringCompareOptions: {
  CaseInsensitive: 1,
  Literal: 2,
  Backwards: 4,
  Anchored: 8,
  Numeric: 64,
  DiacriticInsensitive: 128,
  WidthInsensitive: 256,
  ForcedOrdering: 512,
  RegularExpression: 1024,
};

declare const NSGrammaticalPerson: {
  NotSet: 0,
  First: 1,
  Second: 2,
  Third: 3,
};

declare const NSStreamStatus: {
  NotOpen: 0,
  Opening: 1,
  Open: 2,
  Reading: 3,
  Writing: 4,
  AtEnd: 5,
  Closed: 6,
  Error: 7,
};

declare const NSNumberFormatterPadPosition: {
  BeforePrefix: 0,
  AfterPrefix: 1,
  BeforeSuffix: 2,
  AfterSuffix: 3,
};

declare const NSActivityOptions: {
  IdleDisplaySleepDisabled: 1099511627776,
  IdleSystemSleepDisabled: 1048576,
  SuddenTerminationDisabled: 16384,
  AutomaticTerminationDisabled: 32768,
  AnimationTrackingEnabled: 35184372088832,
  TrackingEnabled: 70368744177664,
  UserInitiated: 16777215,
  UserInitiatedAllowingIdleSystemSleep: 15728639,
  Background: 255,
  LatencyCritical: 1095216660480,
  UserInteractive: 1095233437695,
};

declare const NSMachPortOptions: {
  None: 0,
  SendRight: 1,
  ReceiveRight: 2,
};

declare const NSISO8601DateFormatOptions: {
  Year: 1,
  Month: 2,
  WeekOfYear: 4,
  Day: 16,
  Time: 32,
  TimeZone: 64,
  SpaceBetweenDateAndTime: 128,
  DashSeparatorInDate: 256,
  ColonSeparatorInTime: 512,
  ColonSeparatorInTimeZone: 1024,
  FractionalSeconds: 2048,
  FullDate: 275,
  FullTime: 1632,
  InternetDateTime: 1907,
};

declare const NSURLSessionWebSocketMessageType: {
  Data: 0,
  String: 1,
};

declare const NSMatchingOptions: {
  ReportProgress: 1,
  ReportCompletion: 2,
  Anchored: 4,
  WithTransparentBounds: 8,
  WithoutAnchoringBounds: 16,
};

declare const NSPersonNameComponentsFormatterStyle: {
  Default: 0,
  Short: 1,
  Medium: 2,
  Long: 3,
  Abbreviated: 4,
};

declare const NSSortOptions: {
  Concurrent: 1,
  Stable: 16,
};

declare const NSGrammaticalPronounType: {
  NotSet: 0,
  Personal: 1,
  Reflexive: 2,
  Possessive: 3,
};

declare const NSLinguisticTaggerOptions: {
  OmitWords: 1,
  OmitPunctuation: 2,
  OmitWhitespace: 4,
  OmitOther: 8,
  JoinNames: 16,
};

declare const NSTimeZoneNameStyle: {
  Standard: 0,
  ShortStandard: 1,
  DaylightSaving: 2,
  ShortDaylightSaving: 3,
  Generic: 4,
  ShortGeneric: 5,
};

declare const NSGrammaticalGender: {
  NotSet: 0,
  Feminine: 1,
  Masculine: 2,
  Neuter: 3,
};

declare const NSHTTPCookieAcceptPolicy: {
  Always: 0,
  Never: 1,
  OnlyFromMainDocumentDomain: 2,
};

declare const NSSearchPathDomainMask: {
  UserDomain: 1,
  LocalDomain: 2,
  NetworkDomain: 4,
  SystemDomain: 8,
  AllDomains: 65535,
};

declare const NSCalendarUnit: {
  CalendarUnitEra: 2,
  CalendarUnitYear: 4,
  CalendarUnitMonth: 8,
  CalendarUnitDay: 16,
  CalendarUnitHour: 32,
  CalendarUnitMinute: 64,
  CalendarUnitSecond: 128,
  CalendarUnitWeekday: 512,
  CalendarUnitWeekdayOrdinal: 1024,
  CalendarUnitQuarter: 2048,
  CalendarUnitWeekOfMonth: 4096,
  CalendarUnitWeekOfYear: 8192,
  CalendarUnitYearForWeekOfYear: 16384,
  CalendarUnitNanosecond: 32768,
  CalendarUnitCalendar: 1048576,
  CalendarUnitTimeZone: 2097152,
  EraCalendarUnit: 2,
  YearCalendarUnit: 4,
  MonthCalendarUnit: 8,
  DayCalendarUnit: 16,
  HourCalendarUnit: 32,
  MinuteCalendarUnit: 64,
  SecondCalendarUnit: 128,
  WeekCalendarUnit: 256,
  WeekdayCalendarUnit: 512,
  WeekdayOrdinalCalendarUnit: 1024,
  QuarterCalendarUnit: 2048,
  WeekOfMonthCalendarUnit: 4096,
  WeekOfYearCalendarUnit: 8192,
  YearForWeekOfYearCalendarUnit: 16384,
  CalendarCalendarUnit: 1048576,
  TimeZoneCalendarUnit: 2097152,
};

declare const NSCollectionChangeType: {
  Insert: 0,
  Remove: 1,
};

declare const NSBinarySearchingOptions: {
  FirstEqual: 256,
  LastEqual: 512,
  InsertionIndex: 1024,
};

declare const NSURLBookmarkCreationOptions: {
  PreferFileIDResolution: 256,
  MinimalBookmark: 512,
  SuitableForBookmarkFile: 1024,
  WithoutImplicitSecurityScope: 536870912,
};

declare const NSStreamEvent: {
  None: 0,
  OpenCompleted: 1,
  HasBytesAvailable: 2,
  HasSpaceAvailable: 4,
  ErrorOccurred: 8,
  EndEncountered: 16,
};

declare const NSGrammaticalPartOfSpeech: {
  NotSet: 0,
  Determiner: 1,
  Pronoun: 2,
  Letter: 3,
  Adverb: 4,
  Particle: 5,
  Adjective: 6,
  Adposition: 7,
  Verb: 8,
  Noun: 9,
  Conjunction: 10,
  Numeral: 11,
  Interjection: 12,
  Preposition: 13,
  Abbreviation: 14,
};

declare const NSXPCConnectionOptions: {
  NSXPCConnectionPrivileged: 4096,
};

declare const NSLengthFormatterUnit: {
  Millimeter: 8,
  Centimeter: 9,
  Meter: 11,
  Kilometer: 14,
  Inch: 1281,
  Foot: 1282,
  Yard: 1283,
  Mile: 1284,
};

declare const NSProcessInfoThermalState: {
  Nominal: 0,
  Fair: 1,
  Serious: 2,
  Critical: 3,
};

declare const NSFileCoordinatorWritingOptions: {
  ForDeleting: 1,
  ForMoving: 2,
  ForMerging: 4,
  ForReplacing: 8,
  ContentIndependentMetadataOnly: 16,
};

declare const NSDateFormatterBehavior: {
  BehaviorDefault: 0,
  Behavior10_4: 1040,
};

declare const NSCalculationError: {
  NoError: 0,
  LossOfPrecision: 1,
  Underflow: 2,
  Overflow: 3,
  DivideByZero: 4,
};

declare const NSFormattingUnitStyle: {
  Short: 1,
  Medium: 2,
  Long: 3,
};

declare const NSJSONWritingOptions: {
  PrettyPrinted: 1,
  SortedKeys: 2,
  FragmentsAllowed: 4,
  WithoutEscapingSlashes: 8,
};

declare const NSAttributedStringFormattingOptions: {
  InsertArgumentAttributesWithoutMerging: 1,
  ApplyReplacementIndexAttribute: 2,
};

declare const NSComparisonPredicateOptions: {
  CaseInsensitive: 1,
  DiacriticInsensitive: 2,
  Normalized: 4,
};

declare const NSDecodingFailurePolicy: {
  RaiseException: 0,
  SetErrorAndReturn: 1,
};

declare const NSFileManagerItemReplacementOptions: {
  UsingNewMetadataOnly: 1,
  WithoutDeletingBackupItem: 2,
};

declare const NSDateIntervalFormatterStyle: {
  No: 0,
  Short: 1,
  Medium: 2,
  Long: 3,
  Full: 4,
};

declare const NSAttributedStringEnumerationOptions: {
  Reverse: 2,
  LongestEffectiveRangeNotRequired: 1048576,
};

declare const NSMassFormatterUnit: {
  Gram: 11,
  Kilogram: 14,
  Ounce: 1537,
  Pound: 1538,
  Stone: 1539,
};

declare const NSDataBase64DecodingOptions: {
  NSDataBase64DecodingIgnoreUnknownCharacters: 1,
};

declare const NSNetServicesError: {
  UnknownError: -72000,
  CollisionError: -72001,
  NotFoundError: -72002,
  ActivityInProgress: -72003,
  BadArgumentError: -72004,
  CancelledError: -72005,
  InvalidError: -72006,
  TimeoutError: -72007,
  MissingRequiredConfigurationError: -72008,
};

declare const NSDateFormatterStyle: {
  No: 0,
  Short: 1,
  Medium: 2,
  Long: 3,
  Full: 4,
};

declare const NSKeyValueObservingOptions: {
  New: 1,
  Old: 2,
  Initial: 4,
  Prior: 8,
};

declare const NSLinguisticTaggerUnit: {
  Word: 0,
  Sentence: 1,
  Paragraph: 2,
  Document: 3,
};

declare const NSRoundingMode: {
  Plain: 0,
  Down: 1,
  Up: 2,
  Bankers: 3,
};

declare const NSFileWrapperWritingOptions: {
  Atomic: 1,
  WithNameUpdating: 2,
};

declare const NSEnumerationOptions: {
  Concurrent: 1,
  Reverse: 2,
};

declare const NSComparisonResult: {
  Ascending: -1,
  Same: 0,
  Descending: 1,
};

declare const NSAttributedStringMarkdownInterpretedSyntax: {
  Full: 0,
  InlineOnly: 1,
  InlineOnlyPreservingWhitespace: 2,
};

declare const NSURLSessionResponseDisposition: {
  Cancel: 0,
  Allow: 1,
  BecomeDownload: 2,
  BecomeStream: 3,
};

declare const NSDataSearchOptions: {
  Backwards: 1,
  Anchored: 2,
};

declare class NSOperatingSystemVersion {
  constructor(init?: NSOperatingSystemVersion);
  majorVersion: number;
  minorVersion: number;
  patchVersion: number;
}

declare class NSHashEnumerator {
  constructor(init?: NSHashEnumerator);
  _pi: number;
  _si: number;
  _bs: interop.Pointer;
}

declare class NSHashTableCallBacks {
  constructor(init?: NSHashTableCallBacks);
  hash: (p1: NSHashTable, p2: interop.PointerConvertible) => number | null;
  isEqual: (p1: NSHashTable, p2: interop.PointerConvertible, p3: interop.PointerConvertible) => boolean | null;
  retain: (p1: NSHashTable, p2: interop.PointerConvertible) => void | null;
  release: (p1: NSHashTable, p2: interop.PointerConvertible) => void | null;
  describe: (p1: NSHashTable, p2: interop.PointerConvertible) => string | null;
}

declare class NSSwappedDouble {
  constructor(init?: NSSwappedDouble);
  v: number;
}

declare class NSMapTableKeyCallBacks {
  constructor(init?: NSMapTableKeyCallBacks);
  hash: (p1: NSMapTable, p2: interop.PointerConvertible) => number | null;
  isEqual: (p1: NSMapTable, p2: interop.PointerConvertible, p3: interop.PointerConvertible) => boolean | null;
  retain: (p1: NSMapTable, p2: interop.PointerConvertible) => void | null;
  release: (p1: NSMapTable, p2: interop.PointerConvertible) => void | null;
  describe: (p1: NSMapTable, p2: interop.PointerConvertible) => string | null;
  notAKeyMarker: interop.Pointer;
}

declare class NSMapEnumerator {
  constructor(init?: NSMapEnumerator);
  _pi: number;
  _si: number;
  _bs: interop.Pointer;
}

declare class NSFastEnumerationState {
  constructor(init?: NSFastEnumerationState);
  state: number;
  itemsPtr: interop.Pointer;
  mutationsPtr: interop.Pointer;
  extra: unknown /* const array */;
}

declare class _NSRange {
  constructor(init?: _NSRange);
  location: number;
  length: number;
}

declare class _NSZone {
  constructor(init?: _NSZone);
}

declare class NSSwappedFloat {
  constructor(init?: NSSwappedFloat);
  v: number;
}

declare class NSMapTableValueCallBacks {
  constructor(init?: NSMapTableValueCallBacks);
  retain: (p1: NSMapTable, p2: interop.PointerConvertible) => void | null;
  release: (p1: NSMapTable, p2: interop.PointerConvertible) => void | null;
  describe: (p1: NSMapTable, p2: interop.PointerConvertible) => string | null;
}

declare class NSDecimal {
  constructor(init?: NSDecimal);
  _exponent: number;
  _length: number;
  _isNegative: number;
  _isCompact: number;
  _reserved: number;
  _mantissa: unknown /* const array */;
}

declare function NSStringFromSelector(aSelector: string): string;

declare function NSSelectorFromString(aSelectorName: string): string;

declare function NSStringFromClass(aClass: interop.Object): string;

declare function NSClassFromString(aClassName: string): interop.Object;

declare function NSStringFromProtocol(proto: interop.PointerConvertible): string;

declare function NSProtocolFromString(namestr: string): interop.Pointer;

declare function NSGetSizeAndAlignment(typePtr: string, sizep: interop.PointerConvertible, alignp: interop.PointerConvertible): string;

declare function NSLog(format: string): void;

declare function NSLogv(format: string, args: string): void;

declare function NSDefaultMallocZone(): interop.Pointer;

declare function NSCreateZone(startSize: number, granularity: number, canFree: boolean): interop.Pointer;

declare function NSRecycleZone(zone: interop.PointerConvertible): void;

declare function NSSetZoneName(zone: interop.PointerConvertible, name: string): void;

declare function NSZoneName(zone: interop.PointerConvertible): string;

declare function NSZoneFromPointer(ptr: interop.PointerConvertible): interop.Pointer;

declare function NSZoneMalloc(zone: interop.PointerConvertible, size: number): interop.Pointer;

declare function NSZoneCalloc(zone: interop.PointerConvertible, numElems: number, byteSize: number): interop.Pointer;

declare function NSZoneRealloc(zone: interop.PointerConvertible, ptr: interop.PointerConvertible, size: number): interop.Pointer;

declare function NSZoneFree(zone: interop.PointerConvertible, ptr: interop.PointerConvertible): void;

declare function NSPageSize(): number;

declare function NSLogPageSize(): number;

declare function NSRoundUpToMultipleOfPageSize(bytes: number): number;

declare function NSRoundDownToMultipleOfPageSize(bytes: number): number;

declare function NSAllocateMemoryPages(bytes: number): interop.Pointer;

declare function NSDeallocateMemoryPages(ptr: interop.PointerConvertible, bytes: number): void;

declare function NSCopyMemoryPages(source: interop.PointerConvertible, dest: interop.PointerConvertible, bytes: number): void;

declare function NSRealMemoryAvailable(): number;

declare function NSAllocateObject(aClass: interop.Object, extraBytes: number, zone: interop.PointerConvertible): interop.Object;

declare function NSDeallocateObject(object: interop.Object): void;

declare function NSCopyObject(object: interop.Object, extraBytes: number, zone: interop.PointerConvertible): interop.Object;

declare function NSShouldRetainWithZone(anObject: interop.Object, requestedZone: interop.PointerConvertible): boolean;

declare function NSIncrementExtraRefCount(object: interop.Object): void;

declare function NSDecrementExtraRefCountWasZero(object: interop.Object): boolean;

declare function NSExtraRefCount(object: interop.Object): number;

declare function NSUnionRange(range1: _NSRange, range2: _NSRange): _NSRange;

declare function NSIntersectionRange(range1: _NSRange, range2: _NSRange): _NSRange;

declare function NSStringFromRange(range: _NSRange): string;

declare function NSRangeFromString(aString: string): _NSRange;

declare function NSDecimalCopy(destination: interop.PointerConvertible, source: interop.PointerConvertible): void;

declare function NSDecimalCompact(number: interop.PointerConvertible): void;

declare function NSDecimalCompare(leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible): interop.Enum<typeof NSComparisonResult>;

declare function NSDecimalRound(result: interop.PointerConvertible, number: interop.PointerConvertible, scale: number, roundingMode: interop.Enum<typeof NSRoundingMode>): void;

declare function NSDecimalNormalize(number1: interop.PointerConvertible, number2: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalAdd(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalSubtract(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalMultiply(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalDivide(result: interop.PointerConvertible, leftOperand: interop.PointerConvertible, rightOperand: interop.PointerConvertible, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalPower(result: interop.PointerConvertible, number: interop.PointerConvertible, power: number, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalMultiplyByPowerOf10(result: interop.PointerConvertible, number: interop.PointerConvertible, power: number, roundingMode: interop.Enum<typeof NSRoundingMode>): interop.Enum<typeof NSCalculationError>;

declare function NSDecimalString(dcm: interop.PointerConvertible, locale: interop.Object): string;

declare function NSGetUncaughtExceptionHandler(): (p1: NSException) => void;

declare function NSSetUncaughtExceptionHandler(p1: (p1: NSException) => void): void;

declare function NSUserName(): string;

declare function NSFullUserName(): string;

declare function NSHomeDirectory(): string;

declare function NSHomeDirectoryForUser(userName: string): string;

declare function NSTemporaryDirectory(): string;

declare function NSOpenStepRootDirectory(): string;

declare function NSSearchPathForDirectoriesInDomains(directory: interop.Enum<typeof NSSearchPathDirectory>, domainMask: interop.Enum<typeof NSSearchPathDomainMask>, expandTilde: boolean): NSArray;

declare function NSFreeHashTable(table: NSHashTable): void;

declare function NSResetHashTable(table: NSHashTable): void;

declare function NSCompareHashTables(table1: NSHashTable, table2: NSHashTable): boolean;

declare function NSCopyHashTableWithZone(table: NSHashTable, zone: interop.PointerConvertible): NSHashTable;

declare function NSHashGet(table: NSHashTable, pointer: interop.PointerConvertible): interop.Pointer;

declare function NSHashInsert(table: NSHashTable, pointer: interop.PointerConvertible): void;

declare function NSHashInsertKnownAbsent(table: NSHashTable, pointer: interop.PointerConvertible): void;

declare function NSHashInsertIfAbsent(table: NSHashTable, pointer: interop.PointerConvertible): interop.Pointer;

declare function NSHashRemove(table: NSHashTable, pointer: interop.PointerConvertible): void;

declare function NSEnumerateHashTable(table: NSHashTable): NSHashEnumerator;

declare function NSNextHashEnumeratorItem(enumerator: interop.PointerConvertible): interop.Pointer;

declare function NSEndHashTableEnumeration(enumerator: interop.PointerConvertible): void;

declare function NSCountHashTable(table: NSHashTable): number;

declare function NSStringFromHashTable(table: NSHashTable): string;

declare function NSAllHashTableObjects(table: NSHashTable): NSArray;

declare function NSCreateHashTableWithZone(callBacks: NSHashTableCallBacks, capacity: number, zone: interop.PointerConvertible): NSHashTable;

declare function NSCreateHashTable(callBacks: NSHashTableCallBacks, capacity: number): NSHashTable;

declare function NSFreeMapTable(table: NSMapTable): void;

declare function NSResetMapTable(table: NSMapTable): void;

declare function NSCompareMapTables(table1: NSMapTable, table2: NSMapTable): boolean;

declare function NSCopyMapTableWithZone(table: NSMapTable, zone: interop.PointerConvertible): NSMapTable;

declare function NSMapMember(table: NSMapTable, key: interop.PointerConvertible, originalKey: interop.PointerConvertible, value: interop.PointerConvertible): boolean;

declare function NSMapGet(table: NSMapTable, key: interop.PointerConvertible): interop.Pointer;

declare function NSMapInsert(table: NSMapTable, key: interop.PointerConvertible, value: interop.PointerConvertible): void;

declare function NSMapInsertKnownAbsent(table: NSMapTable, key: interop.PointerConvertible, value: interop.PointerConvertible): void;

declare function NSMapInsertIfAbsent(table: NSMapTable, key: interop.PointerConvertible, value: interop.PointerConvertible): interop.Pointer;

declare function NSMapRemove(table: NSMapTable, key: interop.PointerConvertible): void;

declare function NSEnumerateMapTable(table: NSMapTable): NSMapEnumerator;

declare function NSNextMapEnumeratorPair(enumerator: interop.PointerConvertible, key: interop.PointerConvertible, value: interop.PointerConvertible): boolean;

declare function NSEndMapTableEnumeration(enumerator: interop.PointerConvertible): void;

declare function NSCountMapTable(table: NSMapTable): number;

declare function NSStringFromMapTable(table: NSMapTable): string;

declare function NSAllMapTableKeys(table: NSMapTable): NSArray;

declare function NSAllMapTableValues(table: NSMapTable): NSArray;

declare function NSCreateMapTableWithZone(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number, zone: interop.PointerConvertible): NSMapTable;

declare function NSCreateMapTable(keyCallBacks: NSMapTableKeyCallBacks, valueCallBacks: NSMapTableValueCallBacks, capacity: number): NSMapTable;

declare interface NSKeyedUnarchiverDelegate extends NSObjectProtocol {
  unarchiverCannotDecodeObjectOfClassNameOriginalClasses?(unarchiver: NSKeyedUnarchiver, name: string, classNames: NSArray<interop.Object> | Array<interop.Object>): interop.Object;

  unarchiverDidDecodeObject?(unarchiver: NSKeyedUnarchiver, object: interop.Object | null): interop.Object;

  unarchiverWillReplaceObjectWithObject?(unarchiver: NSKeyedUnarchiver, object: interop.Object, newObject: interop.Object): void;

  unarchiverWillFinish?(unarchiver: NSKeyedUnarchiver): void;

  unarchiverDidFinish?(unarchiver: NSKeyedUnarchiver): void;
}

declare class NSKeyedUnarchiverDelegate extends NativeObject implements NSKeyedUnarchiverDelegate {
}

declare interface NSURLProtocolClient extends NSObjectProtocol {
  URLProtocolWasRedirectedToRequestRedirectResponse(protocol: NSURLProtocol, request: NSURLRequest, redirectResponse: NSURLResponse): void;

  URLProtocolCachedResponseIsValid(protocol: NSURLProtocol, cachedResponse: NSCachedURLResponse): void;

  URLProtocolDidReceiveResponseCacheStoragePolicy(protocol: NSURLProtocol, response: NSURLResponse, policy: interop.Enum<typeof NSURLCacheStoragePolicy>): void;

  URLProtocolDidLoadData(protocol: NSURLProtocol, data: NSData): void;

  URLProtocolDidFinishLoading(protocol: NSURLProtocol): void;

  URLProtocolDidFailWithError(protocol: NSURLProtocol, error: NSError): void;

  URLProtocolDidReceiveAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;

  URLProtocolDidCancelAuthenticationChallenge(protocol: NSURLProtocol, challenge: NSURLAuthenticationChallenge): void;
}

declare class NSURLProtocolClient extends NativeObject implements NSURLProtocolClient {
}

declare interface NSNetServiceDelegate extends NSObjectProtocol {
  netServiceWillPublish?(sender: NSNetService): void;

  netServiceDidPublish?(sender: NSNetService): void;

  netServiceDidNotPublish?(sender: NSNetService, errorDict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  netServiceWillResolve?(sender: NSNetService): void;

  netServiceDidResolveAddress?(sender: NSNetService): void;

  netServiceDidNotResolve?(sender: NSNetService, errorDict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  netServiceDidStop?(sender: NSNetService): void;

  netServiceDidUpdateTXTRecordData?(sender: NSNetService, data: NSData): void;

  netServiceDidAcceptConnectionWithInputStreamOutputStream?(sender: NSNetService, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

declare class NSNetServiceDelegate extends NativeObject implements NSNetServiceDelegate {
}

declare interface NSURLConnectionDelegate extends NSObjectProtocol {
  connectionDidFailWithError?(connection: NSURLConnection, error: NSError): void;

  connectionShouldUseCredentialStorage?(connection: NSURLConnection): boolean;

  connectionWillSendRequestForAuthenticationChallenge?(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;

  connectionCanAuthenticateAgainstProtectionSpace?(connection: NSURLConnection, protectionSpace: NSURLProtectionSpace): boolean;

  connectionDidReceiveAuthenticationChallenge?(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;

  connectionDidCancelAuthenticationChallenge?(connection: NSURLConnection, challenge: NSURLAuthenticationChallenge): void;
}

declare class NSURLConnectionDelegate extends NativeObject implements NSURLConnectionDelegate {
}

declare interface NSProgressReporting extends NSObjectProtocol {
  readonly progress: NSProgress;
}

declare class NSProgressReporting extends NativeObject implements NSProgressReporting {
}

declare interface NSMetadataQueryDelegate extends NSObjectProtocol {
  metadataQueryReplacementObjectForResultObject?(query: NSMetadataQuery, result: NSMetadataItem): interop.Object;

  metadataQueryReplacementValueForAttributeValue?(query: NSMetadataQuery, attrName: string, attrValue: interop.Object): interop.Object;
}

declare class NSMetadataQueryDelegate extends NativeObject implements NSMetadataQueryDelegate {
}

declare interface NSCacheDelegate extends NSObjectProtocol {
  cacheWillEvictObject?(cache: NSCache, obj: interop.Object): void;
}

declare class NSCacheDelegate extends NativeObject implements NSCacheDelegate {
}

declare interface NSStreamDelegate extends NSObjectProtocol {
  streamHandleEvent?(aStream: NSStream, eventCode: interop.Enum<typeof NSStreamEvent>): void;
}

declare class NSStreamDelegate extends NativeObject implements NSStreamDelegate {
}

declare interface NSURLSessionStreamDelegate extends NSURLSessionTaskDelegate {
  URLSessionReadClosedForStreamTask?(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;

  URLSessionWriteClosedForStreamTask?(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;

  URLSessionBetterRouteDiscoveredForStreamTask?(session: NSURLSession, streamTask: NSURLSessionStreamTask): void;

  URLSessionStreamTaskDidBecomeInputStreamOutputStream?(session: NSURLSession, streamTask: NSURLSessionStreamTask, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

declare class NSURLSessionStreamDelegate extends NativeObject implements NSURLSessionStreamDelegate {
}

declare interface NSFileManagerDelegate extends NSObjectProtocol {
  fileManagerShouldCopyItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;

  fileManagerShouldCopyItemAtURLToURL?(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;

  fileManagerShouldProceedAfterErrorCopyingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;

  fileManagerShouldProceedAfterErrorCopyingItemAtURLToURL?(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;

  fileManagerShouldMoveItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;

  fileManagerShouldMoveItemAtURLToURL?(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;

  fileManagerShouldProceedAfterErrorMovingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;

  fileManagerShouldProceedAfterErrorMovingItemAtURLToURL?(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;

  fileManagerShouldLinkItemAtPathToPath?(fileManager: NSFileManager, srcPath: string, dstPath: string): boolean;

  fileManagerShouldLinkItemAtURLToURL?(fileManager: NSFileManager, srcURL: NSURL, dstURL: NSURL): boolean;

  fileManagerShouldProceedAfterErrorLinkingItemAtPathToPath?(fileManager: NSFileManager, error: NSError, srcPath: string, dstPath: string): boolean;

  fileManagerShouldProceedAfterErrorLinkingItemAtURLToURL?(fileManager: NSFileManager, error: NSError, srcURL: NSURL, dstURL: NSURL): boolean;

  fileManagerShouldRemoveItemAtPath?(fileManager: NSFileManager, path: string): boolean;

  fileManagerShouldRemoveItemAtURL?(fileManager: NSFileManager, URL: NSURL): boolean;

  fileManagerShouldProceedAfterErrorRemovingItemAtPath?(fileManager: NSFileManager, error: NSError, path: string): boolean;

  fileManagerShouldProceedAfterErrorRemovingItemAtURL?(fileManager: NSFileManager, error: NSError, URL: NSURL): boolean;
}

declare class NSFileManagerDelegate extends NativeObject implements NSFileManagerDelegate {
}

declare interface NSXPCProxyCreating {
  readonly remoteObjectProxy: interop.Object;

  remoteObjectProxyWithErrorHandler(handler: (p1: NSError) => void): interop.Object;

  synchronousRemoteObjectProxyWithErrorHandler?(handler: (p1: NSError) => void): interop.Object;
}

declare class NSXPCProxyCreating extends NativeObject implements NSXPCProxyCreating {
}

declare interface NSPortDelegate extends NSObjectProtocol {
  handlePortMessage?(message: interop.Object): void;
}

declare class NSPortDelegate extends NativeObject implements NSPortDelegate {
}

declare interface NSMutableCopying {
  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSMutableCopying extends NativeObject implements NSMutableCopying {
}

declare interface NSMachPortDelegate extends NSPortDelegate {
  handleMachMessage?(msg: interop.PointerConvertible): void;
}

declare class NSMachPortDelegate extends NativeObject implements NSMachPortDelegate {
}

declare interface NSURLConnectionDownloadDelegate extends NSURLConnectionDelegate {
  connectionDidWriteDataTotalBytesWrittenExpectedTotalBytes?(connection: NSURLConnection, bytesWritten: number, totalBytesWritten: number, expectedTotalBytes: number): void;

  connectionDidResumeDownloadingTotalBytesWrittenExpectedTotalBytes?(connection: NSURLConnection, totalBytesWritten: number, expectedTotalBytes: number): void;

  connectionDidFinishDownloadingDestinationURL(connection: NSURLConnection, destinationURL: NSURL): void;
}

declare class NSURLConnectionDownloadDelegate extends NativeObject implements NSURLConnectionDownloadDelegate {
}

declare interface NSCoding {
  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCoding extends NativeObject implements NSCoding {
}

declare interface NSNetServiceBrowserDelegate extends NSObjectProtocol {
  netServiceBrowserWillSearch?(browser: NSNetServiceBrowser): void;

  netServiceBrowserDidStopSearch?(browser: NSNetServiceBrowser): void;

  netServiceBrowserDidNotSearch?(browser: NSNetServiceBrowser, errorDict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  netServiceBrowserDidFindDomainMoreComing?(browser: NSNetServiceBrowser, domainString: string, moreComing: boolean): void;

  netServiceBrowserDidFindServiceMoreComing?(browser: NSNetServiceBrowser, service: NSNetService, moreComing: boolean): void;

  netServiceBrowserDidRemoveDomainMoreComing?(browser: NSNetServiceBrowser, domainString: string, moreComing: boolean): void;

  netServiceBrowserDidRemoveServiceMoreComing?(browser: NSNetServiceBrowser, service: NSNetService, moreComing: boolean): void;
}

declare class NSNetServiceBrowserDelegate extends NativeObject implements NSNetServiceBrowserDelegate {
}

declare interface NSDiscardableContent {
  beginContentAccess(): boolean;

  endContentAccess(): void;

  discardContentIfPossible(): void;

  isContentDiscarded(): boolean;
}

declare class NSDiscardableContent extends NativeObject implements NSDiscardableContent {
}

declare interface NSURLSessionWebSocketDelegate extends NSURLSessionTaskDelegate {
  URLSessionWebSocketTaskDidOpenWithProtocol?(session: NSURLSession, webSocketTask: NSURLSessionWebSocketTask, protocol: string | null): void;

  URLSessionWebSocketTaskDidCloseWithCodeReason?(session: NSURLSession, webSocketTask: NSURLSessionWebSocketTask, closeCode: interop.Enum<typeof NSURLSessionWebSocketCloseCode>, reason: NSData | null): void;
}

declare class NSURLSessionWebSocketDelegate extends NativeObject implements NSURLSessionWebSocketDelegate {
}

declare interface NSXMLParserDelegate extends NSObjectProtocol {
  parserDidStartDocument?(parser: NSXMLParser): void;

  parserDidEndDocument?(parser: NSXMLParser): void;

  parserFoundNotationDeclarationWithNamePublicIDSystemID?(parser: NSXMLParser, name: string, publicID: string | null, systemID: string | null): void;

  parserFoundUnparsedEntityDeclarationWithNamePublicIDSystemIDNotationName?(parser: NSXMLParser, name: string, publicID: string | null, systemID: string | null, notationName: string | null): void;

  parserFoundAttributeDeclarationWithNameForElementTypeDefaultValue?(parser: NSXMLParser, attributeName: string, elementName: string, type: string | null, defaultValue: string | null): void;

  parserFoundElementDeclarationWithNameModel?(parser: NSXMLParser, elementName: string, model: string): void;

  parserFoundInternalEntityDeclarationWithNameValue?(parser: NSXMLParser, name: string, value: string | null): void;

  parserFoundExternalEntityDeclarationWithNamePublicIDSystemID?(parser: NSXMLParser, name: string, publicID: string | null, systemID: string | null): void;

  parserDidStartElementNamespaceURIQualifiedNameAttributes?(parser: NSXMLParser, elementName: string, namespaceURI: string | null, qName: string | null, attributeDict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  parserDidEndElementNamespaceURIQualifiedName?(parser: NSXMLParser, elementName: string, namespaceURI: string | null, qName: string | null): void;

  parserDidStartMappingPrefixToURI?(parser: NSXMLParser, prefix: string, namespaceURI: string): void;

  parserDidEndMappingPrefix?(parser: NSXMLParser, prefix: string): void;

  parserFoundCharacters?(parser: NSXMLParser, string: string): void;

  parserFoundIgnorableWhitespace?(parser: NSXMLParser, whitespaceString: string): void;

  parserFoundProcessingInstructionWithTargetData?(parser: NSXMLParser, target: string, data: string | null): void;

  parserFoundComment?(parser: NSXMLParser, comment: string): void;

  parserFoundCDATA?(parser: NSXMLParser, CDATABlock: NSData): void;

  parserResolveExternalEntityNameSystemID?(parser: NSXMLParser, name: string, systemID: string | null): NSData;

  parserParseErrorOccurred?(parser: NSXMLParser, parseError: NSError): void;

  parserValidationErrorOccurred?(parser: NSXMLParser, validationError: NSError): void;
}

declare class NSXMLParserDelegate extends NativeObject implements NSXMLParserDelegate {
}

declare interface NSURLSessionDelegate extends NSObjectProtocol {
  URLSessionDidBecomeInvalidWithError?(session: NSURLSession, error: NSError | null): void;

  URLSessionDidReceiveChallengeCompletionHandler?(session: NSURLSession, challenge: NSURLAuthenticationChallenge, completionHandler: (p1: interop.Enum<typeof NSURLSessionAuthChallengeDisposition>, p2: NSURLCredential) => void | null): void;

  URLSessionDidFinishEventsForBackgroundURLSession?(session: NSURLSession): void;
}

declare class NSURLSessionDelegate extends NativeObject implements NSURLSessionDelegate {
}

declare interface NSUserActivityDelegate extends NSObjectProtocol {
  userActivityWillSave?(userActivity: NSUserActivity): void;

  userActivityWasContinued?(userActivity: NSUserActivity): void;

  userActivityDidReceiveInputStreamOutputStream?(userActivity: NSUserActivity, inputStream: NSInputStream, outputStream: NSOutputStream): void;
}

declare class NSUserActivityDelegate extends NativeObject implements NSUserActivityDelegate {
}

declare interface NSURLSessionTaskDelegate extends NSURLSessionDelegate {
  URLSessionDidCreateTask?(session: NSURLSession, task: NSURLSessionTask): void;

  URLSessionTaskWillBeginDelayedRequestCompletionHandler?(session: NSURLSession, task: NSURLSessionTask, request: NSURLRequest, completionHandler: (p1: interop.Enum<typeof NSURLSessionDelayedRequestDisposition>, p2: NSURLRequest) => void | null): void;

  URLSessionTaskIsWaitingForConnectivity?(session: NSURLSession, task: NSURLSessionTask): void;

  URLSessionTaskWillPerformHTTPRedirectionNewRequestCompletionHandler?(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse, request: NSURLRequest, completionHandler: (p1: NSURLRequest) => void | null): void;

  URLSessionTaskDidReceiveChallengeCompletionHandler?(session: NSURLSession, task: NSURLSessionTask, challenge: NSURLAuthenticationChallenge, completionHandler: (p1: interop.Enum<typeof NSURLSessionAuthChallengeDisposition>, p2: NSURLCredential) => void | null): void;

  URLSessionTaskNeedNewBodyStream?(session: NSURLSession, task: NSURLSessionTask, completionHandler: (p1: NSInputStream) => void | null): void;

  URLSessionTaskNeedNewBodyStreamFromOffsetCompletionHandler?(session: NSURLSession, task: NSURLSessionTask, offset: number, completionHandler: (p1: NSInputStream) => void | null): void;

  URLSessionTaskDidSendBodyDataTotalBytesSentTotalBytesExpectedToSend?(session: NSURLSession, task: NSURLSessionTask, bytesSent: number, totalBytesSent: number, totalBytesExpectedToSend: number): void;

  URLSessionTaskDidReceiveInformationalResponse?(session: NSURLSession, task: NSURLSessionTask, response: NSHTTPURLResponse): void;

  URLSessionTaskDidFinishCollectingMetrics?(session: NSURLSession, task: NSURLSessionTask, metrics: NSURLSessionTaskMetrics): void;

  URLSessionTaskDidCompleteWithError?(session: NSURLSession, task: NSURLSessionTask, error: NSError | null): void;
}

declare class NSURLSessionTaskDelegate extends NativeObject implements NSURLSessionTaskDelegate {
}

declare interface NSFilePresenter extends NSObjectProtocol {
  readonly presentedItemURL: NSURL;

  readonly presentedItemOperationQueue: NSOperationQueue;

  relinquishPresentedItemToReader?(reader: (p1: () => void) => void | null): void;

  relinquishPresentedItemToWriter?(writer: (p1: () => void) => void | null): void;

  savePresentedItemChangesWithCompletionHandler?(completionHandler: (p1: NSError) => void | null): void;

  accommodatePresentedItemDeletionWithCompletionHandler?(completionHandler: (p1: NSError) => void | null): void;

  presentedItemDidMoveToURL?(newURL: NSURL): void;

  presentedItemDidChange?(): void;

  presentedItemDidChangeUbiquityAttributes?(attributes: NSSet): void;

  readonly observedPresentedItemUbiquityAttributes?: NSSet;

  presentedItemDidGainVersion?(version: NSFileVersion): void;

  presentedItemDidLoseVersion?(version: NSFileVersion): void;

  presentedItemDidResolveConflictVersion?(version: NSFileVersion): void;

  accommodatePresentedSubitemDeletionAtURLCompletionHandler?(url: NSURL, completionHandler: (p1: NSError) => void | null): void;

  presentedSubitemDidAppearAtURL?(url: NSURL): void;

  presentedSubitemAtURLDidMoveToURL?(oldURL: NSURL, newURL: NSURL): void;

  presentedSubitemDidChangeAtURL?(url: NSURL): void;

  presentedSubitemAtURLDidGainVersion?(url: NSURL, version: NSFileVersion): void;

  presentedSubitemAtURLDidLoseVersion?(url: NSURL, version: NSFileVersion): void;

  presentedSubitemAtURLDidResolveConflictVersion?(url: NSURL, version: NSFileVersion): void;
}

declare class NSFilePresenter extends NativeObject implements NSFilePresenter {
}

declare interface NSURLSessionDataDelegate extends NSURLSessionTaskDelegate {
  URLSessionDataTaskDidReceiveResponseCompletionHandler?(session: NSURLSession, dataTask: NSURLSessionDataTask, response: NSURLResponse, completionHandler: (p1: interop.Enum<typeof NSURLSessionResponseDisposition>) => void): void;

  URLSessionDataTaskDidBecomeDownloadTask?(session: NSURLSession, dataTask: NSURLSessionDataTask, downloadTask: NSURLSessionDownloadTask): void;

  URLSessionDataTaskDidBecomeStreamTask?(session: NSURLSession, dataTask: NSURLSessionDataTask, streamTask: NSURLSessionStreamTask): void;

  URLSessionDataTaskDidReceiveData?(session: NSURLSession, dataTask: NSURLSessionDataTask, data: NSData): void;

  URLSessionDataTaskWillCacheResponseCompletionHandler?(session: NSURLSession, dataTask: NSURLSessionDataTask, proposedResponse: NSCachedURLResponse, completionHandler: (p1: NSCachedURLResponse) => void | null): void;
}

declare class NSURLSessionDataDelegate extends NativeObject implements NSURLSessionDataDelegate {
}

declare interface NSXPCListenerDelegate extends NSObjectProtocol {
  listenerShouldAcceptNewConnection?(listener: NSXPCListener, newConnection: NSXPCConnection): boolean;
}

declare class NSXPCListenerDelegate extends NativeObject implements NSXPCListenerDelegate {
}

declare interface NSFastEnumeration {
  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSFastEnumeration extends NativeObject implements NSFastEnumeration {
}

declare interface NSCopying {
  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSCopying extends NativeObject implements NSCopying {
}

declare interface NSURLAuthenticationChallengeSender extends NSObjectProtocol {
  useCredentialForAuthenticationChallenge(credential: NSURLCredential, challenge: NSURLAuthenticationChallenge): void;

  continueWithoutCredentialForAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;

  cancelAuthenticationChallenge(challenge: NSURLAuthenticationChallenge): void;

  performDefaultHandlingForAuthenticationChallenge?(challenge: NSURLAuthenticationChallenge): void;

  rejectProtectionSpaceAndContinueWithChallenge?(challenge: NSURLAuthenticationChallenge): void;
}

declare class NSURLAuthenticationChallengeSender extends NativeObject implements NSURLAuthenticationChallengeSender {
}

declare interface NSKeyedArchiverDelegate extends NSObjectProtocol {
  archiverWillEncodeObject?(archiver: NSKeyedArchiver, object: interop.Object): interop.Object;

  archiverDidEncodeObject?(archiver: NSKeyedArchiver, object: interop.Object | null): void;

  archiverWillReplaceObjectWithObject?(archiver: NSKeyedArchiver, object: interop.Object | null, newObject: interop.Object | null): void;

  archiverWillFinish?(archiver: NSKeyedArchiver): void;

  archiverDidFinish?(archiver: NSKeyedArchiver): void;
}

declare class NSKeyedArchiverDelegate extends NativeObject implements NSKeyedArchiverDelegate {
}

declare interface NSExtensionRequestHandling extends NSObjectProtocol {
  beginRequestWithExtensionContext(context: NSExtensionContext): void;
}

declare class NSExtensionRequestHandling extends NativeObject implements NSExtensionRequestHandling {
}

declare interface NSLocking {
  lock(): void;

  unlock(): void;
}

declare class NSLocking extends NativeObject implements NSLocking {
}

declare interface NSDecimalNumberBehaviors {
  roundingMode(): interop.Enum<typeof NSRoundingMode>;

  scale(): number;

  exceptionDuringOperationErrorLeftOperandRightOperand(operation: string, error: interop.Enum<typeof NSCalculationError>, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;
}

declare class NSDecimalNumberBehaviors extends NativeObject implements NSDecimalNumberBehaviors {
}

declare interface NSItemProviderReading extends NSObjectProtocol {
}

declare class NSItemProviderReading extends NativeObject implements NSItemProviderReading {
  static readonly readableTypeIdentifiersForItemProvider: NSArray;

  static objectWithItemProviderDataTypeIdentifierError<This extends abstract new (...args: any) => any>(this: This, data: NSData, typeIdentifier: string, outError: interop.PointerConvertible): InstanceType<This>;
}

declare interface NSURLConnectionDataDelegate extends NSURLConnectionDelegate {
  connectionWillSendRequestRedirectResponse?(connection: NSURLConnection, request: NSURLRequest, response: NSURLResponse | null): NSURLRequest;

  connectionDidReceiveResponse?(connection: NSURLConnection, response: NSURLResponse): void;

  connectionDidReceiveData?(connection: NSURLConnection, data: NSData): void;

  connectionNeedNewBodyStream?(connection: NSURLConnection, request: NSURLRequest): NSInputStream;

  connectionDidSendBodyDataTotalBytesWrittenTotalBytesExpectedToWrite?(connection: NSURLConnection, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;

  connectionWillCacheResponse?(connection: NSURLConnection, cachedResponse: NSCachedURLResponse): NSCachedURLResponse;

  connectionDidFinishLoading?(connection: NSURLConnection): void;
}

declare class NSURLConnectionDataDelegate extends NativeObject implements NSURLConnectionDataDelegate {
}

declare interface NSSecureCoding extends NSCoding {
}

declare class NSSecureCoding extends NativeObject implements NSSecureCoding {
  static readonly supportsSecureCoding: boolean;
}

declare interface NSURLSessionDownloadDelegate extends NSURLSessionTaskDelegate {
  URLSessionDownloadTaskDidFinishDownloadingToURL(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, location: NSURL): void;

  URLSessionDownloadTaskDidWriteDataTotalBytesWrittenTotalBytesExpectedToWrite?(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, bytesWritten: number, totalBytesWritten: number, totalBytesExpectedToWrite: number): void;

  URLSessionDownloadTaskDidResumeAtOffsetExpectedTotalBytes?(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, fileOffset: number, expectedTotalBytes: number): void;
}

declare class NSURLSessionDownloadDelegate extends NativeObject implements NSURLSessionDownloadDelegate {
}

declare interface NSItemProviderWriting extends NSObjectProtocol {
  readonly writableTypeIdentifiersForItemProvider?: NSArray;

  itemProviderVisibilityForRepresentationWithTypeIdentifier?(typeIdentifier: string): interop.Enum<typeof NSItemProviderRepresentationVisibility>;

  loadDataWithTypeIdentifierForItemProviderCompletionHandler(typeIdentifier: string, completionHandler: (p1: NSData, p2: NSError) => void | null): NSProgress;
}

declare class NSItemProviderWriting extends NativeObject implements NSItemProviderWriting {
  static readonly writableTypeIdentifiersForItemProvider: NSArray;

  static itemProviderVisibilityForRepresentationWithTypeIdentifier(typeIdentifier: string): interop.Enum<typeof NSItemProviderRepresentationVisibility>;

}

declare class NSLock extends NSObject implements NSLocking {
  tryLock(): boolean;

  lockBeforeDate(limit: NSDate): boolean;

  name: string;

  lock(): void;

  unlock(): void;
}

// @ts-ignore
declare class NSDictionary<KeyType = interop.Object, ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  objectForKey(aKey: KeyType): ObjectType;

  keyEnumerator(): NSEnumerator;

  init(): this;

  initWithObjectsForKeysCount(objects: interop.PointerConvertible, keys: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  readonly allKeys: NSArray;

  allKeysForObject(anObject: ObjectType): NSArray;

  readonly allValues: NSArray;

  readonly description: string;

  readonly descriptionInStringsFileFormat: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  descriptionWithLocaleIndent(locale: interop.Object | null, level: number): string;

  isEqualToDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): boolean;

  objectEnumerator(): NSEnumerator;

  objectsForKeysNotFoundMarker(keys: NSArray<interop.Object> | Array<interop.Object>, marker: ObjectType): NSArray;

  writeToURLError(url: NSURL, error: interop.PointerConvertible): boolean;

  keysSortedByValueUsingSelector(comparator: string): NSArray;

  getObjectsAndKeysCount(objects: interop.PointerConvertible, keys: interop.PointerConvertible, count: number): void;

  objectForKeyedSubscript(key: KeyType): ObjectType;

  enumerateKeysAndObjectsUsingBlock(block: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => void): void;

  enumerateKeysAndObjectsWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => void): void;

  keysSortedByValueUsingComparator(cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): NSArray;

  keysSortedByValueWithOptionsUsingComparator(opts: interop.Enum<typeof NSSortOptions>, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): NSArray;

  keysOfEntriesPassingTest(predicate: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => boolean): NSSet;

  keysOfEntriesWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => boolean): NSSet;

  getObjectsAndKeys(objects: interop.PointerConvertible, keys: interop.PointerConvertible): void;

  static dictionaryWithContentsOfFile<KeyType, ObjectType>(path: string): NSDictionary;

  static dictionaryWithContentsOfURL<KeyType, ObjectType>(url: NSURL): NSDictionary;

  initWithContentsOfFile(path: string): NSDictionary;

  initWithContentsOfURL(url: NSURL): NSDictionary;

  writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;

  writeToURLAtomically(url: NSURL, atomically: boolean): boolean;

  static dictionary<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dictionaryWithObjectForKey<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, object: ObjectType, key: NSCopying): InstanceType<This>;

  static dictionaryWithObjectsForKeysCount<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, keys: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static dictionaryWithObjectsAndKeys<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObject: interop.Object): InstanceType<This>;

  static dictionaryWithDictionary<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): InstanceType<This>;

  static dictionaryWithObjectsForKeys<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: NSArray<interop.Object> | Array<interop.Object>, keys: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjectsAndKeys(firstObject: interop.Object): this;

  initWithDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  initWithDictionaryCopyItems(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, flag: boolean): this;

  initWithObjectsForKeys(objects: NSArray<interop.Object> | Array<interop.Object>, keys: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithContentsOfURLError(url: NSURL, error: interop.PointerConvertible): NSDictionary;

  static dictionaryWithContentsOfURLError<KeyType, ObjectType>(url: NSURL, error: interop.PointerConvertible): NSDictionary;

  static sharedKeySetForKeys<KeyType, ObjectType>(keys: NSArray<interop.Object> | Array<interop.Object>): interop.Object;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  fileSize(): number;

  fileModificationDate(): NSDate;

  fileType(): string;

  filePosixPermissions(): number;

  fileOwnerAccountName(): string;

  fileGroupOwnerAccountName(): string;

  fileSystemNumber(): number;

  fileSystemFileNumber(): number;

  fileExtensionHidden(): boolean;

  fileHFSCreatorCode(): number;

  fileHFSTypeCode(): number;

  fileIsImmutable(): boolean;

  fileIsAppendOnly(): boolean;

  fileCreationDate(): NSDate;

  fileOwnerAccountID(): NSNumber;

  fileGroupOwnerAccountID(): NSNumber;

  // @ts-ignore
  valueForKey(key: string): ObjectType;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSMethodSignature extends NSObject {
  static signatureWithObjCTypes(types: string): NSMethodSignature;

  readonly numberOfArguments: number;

  getArgumentTypeAtIndex(idx: number): string;

  readonly frameLength: number;

  isOneway(): boolean;

  readonly methodReturnType: string;

  readonly methodReturnLength: number;
}

declare class NSDateComponents extends NSObject implements NSCopying, NSSecureCoding {
  calendar: NSCalendar;

  timeZone: NSTimeZone;

  era: number;

  year: number;

  month: number;

  day: number;

  hour: number;

  minute: number;

  second: number;

  nanosecond: number;

  weekday: number;

  weekdayOrdinal: number;

  quarter: number;

  weekOfMonth: number;

  weekOfYear: number;

  yearForWeekOfYear: number;

  isLeapMonth: boolean;

  readonly date: NSDate;

  week(): number;

  setWeek(v: number): void;

  setValueForComponent(value: number, unit: interop.Enum<typeof NSCalendarUnit>): void;

  valueForComponent(unit: interop.Enum<typeof NSCalendarUnit>): number;

  readonly isValidDate: boolean;

  isValidDateInCalendar(calendar: NSCalendar): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSOutputStream extends NSStream {
  writeMaxLength(buffer: interop.PointerConvertible, len: number): number;

  readonly hasSpaceAvailable: boolean;

  initToMemory(): this;

  initToBufferCapacity(buffer: interop.PointerConvertible, capacity: number): this;

  initWithURLAppend(url: NSURL, shouldAppend: boolean): this;

  initToFileAtPathAppend(path: string, shouldAppend: boolean): this;

  static outputStreamToMemory<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static outputStreamToBufferCapacity<This extends abstract new (...args: any) => any>(this: This, buffer: interop.PointerConvertible, capacity: number): InstanceType<This>;

  static outputStreamToFileAtPathAppend<This extends abstract new (...args: any) => any>(this: This, path: string, shouldAppend: boolean): InstanceType<This>;

  static outputStreamWithURLAppend<This extends abstract new (...args: any) => any>(this: This, url: NSURL, shouldAppend: boolean): InstanceType<This>;
}

declare class NSDateIntervalFormatter extends NSFormatter {
  locale: NSLocale;

  calendar: NSCalendar;

  timeZone: NSTimeZone;

  dateTemplate: string;

  dateStyle: interop.Enum<typeof NSDateIntervalFormatterStyle>;

  timeStyle: interop.Enum<typeof NSDateIntervalFormatterStyle>;

  stringFromDateToDate(fromDate: NSDate, toDate: NSDate): string;

  stringFromDateInterval(dateInterval: NSDateInterval): string;
}

declare class NSXMLParser extends NSObject {
  initWithContentsOfURL(url: NSURL): this;

  initWithData(data: NSData): this;

  initWithStream(stream: NSInputStream): this;

  delegate: NSXMLParserDelegate;

  shouldProcessNamespaces: boolean;

  shouldReportNamespacePrefixes: boolean;

  externalEntityResolvingPolicy: interop.Enum<typeof NSXMLParserExternalEntityResolvingPolicy>;

  allowedExternalEntityURLs: NSSet;

  parse(): boolean;

  abortParsing(): void;

  readonly parserError: NSError;

  shouldResolveExternalEntities: boolean;

  readonly publicID: string;

  readonly systemID: string;

  readonly lineNumber: number;

  readonly columnNumber: number;
}

declare class NSAutoreleasePool extends NSObject {
  static addObject(anObject: interop.Object): void;

  addObject(anObject: interop.Object): void;

  drain(): void;
}

declare class NSComparisonPredicate extends NSPredicate {
  static predicateWithLeftExpressionRightExpressionModifierTypeOptions(lhs: NSExpression, rhs: NSExpression, modifier: interop.Enum<typeof NSComparisonPredicateModifier>, type: interop.Enum<typeof NSPredicateOperatorType>, options: interop.Enum<typeof NSComparisonPredicateOptions>): NSComparisonPredicate;

  static predicateWithLeftExpressionRightExpressionCustomSelector(lhs: NSExpression, rhs: NSExpression, selector: string): NSComparisonPredicate;

  initWithLeftExpressionRightExpressionModifierTypeOptions(lhs: NSExpression, rhs: NSExpression, modifier: interop.Enum<typeof NSComparisonPredicateModifier>, type: interop.Enum<typeof NSPredicateOperatorType>, options: interop.Enum<typeof NSComparisonPredicateOptions>): this;

  initWithLeftExpressionRightExpressionCustomSelector(lhs: NSExpression, rhs: NSExpression, selector: string): this;

  initWithCoder(coder: NSCoder): this;

  readonly predicateOperatorType: interop.Enum<typeof NSPredicateOperatorType>;

  readonly comparisonPredicateModifier: interop.Enum<typeof NSComparisonPredicateModifier>;

  readonly leftExpression: NSExpression;

  readonly rightExpression: NSExpression;

  readonly customSelector: string;

  readonly options: interop.Enum<typeof NSComparisonPredicateOptions>;
}

declare class NSXPCInterface extends NSObject {
  static interfaceWithProtocol(protocol: interop.PointerConvertible): NSXPCInterface;

  get protocol(): interop.Pointer;
  set protocol(value: interop.PointerConvertible);

  setClassesForSelectorArgumentIndexOfReply(classes: NSSet, sel: string, arg: number, ofReply: boolean): void;

  classesForSelectorArgumentIndexOfReply(sel: string, arg: number, ofReply: boolean): NSSet;

  setInterfaceForSelectorArgumentIndexOfReply(ifc: NSXPCInterface, sel: string, arg: number, ofReply: boolean): void;

  interfaceForSelectorArgumentIndexOfReply(sel: string, arg: number, ofReply: boolean): NSXPCInterface;
}

declare class NSFileVersion extends NSObject {
  static currentVersionOfItemAtURL(url: NSURL): NSFileVersion;

  static otherVersionsOfItemAtURL(url: NSURL): NSArray;

  static unresolvedConflictVersionsOfItemAtURL(url: NSURL): NSArray;

  static getNonlocalVersionsOfItemAtURLCompletionHandler(url: NSURL, completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>, p2: NSError) => void | null): void;

  static versionOfItemAtURLForPersistentIdentifier(url: NSURL, persistentIdentifier: interop.Object): NSFileVersion;

  readonly URL: NSURL;

  readonly localizedName: string;

  readonly localizedNameOfSavingComputer: string;

  readonly originatorNameComponents: NSPersonNameComponents;

  readonly modificationDate: NSDate;

  readonly persistentIdentifier: NSCoding;

  readonly isConflict: boolean;

  isResolved: boolean;

  readonly hasLocalContents: boolean;

  readonly hasThumbnail: boolean;

  replaceItemAtURLOptionsError(url: NSURL, options: interop.Enum<typeof NSFileVersionReplacingOptions>, error: interop.PointerConvertible): NSURL;

  removeAndReturnError(outError: interop.PointerConvertible): boolean;

  static removeOtherVersionsOfItemAtURLError(url: NSURL, outError: interop.PointerConvertible): boolean;
}

declare class NSLinguisticTagger extends NSObject {
  initWithTagSchemesOptions(tagSchemes: NSArray<interop.Object> | Array<interop.Object>, opts: number): this;

  readonly tagSchemes: NSArray;

  string: string;

  static availableTagSchemesForUnitLanguage(unit: interop.Enum<typeof NSLinguisticTaggerUnit>, language: string): NSArray;

  static availableTagSchemesForLanguage(language: string): NSArray;

  setOrthographyRange(orthography: NSOrthography | null, range: _NSRange): void;

  orthographyAtIndexEffectiveRange(charIndex: number, effectiveRange: interop.PointerConvertible): NSOrthography;

  stringEditedInRangeChangeInLength(newRange: _NSRange, delta: number): void;

  tokenRangeAtIndexUnit(charIndex: number, unit: interop.Enum<typeof NSLinguisticTaggerUnit>): _NSRange;

  sentenceRangeForRange(range: _NSRange): _NSRange;

  enumerateTagsInRangeUnitSchemeOptionsUsingBlock(range: _NSRange, unit: interop.Enum<typeof NSLinguisticTaggerUnit>, scheme: string, options: interop.Enum<typeof NSLinguisticTaggerOptions>, block: (p1: string, p2: _NSRange, p3: interop.PointerConvertible) => void | null): void;

  tagAtIndexUnitSchemeTokenRange(charIndex: number, unit: interop.Enum<typeof NSLinguisticTaggerUnit>, scheme: string, tokenRange: interop.PointerConvertible): string;

  tagsInRangeUnitSchemeOptionsTokenRanges(range: _NSRange, unit: interop.Enum<typeof NSLinguisticTaggerUnit>, scheme: string, options: interop.Enum<typeof NSLinguisticTaggerOptions>, tokenRanges: interop.PointerConvertible): NSArray;

  enumerateTagsInRangeSchemeOptionsUsingBlock(range: _NSRange, tagScheme: string, opts: interop.Enum<typeof NSLinguisticTaggerOptions>, block: (p1: string, p2: _NSRange, p3: _NSRange, p4: interop.PointerConvertible) => void | null): void;

  tagAtIndexSchemeTokenRangeSentenceRange(charIndex: number, scheme: string, tokenRange: interop.PointerConvertible, sentenceRange: interop.PointerConvertible): string;

  tagsInRangeSchemeOptionsTokenRanges(range: _NSRange, tagScheme: string, opts: interop.Enum<typeof NSLinguisticTaggerOptions>, tokenRanges: interop.PointerConvertible): NSArray;

  readonly dominantLanguage: string;

  static dominantLanguageForString(string: string): string;

  static tagForStringAtIndexUnitSchemeOrthographyTokenRange(string: string, charIndex: number, unit: interop.Enum<typeof NSLinguisticTaggerUnit>, scheme: string, orthography: NSOrthography | null, tokenRange: interop.PointerConvertible): string;

  static tagsForStringRangeUnitSchemeOptionsOrthographyTokenRanges(string: string, range: _NSRange, unit: interop.Enum<typeof NSLinguisticTaggerUnit>, scheme: string, options: interop.Enum<typeof NSLinguisticTaggerOptions>, orthography: NSOrthography | null, tokenRanges: interop.PointerConvertible): NSArray;

  static enumerateTagsForStringRangeUnitSchemeOptionsOrthographyUsingBlock(string: string, range: _NSRange, unit: interop.Enum<typeof NSLinguisticTaggerUnit>, scheme: string, options: interop.Enum<typeof NSLinguisticTaggerOptions>, orthography: NSOrthography | null, block: (p1: string, p2: _NSRange, p3: interop.PointerConvertible) => void | null): void;

  possibleTagsAtIndexSchemeTokenRangeSentenceRangeScores(charIndex: number, tagScheme: string, tokenRange: interop.PointerConvertible, sentenceRange: interop.PointerConvertible, scores: interop.PointerConvertible): NSArray;
}

declare class NSConditionLock extends NSObject implements NSLocking {
  initWithCondition(condition: number): this;

  readonly condition: number;

  lockWhenCondition(condition: number): void;

  tryLock(): boolean;

  tryLockWhenCondition(condition: number): boolean;

  unlockWithCondition(condition: number): void;

  lockBeforeDate(limit: NSDate): boolean;

  lockWhenConditionBeforeDate(condition: number, limit: NSDate): boolean;

  name: string;

  lock(): void;

  unlock(): void;
}

declare class NSURLConnection extends NSObject {
  initWithRequestDelegateStartImmediately(request: NSURLRequest, delegate: interop.Object | null, startImmediately: boolean): this;

  initWithRequestDelegate(request: NSURLRequest, delegate: interop.Object | null): this;

  static connectionWithRequestDelegate(request: NSURLRequest, delegate: interop.Object | null): NSURLConnection;

  readonly originalRequest: NSURLRequest;

  readonly currentRequest: NSURLRequest;

  start(): void;

  cancel(): void;

  scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  unscheduleFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  setDelegateQueue(queue: NSOperationQueue | null): void;

  static canHandleRequest(request: NSURLRequest): boolean;

  static sendSynchronousRequestReturningResponseError(request: NSURLRequest, response: interop.PointerConvertible, error: interop.PointerConvertible): NSData;

  static sendAsynchronousRequestQueueCompletionHandler(request: NSURLRequest, queue: NSOperationQueue, handler: (p1: NSURLResponse, p2: NSData, p3: NSError) => void | null): void;
}

declare class NSValue extends NSObject implements NSCopying, NSSecureCoding {
  getValueSize(value: interop.PointerConvertible, size: number): void;

  readonly objCType: string;

  initWithBytesObjCType(value: interop.PointerConvertible, type: string): this;

  initWithCoder(coder: NSCoder): this;

  static valueWithBytesObjCType(value: interop.PointerConvertible, type: string): NSValue;

  static valueWithObjCType(value: interop.PointerConvertible, type: string): NSValue;

  static valueWithNonretainedObject(anObject: interop.Object | null): NSValue;

  readonly nonretainedObjectValue: interop.Object;

  static valueWithPointer(pointer: interop.PointerConvertible): NSValue;

  readonly pointerValue: interop.Pointer;

  isEqualToValue(value: NSValue): boolean;

  getValue(value: interop.PointerConvertible): void;

  static valueWithRange(range: _NSRange): NSValue;

  readonly rangeValue: _NSRange;

  static valueWithCATransform3D(t: CATransform3D): NSValue;

  readonly CATransform3DValue: CATransform3D;

  static valueWithCMTime(time: CMTime): NSValue;

  readonly CMTimeValue: CMTime;

  static valueWithCMTimeRange(timeRange: CMTimeRange): NSValue;

  readonly CMTimeRangeValue: CMTimeRange;

  static valueWithCMTimeMapping(timeMapping: CMTimeMapping): NSValue;

  readonly CMTimeMappingValue: CMTimeMapping;

  static valueWithCMVideoDimensions(dimensions: CMVideoDimensions): NSValue;

  readonly CMVideoDimensionsValue: CMVideoDimensions;

  static valueWithCGPoint(point: CGPoint): NSValue;

  static valueWithCGVector(vector: CGVector): NSValue;

  static valueWithCGSize(size: CGSize): NSValue;

  static valueWithCGRect(rect: CGRect): NSValue;

  static valueWithCGAffineTransform(transform: CGAffineTransform): NSValue;

  static valueWithUIEdgeInsets(insets: UIEdgeInsets): NSValue;

  static valueWithDirectionalEdgeInsets(insets: NSDirectionalEdgeInsets): NSValue;

  static valueWithUIOffset(insets: UIOffset): NSValue;

  readonly CGPointValue: CGPoint;

  readonly CGVectorValue: CGVector;

  readonly CGSizeValue: CGSize;

  readonly CGRectValue: CGRect;

  readonly CGAffineTransformValue: CGAffineTransform;

  readonly UIEdgeInsetsValue: UIEdgeInsets;

  readonly directionalEdgeInsetsValue: NSDirectionalEdgeInsets;

  readonly UIOffsetValue: UIOffset;

  static valueWithSCNVector3(v: SCNVector3): NSValue;

  static valueWithSCNVector4(v: SCNVector4): NSValue;

  static valueWithSCNMatrix4(v: SCNMatrix4): NSValue;

  readonly SCNVector3Value: SCNVector3;

  readonly SCNVector4Value: SCNVector4;

  readonly SCNMatrix4Value: SCNMatrix4;

  static valueWithMKCoordinate(coordinate: CLLocationCoordinate2D): NSValue;

  static valueWithMKCoordinateSpan(span: MKCoordinateSpan): NSValue;

  readonly MKCoordinateValue: CLLocationCoordinate2D;

  readonly MKCoordinateSpanValue: MKCoordinateSpan;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSUbiquitousKeyValueStore extends NSObject {
  static readonly defaultStore: NSUbiquitousKeyValueStore;

  objectForKey(aKey: string): interop.Object;

  setObjectForKey(anObject: interop.Object | null, aKey: string): void;

  removeObjectForKey(aKey: string): void;

  stringForKey(aKey: string): string;

  arrayForKey(aKey: string): NSArray;

  dictionaryForKey(aKey: string): NSDictionary;

  dataForKey(aKey: string): NSData;

  longLongForKey(aKey: string): number;

  doubleForKey(aKey: string): number;

  boolForKey(aKey: string): boolean;

  setStringForKey(aString: string | null, aKey: string): void;

  setDataForKey(aData: NSData | null, aKey: string): void;

  setArrayForKey(anArray: NSArray<interop.Object> | Array<interop.Object> | null, aKey: string): void;

  setDictionaryForKey(aDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, aKey: string): void;

  setLongLongForKey(value: number, aKey: string): void;

  setDoubleForKey(value: number, aKey: string): void;

  setBoolForKey(value: boolean, aKey: string): void;

  readonly dictionaryRepresentation: NSDictionary;

  synchronize(): boolean;
}

declare class NSMutableAttributedString extends NSAttributedString {
  replaceCharactersInRangeWithString(range: _NSRange, str: string): void;

  setAttributesRange(attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, range: _NSRange): void;

  readonly mutableString: NSMutableString;

  addAttributeValueRange(name: string, value: interop.Object, range: _NSRange): void;

  addAttributesRange(attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, range: _NSRange): void;

  removeAttributeRange(name: string, range: _NSRange): void;

  replaceCharactersInRangeWithAttributedString(range: _NSRange, attrString: NSAttributedString): void;

  insertAttributedStringAtIndex(attrString: NSAttributedString, loc: number): void;

  appendAttributedString(attrString: NSAttributedString): void;

  deleteCharactersInRange(range: _NSRange): void;

  setAttributedString(attrString: NSAttributedString): void;

  beginEditing(): void;

  endEditing(): void;

  appendLocalizedFormat(format: NSAttributedString): void;

  fixAttributesInRange(range: _NSRange): void;

  readFromURLOptionsDocumentAttributesError(url: NSURL, opts: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, dict: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  readFromDataOptionsDocumentAttributesError(data: NSData, opts: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, dict: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  readFromFileURLOptionsDocumentAttributesError(url: NSURL, opts: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, dict: interop.PointerConvertible, error: interop.PointerConvertible): boolean;
}

declare class NSExtensionContext extends NSObject {
  readonly inputItems: NSArray;

  completeRequestReturningItemsCompletionHandler(items: NSArray<interop.Object> | Array<interop.Object> | null, completionHandler: (p1: boolean) => void | null): void;

  cancelRequestWithError(error: NSError): void;

  openURLCompletionHandler(URL: NSURL, completionHandler: (p1: boolean) => void | null): void;

  readonly intent: INIntent;
}

declare class NSCalendar extends NSObject implements NSCopying, NSSecureCoding {
  static readonly currentCalendar: NSCalendar;

  static readonly autoupdatingCurrentCalendar: NSCalendar;

  static calendarWithIdentifier(calendarIdentifierConstant: string): NSCalendar;

  initWithCalendarIdentifier(ident: string): interop.Object;

  readonly calendarIdentifier: string;

  locale: NSLocale;

  timeZone: NSTimeZone;

  firstWeekday: number;

  minimumDaysInFirstWeek: number;

  readonly eraSymbols: NSArray;

  readonly longEraSymbols: NSArray;

  readonly monthSymbols: NSArray;

  readonly shortMonthSymbols: NSArray;

  readonly veryShortMonthSymbols: NSArray;

  readonly standaloneMonthSymbols: NSArray;

  readonly shortStandaloneMonthSymbols: NSArray;

  readonly veryShortStandaloneMonthSymbols: NSArray;

  readonly weekdaySymbols: NSArray;

  readonly shortWeekdaySymbols: NSArray;

  readonly veryShortWeekdaySymbols: NSArray;

  readonly standaloneWeekdaySymbols: NSArray;

  readonly shortStandaloneWeekdaySymbols: NSArray;

  readonly veryShortStandaloneWeekdaySymbols: NSArray;

  readonly quarterSymbols: NSArray;

  readonly shortQuarterSymbols: NSArray;

  readonly standaloneQuarterSymbols: NSArray;

  readonly shortStandaloneQuarterSymbols: NSArray;

  readonly AMSymbol: string;

  readonly PMSymbol: string;

  minimumRangeOfUnit(unit: interop.Enum<typeof NSCalendarUnit>): _NSRange;

  maximumRangeOfUnit(unit: interop.Enum<typeof NSCalendarUnit>): _NSRange;

  rangeOfUnitInUnitForDate(smaller: interop.Enum<typeof NSCalendarUnit>, larger: interop.Enum<typeof NSCalendarUnit>, date: NSDate): _NSRange;

  ordinalityOfUnitInUnitForDate(smaller: interop.Enum<typeof NSCalendarUnit>, larger: interop.Enum<typeof NSCalendarUnit>, date: NSDate): number;

  rangeOfUnitStartDateIntervalForDate(unit: interop.Enum<typeof NSCalendarUnit>, datep: interop.PointerConvertible, tip: interop.PointerConvertible, date: NSDate): boolean;

  dateFromComponents(comps: NSDateComponents): NSDate;

  componentsFromDate(unitFlags: interop.Enum<typeof NSCalendarUnit>, date: NSDate): NSDateComponents;

  dateByAddingComponentsToDateOptions(comps: NSDateComponents, date: NSDate, opts: interop.Enum<typeof NSCalendarOptions>): NSDate;

  componentsFromDateToDateOptions(unitFlags: interop.Enum<typeof NSCalendarUnit>, startingDate: NSDate, resultDate: NSDate, opts: interop.Enum<typeof NSCalendarOptions>): NSDateComponents;

  getEraYearMonthDayFromDate(eraValuePointer: interop.PointerConvertible, yearValuePointer: interop.PointerConvertible, monthValuePointer: interop.PointerConvertible, dayValuePointer: interop.PointerConvertible, date: NSDate): void;

  getEraYearForWeekOfYearWeekOfYearWeekdayFromDate(eraValuePointer: interop.PointerConvertible, yearValuePointer: interop.PointerConvertible, weekValuePointer: interop.PointerConvertible, weekdayValuePointer: interop.PointerConvertible, date: NSDate): void;

  getHourMinuteSecondNanosecondFromDate(hourValuePointer: interop.PointerConvertible, minuteValuePointer: interop.PointerConvertible, secondValuePointer: interop.PointerConvertible, nanosecondValuePointer: interop.PointerConvertible, date: NSDate): void;

  componentFromDate(unit: interop.Enum<typeof NSCalendarUnit>, date: NSDate): number;

  dateWithEraYearMonthDayHourMinuteSecondNanosecond(eraValue: number, yearValue: number, monthValue: number, dayValue: number, hourValue: number, minuteValue: number, secondValue: number, nanosecondValue: number): NSDate;

  dateWithEraYearForWeekOfYearWeekOfYearWeekdayHourMinuteSecondNanosecond(eraValue: number, yearValue: number, weekValue: number, weekdayValue: number, hourValue: number, minuteValue: number, secondValue: number, nanosecondValue: number): NSDate;

  startOfDayForDate(date: NSDate): NSDate;

  componentsInTimeZoneFromDate(timezone: NSTimeZone, date: NSDate): NSDateComponents;

  compareDateToDateToUnitGranularity(date1: NSDate, date2: NSDate, unit: interop.Enum<typeof NSCalendarUnit>): interop.Enum<typeof NSComparisonResult>;

  isDateEqualToDateToUnitGranularity(date1: NSDate, date2: NSDate, unit: interop.Enum<typeof NSCalendarUnit>): boolean;

  isDateInSameDayAsDate(date1: NSDate, date2: NSDate): boolean;

  isDateInToday(date: NSDate): boolean;

  isDateInYesterday(date: NSDate): boolean;

  isDateInTomorrow(date: NSDate): boolean;

  isDateInWeekend(date: NSDate): boolean;

  rangeOfWeekendStartDateIntervalContainingDate(datep: interop.PointerConvertible, tip: interop.PointerConvertible, date: NSDate): boolean;

  nextWeekendStartDateIntervalOptionsAfterDate(datep: interop.PointerConvertible, tip: interop.PointerConvertible, options: interop.Enum<typeof NSCalendarOptions>, date: NSDate): boolean;

  componentsFromDateComponentsToDateComponentsOptions(unitFlags: interop.Enum<typeof NSCalendarUnit>, startingDateComp: NSDateComponents, resultDateComp: NSDateComponents, options: interop.Enum<typeof NSCalendarOptions>): NSDateComponents;

  dateByAddingUnitValueToDateOptions(unit: interop.Enum<typeof NSCalendarUnit>, value: number, date: NSDate, options: interop.Enum<typeof NSCalendarOptions>): NSDate;

  enumerateDatesStartingAfterDateMatchingComponentsOptionsUsingBlock(start: NSDate, comps: NSDateComponents, opts: interop.Enum<typeof NSCalendarOptions>, block: (p1: NSDate, p2: boolean, p3: interop.PointerConvertible) => void | null): void;

  nextDateAfterDateMatchingComponentsOptions(date: NSDate, comps: NSDateComponents, options: interop.Enum<typeof NSCalendarOptions>): NSDate;

  nextDateAfterDateMatchingUnitValueOptions(date: NSDate, unit: interop.Enum<typeof NSCalendarUnit>, value: number, options: interop.Enum<typeof NSCalendarOptions>): NSDate;

  nextDateAfterDateMatchingHourMinuteSecondOptions(date: NSDate, hourValue: number, minuteValue: number, secondValue: number, options: interop.Enum<typeof NSCalendarOptions>): NSDate;

  dateBySettingUnitValueOfDateOptions(unit: interop.Enum<typeof NSCalendarUnit>, v: number, date: NSDate, opts: interop.Enum<typeof NSCalendarOptions>): NSDate;

  dateBySettingHourMinuteSecondOfDateOptions(h: number, m: number, s: number, date: NSDate, opts: interop.Enum<typeof NSCalendarOptions>): NSDate;

  dateMatchesComponents(date: NSDate, components: NSDateComponents): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLCredentialStorage extends NSObject {
  static readonly sharedCredentialStorage: NSURLCredentialStorage;

  credentialsForProtectionSpace(space: NSURLProtectionSpace): NSDictionary;

  readonly allCredentials: NSDictionary;

  setCredentialForProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;

  removeCredentialForProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;

  removeCredentialForProtectionSpaceOptions(credential: NSURLCredential, space: NSURLProtectionSpace, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  defaultCredentialForProtectionSpace(space: NSURLProtectionSpace): NSURLCredential;

  setDefaultCredentialForProtectionSpace(credential: NSURLCredential, space: NSURLProtectionSpace): void;

  getCredentialsForProtectionSpaceTaskCompletionHandler(protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => void | null): void;

  setCredentialForProtectionSpaceTask(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;

  removeCredentialForProtectionSpaceOptionsTask(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, task: NSURLSessionTask): void;

  getDefaultCredentialForProtectionSpaceTaskCompletionHandler(space: NSURLProtectionSpace, task: NSURLSessionTask, completionHandler: (p1: NSURLCredential) => void | null): void;

  setDefaultCredentialForProtectionSpaceTask(credential: NSURLCredential, protectionSpace: NSURLProtectionSpace, task: NSURLSessionTask): void;
}

declare class NSFileAccessIntent extends NSObject {
  static readingIntentWithURLOptions<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: interop.Enum<typeof NSFileCoordinatorReadingOptions>): InstanceType<This>;

  static writingIntentWithURLOptions<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: interop.Enum<typeof NSFileCoordinatorWritingOptions>): InstanceType<This>;

  readonly URL: NSURL;
}

declare class NSUnitConverterLinear extends NSUnitConverter implements NSSecureCoding {
  readonly coefficient: number;

  readonly constant: number;

  initWithCoefficient(coefficient: number): this;

  initWithCoefficientConstant(coefficient: number, constant: number): this;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSSet<ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  member(object: ObjectType): ObjectType;

  objectEnumerator(): NSEnumerator;

  init(): this;

  initWithObjectsCount(objects: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  readonly allObjects: NSArray;

  anyObject(): ObjectType;

  containsObject(anObject: ObjectType): boolean;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  intersectsSet(otherSet: NSSet): boolean;

  isEqualToSet(otherSet: NSSet): boolean;

  isSubsetOfSet(otherSet: NSSet): boolean;

  makeObjectsPerformSelector(aSelector: string): void;

  makeObjectsPerformSelectorWithObject(aSelector: string, argument: interop.Object | null): void;

  setByAddingObject(anObject: ObjectType): NSSet;

  setByAddingObjectsFromSet(other: NSSet): NSSet;

  setByAddingObjectsFromArray(other: NSArray<interop.Object> | Array<interop.Object>): NSSet;

  enumerateObjectsUsingBlock(block: (p1: interop.Object, p2: interop.PointerConvertible) => void): void;

  enumerateObjectsWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: interop.PointerConvertible) => void): void;

  objectsPassingTest(predicate: (p1: interop.Object, p2: interop.PointerConvertible) => boolean): NSSet;

  objectsWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: interop.PointerConvertible) => boolean): NSSet;

  static set<ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static setWithObject<ObjectType, This extends abstract new (...args: any) => any>(this: This, object: ObjectType): InstanceType<This>;

  static setWithObjectsCount<ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static setWithObjects<ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObj: ObjectType): InstanceType<This>;

  static setWithSet<ObjectType, This extends abstract new (...args: any) => any>(this: This, set: NSSet): InstanceType<This>;

  static setWithArray<ObjectType, This extends abstract new (...args: any) => any>(this: This, array: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjects(firstObj: ObjectType): this;

  initWithSet(set: NSSet): this;

  initWithSetCopyItems(set: NSSet, flag: boolean): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;

  addObserverForKeyPathOptionsContext(observer: NSObject, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverForKeyPathContext(observer: NSObject, keyPath: string, context: interop.PointerConvertible): void;

  removeObserverForKeyPath(observer: NSObject, keyPath: string): void;

  sortedArrayUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  filteredSetUsingPredicate(predicate: NSPredicate): NSSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

// @ts-ignore
declare class NSKeyedArchiver extends NSCoder {
  initRequiringSecureCoding(requiresSecureCoding: boolean): this;

  static archivedDataWithRootObjectRequiringSecureCodingError(object: interop.Object, requiresSecureCoding: boolean, error: interop.PointerConvertible): NSData;

  init(): this;

  initForWritingWithMutableData(data: NSMutableData): this;

  static archivedDataWithRootObject(rootObject: interop.Object): NSData;

  static archiveRootObjectToFile(rootObject: interop.Object, path: string): boolean;

  delegate: NSKeyedArchiverDelegate;

  outputFormat: interop.Enum<typeof NSPropertyListFormat>;

  readonly encodedData: NSData;

  finishEncoding(): void;

  static setClassNameForClass(codedName: string | null, cls: interop.Object): void;

  setClassNameForClass(codedName: string | null, cls: interop.Object): void;

  static classNameForClass(cls: interop.Object): string;

  classNameForClass(cls: interop.Object): string;

  encodeObjectForKey(object: interop.Object | null, key: string): void;

  encodeConditionalObjectForKey(object: interop.Object | null, key: string): void;

  encodeBoolForKey(value: boolean, key: string): void;

  encodeIntForKey(value: number, key: string): void;

  encodeInt32ForKey(value: number, key: string): void;

  encodeInt64ForKey(value: number, key: string): void;

  encodeFloatForKey(value: number, key: string): void;

  encodeDoubleForKey(value: number, key: string): void;

  encodeBytesLengthForKey(bytes: interop.PointerConvertible, length: number, key: string): void;

  // @ts-ignore
  requiresSecureCoding: boolean;
}

declare class NSURLSessionConfiguration extends NSObject implements NSCopying {
  static readonly defaultSessionConfiguration: NSURLSessionConfiguration;

  static readonly ephemeralSessionConfiguration: NSURLSessionConfiguration;

  static backgroundSessionConfigurationWithIdentifier(identifier: string): NSURLSessionConfiguration;

  readonly identifier: string;

  requestCachePolicy: interop.Enum<typeof NSURLRequestCachePolicy>;

  timeoutIntervalForRequest: number;

  timeoutIntervalForResource: number;

  networkServiceType: interop.Enum<typeof NSURLRequestNetworkServiceType>;

  allowsCellularAccess: boolean;

  allowsExpensiveNetworkAccess: boolean;

  allowsConstrainedNetworkAccess: boolean;

  requiresDNSSECValidation: boolean;

  waitsForConnectivity: boolean;

  isDiscretionary: boolean;

  sharedContainerIdentifier: string;

  sessionSendsLaunchEvents: boolean;

  get connectionProxyDictionary(): NSDictionary;
  set connectionProxyDictionary(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  TLSMinimumSupportedProtocol: interop.Enum<typeof SSLProtocol>;

  TLSMaximumSupportedProtocol: interop.Enum<typeof SSLProtocol>;

  TLSMinimumSupportedProtocolVersion: interop.Enum<typeof tls_protocol_version_t>;

  TLSMaximumSupportedProtocolVersion: interop.Enum<typeof tls_protocol_version_t>;

  HTTPShouldUsePipelining: boolean;

  HTTPShouldSetCookies: boolean;

  HTTPCookieAcceptPolicy: interop.Enum<typeof NSHTTPCookieAcceptPolicy>;

  get HTTPAdditionalHeaders(): NSDictionary;
  set HTTPAdditionalHeaders(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  HTTPMaximumConnectionsPerHost: number;

  HTTPCookieStorage: NSHTTPCookieStorage;

  URLCredentialStorage: NSURLCredentialStorage;

  URLCache: NSURLCache;

  shouldUseExtendedBackgroundIdleMode: boolean;

  get protocolClasses(): NSArray;
  set protocolClasses(value: NSArray<interop.Object> | Array<interop.Object>);

  multipathServiceType: interop.Enum<typeof NSURLSessionMultipathServiceType>;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static backgroundSessionConfiguration(identifier: string): NSURLSessionConfiguration;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSURL extends NSObject implements NSSecureCoding, NSCopying {
  initWithSchemeHostPath(scheme: string, host: string | null, path: string): this;

  initFileURLWithPathIsDirectoryRelativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): this;

  initFileURLWithPathRelativeToURL(path: string, baseURL: NSURL | null): this;

  initFileURLWithPathIsDirectory(path: string, isDir: boolean): this;

  initFileURLWithPath(path: string): this;

  static fileURLWithPathIsDirectoryRelativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): NSURL;

  static fileURLWithPathRelativeToURL(path: string, baseURL: NSURL | null): NSURL;

  static fileURLWithPathIsDirectory(path: string, isDir: boolean): NSURL;

  static fileURLWithPath(path: string): NSURL;

  initFileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): this;

  static fileURLWithFileSystemRepresentationIsDirectoryRelativeToURL(path: string, isDir: boolean, baseURL: NSURL | null): NSURL;

  initWithString(URLString: string): this;

  initWithStringRelativeToURL(URLString: string, baseURL: NSURL | null): this;

  static URLWithString<This extends abstract new (...args: any) => any>(this: This, URLString: string): InstanceType<This>;

  static URLWithStringRelativeToURL<This extends abstract new (...args: any) => any>(this: This, URLString: string, baseURL: NSURL | null): InstanceType<This>;

  initWithStringEncodingInvalidCharacters(URLString: string, encodingInvalidCharacters: boolean): this;

  static URLWithStringEncodingInvalidCharacters<This extends abstract new (...args: any) => any>(this: This, URLString: string, encodingInvalidCharacters: boolean): InstanceType<This>;

  initWithDataRepresentationRelativeToURL(data: NSData, baseURL: NSURL | null): this;

  static URLWithDataRepresentationRelativeToURL(data: NSData, baseURL: NSURL | null): NSURL;

  initAbsoluteURLWithDataRepresentationRelativeToURL(data: NSData, baseURL: NSURL | null): this;

  static absoluteURLWithDataRepresentationRelativeToURL(data: NSData, baseURL: NSURL | null): NSURL;

  readonly dataRepresentation: NSData;

  readonly absoluteString: string;

  readonly relativeString: string;

  readonly baseURL: NSURL;

  readonly absoluteURL: NSURL;

  readonly scheme: string;

  readonly resourceSpecifier: string;

  readonly host: string;

  readonly port: NSNumber;

  readonly user: string;

  readonly password: string;

  readonly path: string;

  readonly fragment: string;

  readonly parameterString: string;

  readonly query: string;

  readonly relativePath: string;

  readonly hasDirectoryPath: boolean;

  getFileSystemRepresentationMaxLength(buffer: string, maxBufferLength: number): boolean;

  readonly fileSystemRepresentation: string;

  readonly isFileURL: boolean;

  readonly standardizedURL: NSURL;

  checkResourceIsReachableAndReturnError(error: interop.PointerConvertible): boolean;

  isFileReferenceURL(): boolean;

  fileReferenceURL(): NSURL;

  readonly filePathURL: NSURL;

  getResourceValueForKeyError(value: interop.PointerConvertible, key: string, error: interop.PointerConvertible): boolean;

  resourceValuesForKeysError(keys: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): NSDictionary;

  setResourceValueForKeyError(value: interop.Object | null, key: string, error: interop.PointerConvertible): boolean;

  setResourceValuesError(keyedValues: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, error: interop.PointerConvertible): boolean;

  removeCachedResourceValueForKey(key: string): void;

  removeAllCachedResourceValues(): void;

  setTemporaryResourceValueForKey(value: interop.Object | null, key: string): void;

  bookmarkDataWithOptionsIncludingResourceValuesForKeysRelativeToURLError(options: interop.Enum<typeof NSURLBookmarkCreationOptions>, keys: NSArray<interop.Object> | Array<interop.Object> | null, relativeURL: NSURL | null, error: interop.PointerConvertible): NSData;

  initByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError(bookmarkData: NSData, options: interop.Enum<typeof NSURLBookmarkResolutionOptions>, relativeURL: NSURL | null, isStale: interop.PointerConvertible, error: interop.PointerConvertible): this;

  static URLByResolvingBookmarkDataOptionsRelativeToURLBookmarkDataIsStaleError<This extends abstract new (...args: any) => any>(this: This, bookmarkData: NSData, options: interop.Enum<typeof NSURLBookmarkResolutionOptions>, relativeURL: NSURL | null, isStale: interop.PointerConvertible, error: interop.PointerConvertible): InstanceType<This>;

  static resourceValuesForKeysFromBookmarkData(keys: NSArray<interop.Object> | Array<interop.Object>, bookmarkData: NSData): NSDictionary;

  static writeBookmarkDataToURLOptionsError(bookmarkData: NSData, bookmarkFileURL: NSURL, options: number, error: interop.PointerConvertible): boolean;

  static bookmarkDataWithContentsOfURLError(bookmarkFileURL: NSURL, error: interop.PointerConvertible): NSData;

  static URLByResolvingAliasFileAtURLOptionsError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: interop.Enum<typeof NSURLBookmarkResolutionOptions>, error: interop.PointerConvertible): InstanceType<This>;

  startAccessingSecurityScopedResource(): boolean;

  stopAccessingSecurityScopedResource(): void;

  getPromisedItemResourceValueForKeyError(value: interop.PointerConvertible, key: string, error: interop.PointerConvertible): boolean;

  promisedItemResourceValuesForKeysError(keys: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): NSDictionary;

  checkPromisedItemIsReachableAndReturnError(error: interop.PointerConvertible): boolean;

  static fileURLWithPathComponents(components: NSArray<interop.Object> | Array<interop.Object>): NSURL;

  readonly pathComponents: NSArray;

  readonly lastPathComponent: string;

  readonly pathExtension: string;

  URLByAppendingPathComponent(pathComponent: string): NSURL;

  URLByAppendingPathComponentIsDirectory(pathComponent: string, isDirectory: boolean): NSURL;

  readonly URLByDeletingLastPathComponent: NSURL;

  URLByAppendingPathExtension(pathExtension: string): NSURL;

  readonly URLByDeletingPathExtension: NSURL;

  readonly URLByStandardizingPath: NSURL;

  readonly URLByResolvingSymlinksInPath: NSURL;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSExtensionItem extends NSObject implements NSCopying, NSSecureCoding {
  attributedTitle: NSAttributedString;

  attributedContentText: NSAttributedString;

  get attachments(): NSArray;
  set attachments(value: NSArray<interop.Object> | Array<interop.Object>);

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCondition extends NSObject implements NSLocking {
  wait(): void;

  waitUntilDate(limit: NSDate): boolean;

  signal(): void;

  broadcast(): void;

  name: string;

  lock(): void;

  unlock(): void;
}

declare class NSUnitFuelEfficiency extends NSDimension implements NSSecureCoding {
  static readonly litersPer100Kilometers: NSUnitFuelEfficiency;

  static readonly milesPerImperialGallon: NSUnitFuelEfficiency;

  static readonly milesPerGallon: NSUnitFuelEfficiency;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSFileProviderService extends NSObject {
  getFileProviderConnectionWithCompletionHandler(completionHandler: (p1: NSXPCConnection, p2: NSError) => void | null): void;

  readonly name: string;
}

declare class NSJSONSerialization extends NSObject {
  static isValidJSONObject(obj: interop.Object): boolean;

  static dataWithJSONObjectOptionsError(obj: interop.Object, opt: interop.Enum<typeof NSJSONWritingOptions>, error: interop.PointerConvertible): NSData;

  static JSONObjectWithDataOptionsError(data: NSData, opt: interop.Enum<typeof NSJSONReadingOptions>, error: interop.PointerConvertible): interop.Object;

  static writeJSONObjectToStreamOptionsError(obj: interop.Object, stream: NSOutputStream, opt: interop.Enum<typeof NSJSONWritingOptions>, error: interop.PointerConvertible): number;

  static JSONObjectWithStreamOptionsError(stream: NSInputStream, opt: interop.Enum<typeof NSJSONReadingOptions>, error: interop.PointerConvertible): interop.Object;
}

declare class NSMorphologyCustomPronoun extends NSObject implements NSCopying, NSSecureCoding {
  static isSupportedForLanguage(language: string): boolean;

  static requiredKeysForLanguage(language: string): NSArray;

  subjectForm: string;

  objectForm: string;

  possessiveForm: string;

  possessiveAdjectiveForm: string;

  reflexiveForm: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSNotification extends NSObject implements NSCopying, NSCoding {
  readonly name: string;

  readonly object: interop.Object;

  readonly userInfo: NSDictionary;

  initWithNameObjectUserInfo(name: string, object: interop.Object | null, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  initWithCoder(coder: NSCoder): this;

  static notificationWithNameObject<This extends abstract new (...args: any) => any>(this: This, aName: string, anObject: interop.Object | null): InstanceType<This>;

  static notificationWithNameObjectUserInfo<This extends abstract new (...args: any) => any>(this: This, aName: string, anObject: interop.Object | null, aUserInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  init(): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSTimeZone extends NSObject implements NSCopying, NSSecureCoding {
  readonly name: string;

  readonly data: NSData;

  secondsFromGMTForDate(aDate: NSDate): number;

  abbreviationForDate(aDate: NSDate): string;

  isDaylightSavingTimeForDate(aDate: NSDate): boolean;

  daylightSavingTimeOffsetForDate(aDate: NSDate): number;

  nextDaylightSavingTimeTransitionAfterDate(aDate: NSDate): NSDate;

  static readonly systemTimeZone: NSTimeZone;

  static resetSystemTimeZone(): void;

  static defaultTimeZone: NSTimeZone;

  static readonly localTimeZone: NSTimeZone;

  static readonly knownTimeZoneNames: NSArray;

  static get abbreviationDictionary(): NSDictionary;
  static set abbreviationDictionary(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  static readonly timeZoneDataVersion: string;

  readonly secondsFromGMT: number;

  readonly abbreviation: string;

  readonly isDaylightSavingTime: boolean;

  readonly daylightSavingTimeOffset: number;

  readonly nextDaylightSavingTimeTransition: NSDate;

  readonly description: string;

  isEqualToTimeZone(aTimeZone: NSTimeZone): boolean;

  localizedNameLocale(style: interop.Enum<typeof NSTimeZoneNameStyle>, locale: NSLocale | null): string;

  static timeZoneWithName<This extends abstract new (...args: any) => any>(this: This, tzName: string): InstanceType<This>;

  static timeZoneWithNameData<This extends abstract new (...args: any) => any>(this: This, tzName: string, aData: NSData | null): InstanceType<This>;

  initWithName(tzName: string): this;

  initWithNameData(tzName: string, aData: NSData | null): this;

  static timeZoneForSecondsFromGMT<This extends abstract new (...args: any) => any>(this: This, seconds: number): InstanceType<This>;

  static timeZoneWithAbbreviation<This extends abstract new (...args: any) => any>(this: This, abbreviation: string): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSHashTable<ObjectType = interop.Object> extends NSObject implements NSCopying, NSSecureCoding, NSFastEnumeration {
  initWithOptionsCapacity(options: interop.Enum<typeof NSPointerFunctionsOptions>, initialCapacity: number): this;

  initWithPointerFunctionsCapacity(functions: NSPointerFunctions, initialCapacity: number): this;

  static hashTableWithOptions<ObjectType>(options: interop.Enum<typeof NSPointerFunctionsOptions>): NSHashTable;

  static weakObjectsHashTable<ObjectType>(): NSHashTable;

  readonly pointerFunctions: NSPointerFunctions;

  readonly count: number;

  member(object: ObjectType | null): ObjectType;

  objectEnumerator(): NSEnumerator;

  addObject(object: ObjectType | null): void;

  removeObject(object: ObjectType | null): void;

  removeAllObjects(): void;

  readonly allObjects: NSArray;

  readonly anyObject: ObjectType;

  containsObject(anObject: ObjectType | null): boolean;

  intersectsHashTable(other: NSHashTable): boolean;

  isEqualToHashTable(other: NSHashTable): boolean;

  isSubsetOfHashTable(other: NSHashTable): boolean;

  intersectHashTable(other: NSHashTable): void;

  unionHashTable(other: NSHashTable): void;

  minusHashTable(other: NSHashTable): void;

  readonly setRepresentation: NSSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSInputStream extends NSStream {
  readMaxLength(buffer: interop.PointerConvertible, len: number): number;

  getBufferLength(buffer: interop.PointerConvertible, len: interop.PointerConvertible): boolean;

  readonly hasBytesAvailable: boolean;

  initWithData(data: NSData): this;

  initWithURL(url: NSURL): this;

  initWithFileAtPath(path: string): this;

  static inputStreamWithData<This extends abstract new (...args: any) => any>(this: This, data: NSData): InstanceType<This>;

  static inputStreamWithFileAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static inputStreamWithURL<This extends abstract new (...args: any) => any>(this: This, url: NSURL): InstanceType<This>;
}

declare class NSMessagePort extends NSPort {
}

declare class NSOrderedCollectionChange<ObjectType = interop.Object> extends NSObject {
  static changeWithObjectTypeIndex<ObjectType>(anObject: ObjectType | null, type: interop.Enum<typeof NSCollectionChangeType>, index: number): NSOrderedCollectionChange;

  static changeWithObjectTypeIndexAssociatedIndex<ObjectType>(anObject: ObjectType | null, type: interop.Enum<typeof NSCollectionChangeType>, index: number, associatedIndex: number): NSOrderedCollectionChange;

  readonly object: ObjectType;

  readonly changeType: interop.Enum<typeof NSCollectionChangeType>;

  readonly index: number;

  readonly associatedIndex: number;

  initWithObjectTypeIndex(anObject: ObjectType | null, type: interop.Enum<typeof NSCollectionChangeType>, index: number): this;

  initWithObjectTypeIndexAssociatedIndex(anObject: ObjectType | null, type: interop.Enum<typeof NSCollectionChangeType>, index: number, associatedIndex: number): this;
}

declare class NSDimension extends NSUnit implements NSSecureCoding {
  readonly converter: NSUnitConverter;

  initWithSymbolConverter(symbol: string, converter: NSUnitConverter): this;

  static baseUnit<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitConcentrationMass extends NSDimension implements NSSecureCoding {
  static readonly gramsPerLiter: NSUnitConcentrationMass;

  static readonly milligramsPerDeciliter: NSUnitConcentrationMass;

  static millimolesPerLiterWithGramsPerMole(gramsPerMole: number): NSUnitConcentrationMass;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSXPCListenerEndpoint extends NSObject implements NSSecureCoding {
  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSProgress extends NSObject {
  static currentProgress(): NSProgress;

  static progressWithTotalUnitCount(unitCount: number): NSProgress;

  static discreteProgressWithTotalUnitCount(unitCount: number): NSProgress;

  static progressWithTotalUnitCountParentPendingUnitCount(unitCount: number, parent: NSProgress, portionOfParentTotalUnitCount: number): NSProgress;

  initWithParentUserInfo(parentProgressOrNil: NSProgress | null, userInfoOrNil: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  becomeCurrentWithPendingUnitCount(unitCount: number): void;

  performAsCurrentWithPendingUnitCountUsingBlock(unitCount: number, work: () => void): void;

  resignCurrent(): void;

  addChildWithPendingUnitCount(child: NSProgress, inUnitCount: number): void;

  totalUnitCount: number;

  completedUnitCount: number;

  localizedDescription: string;

  localizedAdditionalDescription: string;

  isCancellable: boolean;

  isPausable: boolean;

  readonly isCancelled: boolean;

  readonly isPaused: boolean;

  cancellationHandler: () => void;

  pausingHandler: () => void;

  resumingHandler: () => void;

  setUserInfoObjectForKey(objectOrNil: interop.Object | null, key: string): void;

  readonly isIndeterminate: boolean;

  readonly fractionCompleted: number;

  readonly isFinished: boolean;

  cancel(): void;

  pause(): void;

  resume(): void;

  readonly userInfo: NSDictionary;

  kind: string;

  estimatedTimeRemaining: NSNumber;

  throughput: NSNumber;

  fileOperationKind: string;

  fileURL: NSURL;

  fileTotalCount: NSNumber;

  fileCompletedCount: NSNumber;
}

declare class NSInvocationOperation extends NSOperation {
  initWithTargetSelectorObject(target: interop.Object, sel: string, arg: interop.Object | null): this;

  initWithInvocation(inv: NSInvocation): this;

  readonly invocation: NSInvocation;

  readonly result: interop.Object;
}

declare class NSPredicate extends NSObject implements NSSecureCoding, NSCopying {
  static predicateWithFormatArgumentArray(predicateFormat: string, arguments$: NSArray<interop.Object> | Array<interop.Object> | null): NSPredicate;

  static predicateWithFormat(predicateFormat: string): NSPredicate;

  static predicateWithFormatArguments(predicateFormat: string, argList: string): NSPredicate;

  static predicateWithValue(value: boolean): NSPredicate;

  static predicateWithBlock(block: (p1: interop.Object, p2: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => boolean | null): NSPredicate;

  readonly predicateFormat: string;

  predicateWithSubstitutionVariables(variables: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  evaluateWithObject(object: interop.Object | null): boolean;

  evaluateWithObjectSubstitutionVariables(object: interop.Object | null, bindings: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): boolean;

  allowEvaluation(): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSUnitPower extends NSDimension implements NSSecureCoding {
  static readonly terawatts: NSUnitPower;

  static readonly gigawatts: NSUnitPower;

  static readonly megawatts: NSUnitPower;

  static readonly kilowatts: NSUnitPower;

  static readonly watts: NSUnitPower;

  static readonly milliwatts: NSUnitPower;

  static readonly microwatts: NSUnitPower;

  static readonly nanowatts: NSUnitPower;

  static readonly picowatts: NSUnitPower;

  static readonly femtowatts: NSUnitPower;

  static readonly horsepower: NSUnitPower;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSOrderedCollectionDifference<ObjectType = interop.Object> extends NSObject implements NSFastEnumeration {
  initWithChanges(changes: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithInsertIndexesInsertedObjectsRemoveIndexesRemovedObjectsAdditionalChanges(inserts: NSIndexSet, insertedObjects: NSArray<interop.Object> | Array<interop.Object> | null, removes: NSIndexSet, removedObjects: NSArray<interop.Object> | Array<interop.Object> | null, changes: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithInsertIndexesInsertedObjectsRemoveIndexesRemovedObjects(inserts: NSIndexSet, insertedObjects: NSArray<interop.Object> | Array<interop.Object> | null, removes: NSIndexSet, removedObjects: NSArray<interop.Object> | Array<interop.Object> | null): this;

  readonly insertions: NSArray;

  readonly removals: NSArray;

  readonly hasChanges: boolean;

  differenceByTransformingChangesWithBlock(block: (p1: NSOrderedCollectionChange) => NSOrderedCollectionChange): NSOrderedCollectionDifference;

  inverseDifference(): this;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSProcessInfo extends NSObject {
  static readonly processInfo: NSProcessInfo;

  readonly environment: NSDictionary;

  readonly arguments: NSArray;

  readonly hostName: string;

  processName: string;

  readonly processIdentifier: number;

  readonly globallyUniqueString: string;

  operatingSystem(): number;

  operatingSystemName(): string;

  readonly operatingSystemVersionString: string;

  readonly operatingSystemVersion: NSOperatingSystemVersion;

  readonly processorCount: number;

  readonly activeProcessorCount: number;

  readonly physicalMemory: number;

  isOperatingSystemAtLeastVersion(version: NSOperatingSystemVersion): boolean;

  readonly systemUptime: number;

  beginActivityWithOptionsReason(options: interop.Enum<typeof NSActivityOptions>, reason: string): NSObject;

  endActivity(activity: NSObject): void;

  performActivityWithOptionsReasonUsingBlock(options: interop.Enum<typeof NSActivityOptions>, reason: string, block: () => void): void;

  performExpiringActivityWithReasonUsingBlock(reason: string, block: (p1: boolean) => void): void;

  readonly thermalState: interop.Enum<typeof NSProcessInfoThermalState>;

  readonly isLowPowerModeEnabled: boolean;

  readonly isMacCatalystApp: boolean;

  readonly isiOSAppOnMac: boolean;
}

declare class NSAttributedStringMarkdownParsingOptions extends NSObject implements NSCopying {
  init(): this;

  allowsExtendedAttributes: boolean;

  interpretedSyntax: interop.Enum<typeof NSAttributedStringMarkdownInterpretedSyntax>;

  failurePolicy: interop.Enum<typeof NSAttributedStringMarkdownParsingFailurePolicy>;

  languageCode: string;

  appliesSourcePositionAttributes: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSPort extends NSObject implements NSCopying, NSCoding {
  static port(): NSPort;

  invalidate(): void;

  readonly isValid: boolean;

  setDelegate(anObject: NSPortDelegate | null): void;

  delegate(): NSPortDelegate;

  scheduleInRunLoopForMode(runLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(runLoop: NSRunLoop, mode: string): void;

  readonly reservedSpaceLength: number;

  sendBeforeDateComponentsFromReserved(limitDate: NSDate, components: NSMutableArray | null, receivePort: NSPort | null, headerSpaceReserved: number): boolean;

  sendBeforeDateMsgidComponentsFromReserved(limitDate: NSDate, msgID: number, components: NSMutableArray | null, receivePort: NSPort | null, headerSpaceReserved: number): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSPipe extends NSObject {
  readonly fileHandleForReading: NSFileHandle;

  readonly fileHandleForWriting: NSFileHandle;

  static pipe(): NSPipe;
}

declare class NSUnitTemperature extends NSDimension implements NSSecureCoding {
  static readonly kelvin: NSUnitTemperature;

  static readonly celsius: NSUnitTemperature;

  static readonly fahrenheit: NSUnitTemperature;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSNumber extends NSValue {
  initWithCoder(coder: NSCoder): this;

  initWithChar(value: number): NSNumber;

  initWithUnsignedChar(value: number): NSNumber;

  initWithShort(value: number): NSNumber;

  initWithUnsignedShort(value: number): NSNumber;

  initWithInt(value: number): NSNumber;

  initWithUnsignedInt(value: number): NSNumber;

  initWithLong(value: number): NSNumber;

  initWithUnsignedLong(value: number): NSNumber;

  initWithLongLong(value: number): NSNumber;

  initWithUnsignedLongLong(value: number): NSNumber;

  initWithFloat(value: number): NSNumber;

  initWithDouble(value: number): NSNumber;

  initWithBool(value: boolean): NSNumber;

  initWithInteger(value: number): NSNumber;

  initWithUnsignedInteger(value: number): NSNumber;

  readonly charValue: number;

  readonly unsignedCharValue: number;

  readonly shortValue: number;

  readonly unsignedShortValue: number;

  readonly intValue: number;

  readonly unsignedIntValue: number;

  readonly longValue: number;

  readonly unsignedLongValue: number;

  readonly longLongValue: number;

  readonly unsignedLongLongValue: number;

  readonly floatValue: number;

  readonly doubleValue: number;

  readonly boolValue: boolean;

  readonly integerValue: number;

  readonly unsignedIntegerValue: number;

  readonly stringValue: string;

  compare(otherNumber: NSNumber): interop.Enum<typeof NSComparisonResult>;

  isEqualToNumber(number: NSNumber): boolean;

  descriptionWithLocale(locale: interop.Object | null): string;

  static numberWithChar(value: number): NSNumber;

  static numberWithUnsignedChar(value: number): NSNumber;

  static numberWithShort(value: number): NSNumber;

  static numberWithUnsignedShort(value: number): NSNumber;

  static numberWithInt(value: number): NSNumber;

  static numberWithUnsignedInt(value: number): NSNumber;

  static numberWithLong(value: number): NSNumber;

  static numberWithUnsignedLong(value: number): NSNumber;

  static numberWithLongLong(value: number): NSNumber;

  static numberWithUnsignedLongLong(value: number): NSNumber;

  static numberWithFloat(value: number): NSNumber;

  static numberWithDouble(value: number): NSNumber;

  static numberWithBool(value: boolean): NSNumber;

  static numberWithInteger(value: number): NSNumber;

  static numberWithUnsignedInteger(value: number): NSNumber;

  readonly decimalValue: NSDecimal;
}

declare class NSAttributedStringMarkdownSourcePosition extends NSObject implements NSCopying, NSSecureCoding {
  readonly startLine: number;

  readonly startColumn: number;

  readonly endLine: number;

  readonly endColumn: number;

  initWithStartLineStartColumnEndLineEndColumn(startLine: number, startColumn: number, endLine: number, endColumn: number): this;

  rangeInString(string: string): _NSRange;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSNotificationQueue extends NSObject {
  static readonly defaultQueue: NSNotificationQueue;

  initWithNotificationCenter(notificationCenter: NSNotificationCenter): this;

  enqueueNotificationPostingStyle(notification: NSNotification, postingStyle: interop.Enum<typeof NSPostingStyle>): void;

  enqueueNotificationPostingStyleCoalesceMaskForModes(notification: NSNotification, postingStyle: interop.Enum<typeof NSPostingStyle>, coalesceMask: interop.Enum<typeof NSNotificationCoalescing>, modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  dequeueNotificationsMatchingCoalesceMask(notification: NSNotification, coalesceMask: number): void;
}

declare class NSData extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  readonly length: number;

  readonly bytes: interop.Pointer;

  readonly description: string;

  getBytesLength(buffer: interop.PointerConvertible, length: number): void;

  getBytesRange(buffer: interop.PointerConvertible, range: _NSRange): void;

  isEqualToData(other: NSData): boolean;

  subdataWithRange(range: _NSRange): NSData;

  writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;

  writeToURLAtomically(url: NSURL, atomically: boolean): boolean;

  writeToFileOptionsError(path: string, writeOptionsMask: interop.Enum<typeof NSDataWritingOptions>, errorPtr: interop.PointerConvertible): boolean;

  writeToURLOptionsError(url: NSURL, writeOptionsMask: interop.Enum<typeof NSDataWritingOptions>, errorPtr: interop.PointerConvertible): boolean;

  rangeOfDataOptionsRange(dataToFind: NSData, mask: interop.Enum<typeof NSDataSearchOptions>, searchRange: _NSRange): _NSRange;

  enumerateByteRangesUsingBlock(block: (p1: interop.PointerConvertible, p2: _NSRange, p3: interop.PointerConvertible) => void): void;

  static data<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dataWithBytesLength<This extends abstract new (...args: any) => any>(this: This, bytes: interop.PointerConvertible, length: number): InstanceType<This>;

  static dataWithBytesNoCopyLength<This extends abstract new (...args: any) => any>(this: This, bytes: interop.PointerConvertible, length: number): InstanceType<This>;

  static dataWithBytesNoCopyLengthFreeWhenDone<This extends abstract new (...args: any) => any>(this: This, bytes: interop.PointerConvertible, length: number, b: boolean): InstanceType<This>;

  static dataWithContentsOfFileOptionsError<This extends abstract new (...args: any) => any>(this: This, path: string, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): InstanceType<This>;

  static dataWithContentsOfURLOptionsError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): InstanceType<This>;

  static dataWithContentsOfFile<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static dataWithContentsOfURL<This extends abstract new (...args: any) => any>(this: This, url: NSURL): InstanceType<This>;

  initWithBytesLength(bytes: interop.PointerConvertible, length: number): this;

  initWithBytesNoCopyLength(bytes: interop.PointerConvertible, length: number): this;

  initWithBytesNoCopyLengthFreeWhenDone(bytes: interop.PointerConvertible, length: number, b: boolean): this;

  initWithBytesNoCopyLengthDeallocator(bytes: interop.PointerConvertible, length: number, deallocator: (p1: interop.PointerConvertible, p2: number) => void | null): this;

  initWithContentsOfFileOptionsError(path: string, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): this;

  initWithContentsOfURLOptionsError(url: NSURL, readOptionsMask: interop.Enum<typeof NSDataReadingOptions>, errorPtr: interop.PointerConvertible): this;

  initWithContentsOfFile(path: string): this;

  initWithContentsOfURL(url: NSURL): this;

  initWithData(data: NSData): this;

  static dataWithData<This extends abstract new (...args: any) => any>(this: This, data: NSData): InstanceType<This>;

  initWithBase64EncodedStringOptions(base64String: string, options: interop.Enum<typeof NSDataBase64DecodingOptions>): this;

  base64EncodedStringWithOptions(options: interop.Enum<typeof NSDataBase64EncodingOptions>): string;

  initWithBase64EncodedDataOptions(base64Data: NSData, options: interop.Enum<typeof NSDataBase64DecodingOptions>): this;

  base64EncodedDataWithOptions(options: interop.Enum<typeof NSDataBase64EncodingOptions>): NSData;

  decompressedDataUsingAlgorithmError(algorithm: interop.Enum<typeof NSDataCompressionAlgorithm>, error: interop.PointerConvertible): this;

  compressedDataUsingAlgorithmError(algorithm: interop.Enum<typeof NSDataCompressionAlgorithm>, error: interop.PointerConvertible): this;

  getBytes(buffer: interop.PointerConvertible): void;

  static dataWithContentsOfMappedFile(path: string): interop.Object;

  initWithContentsOfMappedFile(path: string): interop.Object;

  initWithBase64Encoding(base64String: string): interop.Object;

  base64Encoding(): string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitDuration extends NSDimension implements NSSecureCoding {
  static readonly hours: NSUnitDuration;

  static readonly minutes: NSUnitDuration;

  static readonly seconds: NSUnitDuration;

  static readonly milliseconds: NSUnitDuration;

  static readonly microseconds: NSUnitDuration;

  static readonly nanoseconds: NSUnitDuration;

  static readonly picoseconds: NSUnitDuration;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSDateInterval extends NSObject implements NSCopying, NSSecureCoding {
  readonly startDate: NSDate;

  readonly endDate: NSDate;

  readonly duration: number;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  initWithStartDateDuration(startDate: NSDate, duration: number): this;

  initWithStartDateEndDate(startDate: NSDate, endDate: NSDate): this;

  compare(dateInterval: NSDateInterval): interop.Enum<typeof NSComparisonResult>;

  isEqualToDateInterval(dateInterval: NSDateInterval): boolean;

  intersectsDateInterval(dateInterval: NSDateInterval): boolean;

  intersectionWithDateInterval(dateInterval: NSDateInterval): NSDateInterval;

  containsDate(date: NSDate): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSFileSecurity extends NSObject implements NSCopying, NSSecureCoding {
  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSRegularExpression extends NSObject implements NSCopying, NSSecureCoding {
  static regularExpressionWithPatternOptionsError(pattern: string, options: interop.Enum<typeof NSRegularExpressionOptions>, error: interop.PointerConvertible): NSRegularExpression;

  initWithPatternOptionsError(pattern: string, options: interop.Enum<typeof NSRegularExpressionOptions>, error: interop.PointerConvertible): this;

  readonly pattern: string;

  readonly options: interop.Enum<typeof NSRegularExpressionOptions>;

  readonly numberOfCaptureGroups: number;

  static escapedPatternForString(string: string): string;

  enumerateMatchesInStringOptionsRangeUsingBlock(string: string, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange, block: (p1: NSTextCheckingResult, p2: interop.Enum<typeof NSMatchingFlags>, p3: interop.PointerConvertible) => void | null): void;

  matchesInStringOptionsRange(string: string, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange): NSArray;

  numberOfMatchesInStringOptionsRange(string: string, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange): number;

  firstMatchInStringOptionsRange(string: string, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange): NSTextCheckingResult;

  rangeOfFirstMatchInStringOptionsRange(string: string, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange): _NSRange;

  stringByReplacingMatchesInStringOptionsRangeWithTemplate(string: string, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange, templ: string): string;

  replaceMatchesInStringOptionsRangeWithTemplate(string: NSMutableString, options: interop.Enum<typeof NSMatchingOptions>, range: _NSRange, templ: string): number;

  replacementStringForResultInStringOffsetTemplate(result: NSTextCheckingResult, string: string, offset: number, templ: string): string;

  static escapedTemplateForString(string: string): string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSRecursiveLock extends NSObject implements NSLocking {
  tryLock(): boolean;

  lockBeforeDate(limit: NSDate): boolean;

  name: string;

  lock(): void;

  unlock(): void;
}

declare class NSItemProvider extends NSObject implements NSCopying {
  init(): this;

  registerDataRepresentationForTypeIdentifierVisibilityLoadHandler(typeIdentifier: string, visibility: interop.Enum<typeof NSItemProviderRepresentationVisibility>, loadHandler: (p1: (p1: NSData, p2: NSError) => void) => NSProgress | null): void;

  registerFileRepresentationForTypeIdentifierFileOptionsVisibilityLoadHandler(typeIdentifier: string, fileOptions: interop.Enum<typeof NSItemProviderFileOptions>, visibility: interop.Enum<typeof NSItemProviderRepresentationVisibility>, loadHandler: (p1: (p1: NSURL, p2: boolean, p3: NSError) => void) => NSProgress | null): void;

  readonly registeredTypeIdentifiers: NSArray;

  registeredTypeIdentifiersWithFileOptions(fileOptions: interop.Enum<typeof NSItemProviderFileOptions>): NSArray;

  hasItemConformingToTypeIdentifier(typeIdentifier: string): boolean;

  hasRepresentationConformingToTypeIdentifierFileOptions(typeIdentifier: string, fileOptions: interop.Enum<typeof NSItemProviderFileOptions>): boolean;

  loadDataRepresentationForTypeIdentifierCompletionHandler(typeIdentifier: string, completionHandler: (p1: NSData, p2: NSError) => void | null): NSProgress;

  loadFileRepresentationForTypeIdentifierCompletionHandler(typeIdentifier: string, completionHandler: (p1: NSURL, p2: NSError) => void | null): NSProgress;

  loadInPlaceFileRepresentationForTypeIdentifierCompletionHandler(typeIdentifier: string, completionHandler: (p1: NSURL, p2: boolean, p3: NSError) => void | null): NSProgress;

  suggestedName: string;

  initWithObject(object: NSItemProviderWriting): this;

  registerObjectVisibility(object: NSItemProviderWriting, visibility: interop.Enum<typeof NSItemProviderRepresentationVisibility>): void;

  registerObjectOfClassVisibilityLoadHandler(aClass: NSItemProviderWriting, visibility: interop.Enum<typeof NSItemProviderRepresentationVisibility>, loadHandler: (p1: (p1: NSItemProviderWriting, p2: NSError) => void) => NSProgress | null): void;

  canLoadObjectOfClass(aClass: NSItemProviderReading): boolean;

  loadObjectOfClassCompletionHandler(aClass: NSItemProviderReading, completionHandler: (p1: NSItemProviderReading, p2: NSError) => void | null): NSProgress;

  initWithItemTypeIdentifier(item: NSSecureCoding | null, typeIdentifier: string | null): this;

  initWithContentsOfURL(fileURL: NSURL): this;

  registerItemForTypeIdentifierLoadHandler(typeIdentifier: string, loadHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: interop.Object, p3: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => void): void;

  loadItemForTypeIdentifierOptionsCompletionHandler(typeIdentifier: string, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, completionHandler: (p1: NSSecureCoding, p2: NSError) => void | null): void;

  previewImageHandler: (p1: (p1: NSSecureCoding, p2: NSError) => void, p2: interop.Object, p3: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => void;

  loadPreviewImageWithOptionsCompletionHandler(options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: (p1: NSSecureCoding, p2: NSError) => void): void;

  registerCKShareWithContainerAllowedSharingOptionsPreparationHandler(container: CKContainer, allowedOptions: CKAllowedSharingOptions, preparationHandler: (p1: (p1: CKShare, p2: NSError) => void) => void): void;

  registerCKShareContainerAllowedSharingOptions(share: CKShare, container: CKContainer, allowedOptions: CKAllowedSharingOptions): void;

  teamData: NSData;

  preferredPresentationSize: CGSize;

  preferredPresentationStyle: interop.Enum<typeof UIPreferredPresentationStyle>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSIndexPath extends NSObject implements NSCopying, NSSecureCoding {
  static indexPathWithIndex<This extends abstract new (...args: any) => any>(this: This, index: number): InstanceType<This>;

  static indexPathWithIndexesLength<This extends abstract new (...args: any) => any>(this: This, indexes: interop.PointerConvertible, length: number): InstanceType<This>;

  initWithIndexesLength(indexes: interop.PointerConvertible, length: number): this;

  initWithIndex(index: number): this;

  indexPathByAddingIndex(index: number): NSIndexPath;

  indexPathByRemovingLastIndex(): NSIndexPath;

  indexAtPosition(position: number): number;

  readonly length: number;

  getIndexesRange(indexes: interop.PointerConvertible, positionRange: _NSRange): void;

  compare(otherObject: NSIndexPath): interop.Enum<typeof NSComparisonResult>;

  getIndexes(indexes: interop.PointerConvertible): void;

  static indexPathForRowInSection<This extends abstract new (...args: any) => any>(this: This, row: number, section: number): InstanceType<This>;

  static indexPathForItemInSection<This extends abstract new (...args: any) => any>(this: This, item: number, section: number): InstanceType<This>;

  readonly section: number;

  readonly row: number;

  readonly item: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSSortDescriptor extends NSObject implements NSSecureCoding, NSCopying {
  static sortDescriptorWithKeyAscending<This extends abstract new (...args: any) => any>(this: This, key: string | null, ascending: boolean): InstanceType<This>;

  static sortDescriptorWithKeyAscendingSelector<This extends abstract new (...args: any) => any>(this: This, key: string | null, ascending: boolean, selector: string | null): InstanceType<This>;

  initWithKeyAscending(key: string | null, ascending: boolean): this;

  initWithKeyAscendingSelector(key: string | null, ascending: boolean, selector: string | null): this;

  initWithCoder(coder: NSCoder): this;

  readonly key: string;

  readonly ascending: boolean;

  readonly selector: string;

  allowEvaluation(): void;

  static sortDescriptorWithKeyAscendingComparator<This extends abstract new (...args: any) => any>(this: This, key: string | null, ascending: boolean, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): InstanceType<This>;

  initWithKeyAscendingComparator(key: string | null, ascending: boolean, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): this;

  readonly comparator: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>;

  compareObjectToObject(object1: interop.Object, object2: interop.Object): interop.Enum<typeof NSComparisonResult>;

  readonly reversedSortDescriptor: interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSCountedSet<ObjectType = interop.Object> extends NSMutableSet {
  initWithCapacity(numItems: number): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithSet(set: NSSet): this;

  countForObject(object: ObjectType): number;

  objectEnumerator(): NSEnumerator;

  addObject(object: ObjectType): void;

  removeObject(object: ObjectType): void;
}

declare class NSUnitDispersion extends NSDimension implements NSSecureCoding {
  static readonly partsPerMillion: NSUnitDispersion;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUserDefaults extends NSObject {
  static readonly standardUserDefaults: NSUserDefaults;

  static resetStandardUserDefaults(): void;

  init(): this;

  initWithSuiteName(suitename: string | null): this;

  initWithUser(username: string): interop.Object;

  objectForKey(defaultName: string): interop.Object;

  setObjectForKey(value: interop.Object | null, defaultName: string): void;

  removeObjectForKey(defaultName: string): void;

  stringForKey(defaultName: string): string;

  arrayForKey(defaultName: string): NSArray;

  dictionaryForKey(defaultName: string): NSDictionary;

  dataForKey(defaultName: string): NSData;

  stringArrayForKey(defaultName: string): NSArray;

  integerForKey(defaultName: string): number;

  floatForKey(defaultName: string): number;

  doubleForKey(defaultName: string): number;

  boolForKey(defaultName: string): boolean;

  URLForKey(defaultName: string): NSURL;

  setIntegerForKey(value: number, defaultName: string): void;

  setFloatForKey(value: number, defaultName: string): void;

  setDoubleForKey(value: number, defaultName: string): void;

  setBoolForKey(value: boolean, defaultName: string): void;

  setURLForKey(url: NSURL | null, defaultName: string): void;

  registerDefaults(registrationDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  addSuiteNamed(suiteName: string): void;

  removeSuiteNamed(suiteName: string): void;

  dictionaryRepresentation(): NSDictionary;

  readonly volatileDomainNames: NSArray;

  volatileDomainForName(domainName: string): NSDictionary;

  setVolatileDomainForName(domain: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, domainName: string): void;

  removeVolatileDomainForName(domainName: string): void;

  persistentDomainNames(): NSArray;

  persistentDomainForName(domainName: string): NSDictionary;

  setPersistentDomainForName(domain: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, domainName: string): void;

  removePersistentDomainForName(domainName: string): void;

  synchronize(): boolean;

  objectIsForcedForKey(key: string): boolean;

  objectIsForcedForKeyInDomain(key: string, domain: string): boolean;
}

declare class NSMorphologyPronoun extends NSObject implements NSCopying, NSSecureCoding {
  initWithPronounMorphologyDependentMorphology(pronoun: string, morphology: NSMorphology, dependentMorphology: NSMorphology | null): this;

  readonly pronoun: string;

  readonly morphology: NSMorphology;

  readonly dependentMorphology: NSMorphology;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLSession extends NSObject {
  static readonly sharedSession: NSURLSession;

  static sessionWithConfiguration(configuration: NSURLSessionConfiguration): NSURLSession;

  static sessionWithConfigurationDelegateDelegateQueue(configuration: NSURLSessionConfiguration, delegate: NSURLSessionDelegate | null, queue: NSOperationQueue | null): NSURLSession;

  readonly delegateQueue: NSOperationQueue;

  readonly delegate: NSURLSessionDelegate;

  readonly configuration: NSURLSessionConfiguration;

  sessionDescription: string;

  finishTasksAndInvalidate(): void;

  invalidateAndCancel(): void;

  resetWithCompletionHandler(completionHandler: () => void): void;

  flushWithCompletionHandler(completionHandler: () => void): void;

  getTasksWithCompletionHandler(completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>, p2: NSArray<interop.Object> | Array<interop.Object>, p3: NSArray<interop.Object> | Array<interop.Object>) => void): void;

  getAllTasksWithCompletionHandler(completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>) => void): void;

  dataTaskWithRequest(request: NSURLRequest): NSURLSessionDataTask;

  dataTaskWithURL(url: NSURL): NSURLSessionDataTask;

  uploadTaskWithRequestFromFile(request: NSURLRequest, fileURL: NSURL): NSURLSessionUploadTask;

  uploadTaskWithRequestFromData(request: NSURLRequest, bodyData: NSData): NSURLSessionUploadTask;

  uploadTaskWithResumeData(resumeData: NSData): NSURLSessionUploadTask;

  uploadTaskWithStreamedRequest(request: NSURLRequest): NSURLSessionUploadTask;

  downloadTaskWithRequest(request: NSURLRequest): NSURLSessionDownloadTask;

  downloadTaskWithURL(url: NSURL): NSURLSessionDownloadTask;

  downloadTaskWithResumeData(resumeData: NSData): NSURLSessionDownloadTask;

  streamTaskWithHostNamePort(hostname: string, port: number): NSURLSessionStreamTask;

  streamTaskWithNetService(service: NSNetService): NSURLSessionStreamTask;

  webSocketTaskWithURL(url: NSURL): NSURLSessionWebSocketTask;

  webSocketTaskWithURLProtocols(url: NSURL, protocols: NSArray<interop.Object> | Array<interop.Object>): NSURLSessionWebSocketTask;

  webSocketTaskWithRequest(request: NSURLRequest): NSURLSessionWebSocketTask;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  dataTaskWithRequestCompletionHandler(request: NSURLRequest, completionHandler: (p1: NSData, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionDataTask;

  dataTaskWithURLCompletionHandler(url: NSURL, completionHandler: (p1: NSData, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionDataTask;

  uploadTaskWithRequestFromFileCompletionHandler(request: NSURLRequest, fileURL: NSURL, completionHandler: (p1: NSData, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionUploadTask;

  uploadTaskWithRequestFromDataCompletionHandler(request: NSURLRequest, bodyData: NSData | null, completionHandler: (p1: NSData, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionUploadTask;

  uploadTaskWithResumeDataCompletionHandler(resumeData: NSData, completionHandler: (p1: NSData, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionUploadTask;

  downloadTaskWithRequestCompletionHandler(request: NSURLRequest, completionHandler: (p1: NSURL, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionDownloadTask;

  downloadTaskWithURLCompletionHandler(url: NSURL, completionHandler: (p1: NSURL, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionDownloadTask;

  downloadTaskWithResumeDataCompletionHandler(resumeData: NSData, completionHandler: (p1: NSURL, p2: NSURLResponse, p3: NSError) => void | null): NSURLSessionDownloadTask;
}

declare class NSNumberFormatter extends NSFormatter {
  formattingContext: interop.Enum<typeof NSFormattingContext>;

  getObjectValueForStringRangeError(obj: interop.PointerConvertible, string: string, rangep: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  stringFromNumber(number: NSNumber): string;

  numberFromString(string: string): NSNumber;

  static localizedStringFromNumberNumberStyle(num: NSNumber, nstyle: interop.Enum<typeof NSNumberFormatterStyle>): string;

  static defaultFormatterBehavior(): interop.Enum<typeof NSNumberFormatterBehavior>;

  static setDefaultFormatterBehavior(behavior: interop.Enum<typeof NSNumberFormatterBehavior>): void;

  numberStyle: interop.Enum<typeof NSNumberFormatterStyle>;

  locale: NSLocale;

  generatesDecimalNumbers: boolean;

  formatterBehavior: interop.Enum<typeof NSNumberFormatterBehavior>;

  negativeFormat: string;

  get textAttributesForNegativeValues(): NSDictionary;
  set textAttributesForNegativeValues(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  positiveFormat: string;

  get textAttributesForPositiveValues(): NSDictionary;
  set textAttributesForPositiveValues(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  allowsFloats: boolean;

  decimalSeparator: string;

  alwaysShowsDecimalSeparator: boolean;

  currencyDecimalSeparator: string;

  usesGroupingSeparator: boolean;

  groupingSeparator: string;

  zeroSymbol: string;

  get textAttributesForZero(): NSDictionary;
  set textAttributesForZero(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  nilSymbol: string;

  get textAttributesForNil(): NSDictionary;
  set textAttributesForNil(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  notANumberSymbol: string;

  get textAttributesForNotANumber(): NSDictionary;
  set textAttributesForNotANumber(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  positiveInfinitySymbol: string;

  get textAttributesForPositiveInfinity(): NSDictionary;
  set textAttributesForPositiveInfinity(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  negativeInfinitySymbol: string;

  get textAttributesForNegativeInfinity(): NSDictionary;
  set textAttributesForNegativeInfinity(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  positivePrefix: string;

  positiveSuffix: string;

  negativePrefix: string;

  negativeSuffix: string;

  currencyCode: string;

  currencySymbol: string;

  internationalCurrencySymbol: string;

  percentSymbol: string;

  perMillSymbol: string;

  minusSign: string;

  plusSign: string;

  exponentSymbol: string;

  groupingSize: number;

  secondaryGroupingSize: number;

  multiplier: NSNumber;

  formatWidth: number;

  paddingCharacter: string;

  paddingPosition: interop.Enum<typeof NSNumberFormatterPadPosition>;

  roundingMode: interop.Enum<typeof NSNumberFormatterRoundingMode>;

  roundingIncrement: NSNumber;

  minimumIntegerDigits: number;

  maximumIntegerDigits: number;

  minimumFractionDigits: number;

  maximumFractionDigits: number;

  minimum: NSNumber;

  maximum: NSNumber;

  currencyGroupingSeparator: string;

  isLenient: boolean;

  usesSignificantDigits: boolean;

  minimumSignificantDigits: number;

  maximumSignificantDigits: number;

  isPartialStringValidationEnabled: boolean;
}

declare class NSDateFormatter extends NSFormatter {
  formattingContext: interop.Enum<typeof NSFormattingContext>;

  getObjectValueForStringRangeError(obj: interop.PointerConvertible, string: string, rangep: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  stringFromDate(date: NSDate): string;

  dateFromString(string: string): NSDate;

  static localizedStringFromDateDateStyleTimeStyle(date: NSDate, dstyle: interop.Enum<typeof NSDateFormatterStyle>, tstyle: interop.Enum<typeof NSDateFormatterStyle>): string;

  static dateFormatFromTemplateOptionsLocale(tmplate: string, opts: number, locale: NSLocale | null): string;

  static defaultFormatterBehavior: interop.Enum<typeof NSDateFormatterBehavior>;

  setLocalizedDateFormatFromTemplate(dateFormatTemplate: string): void;

  dateFormat: string;

  dateStyle: interop.Enum<typeof NSDateFormatterStyle>;

  timeStyle: interop.Enum<typeof NSDateFormatterStyle>;

  locale: NSLocale;

  generatesCalendarDates: boolean;

  formatterBehavior: interop.Enum<typeof NSDateFormatterBehavior>;

  timeZone: NSTimeZone;

  calendar: NSCalendar;

  isLenient: boolean;

  twoDigitStartDate: NSDate;

  defaultDate: NSDate;

  get eraSymbols(): NSArray;
  set eraSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get monthSymbols(): NSArray;
  set monthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortMonthSymbols(): NSArray;
  set shortMonthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get weekdaySymbols(): NSArray;
  set weekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortWeekdaySymbols(): NSArray;
  set shortWeekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  AMSymbol: string;

  PMSymbol: string;

  get longEraSymbols(): NSArray;
  set longEraSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get veryShortMonthSymbols(): NSArray;
  set veryShortMonthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get standaloneMonthSymbols(): NSArray;
  set standaloneMonthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortStandaloneMonthSymbols(): NSArray;
  set shortStandaloneMonthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get veryShortStandaloneMonthSymbols(): NSArray;
  set veryShortStandaloneMonthSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get veryShortWeekdaySymbols(): NSArray;
  set veryShortWeekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get standaloneWeekdaySymbols(): NSArray;
  set standaloneWeekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortStandaloneWeekdaySymbols(): NSArray;
  set shortStandaloneWeekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get veryShortStandaloneWeekdaySymbols(): NSArray;
  set veryShortStandaloneWeekdaySymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get quarterSymbols(): NSArray;
  set quarterSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortQuarterSymbols(): NSArray;
  set shortQuarterSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get standaloneQuarterSymbols(): NSArray;
  set standaloneQuarterSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  get shortStandaloneQuarterSymbols(): NSArray;
  set shortStandaloneQuarterSymbols(value: NSArray<interop.Object> | Array<interop.Object>);

  gregorianStartDate: NSDate;

  doesRelativeDateFormatting: boolean;
}

declare class NSUndoManager extends NSObject {
  beginUndoGrouping(): void;

  endUndoGrouping(): void;

  readonly groupingLevel: number;

  disableUndoRegistration(): void;

  enableUndoRegistration(): void;

  readonly isUndoRegistrationEnabled: boolean;

  groupsByEvent: boolean;

  levelsOfUndo: number;

  get runLoopModes(): NSArray;
  set runLoopModes(value: NSArray<interop.Object> | Array<interop.Object>);

  undo(): void;

  redo(): void;

  undoNestedGroup(): void;

  readonly canUndo: boolean;

  readonly canRedo: boolean;

  readonly isUndoing: boolean;

  readonly isRedoing: boolean;

  removeAllActions(): void;

  removeAllActionsWithTarget(target: interop.Object): void;

  registerUndoWithTargetSelectorObject(target: interop.Object, selector: string, anObject: interop.Object | null): void;

  prepareWithInvocationTarget(target: interop.Object): interop.Object;

  registerUndoWithTargetHandler(target: interop.Object, undoHandler: (p1: interop.Object) => void): void;

  setActionIsDiscardable(discardable: boolean): void;

  readonly undoActionIsDiscardable: boolean;

  readonly redoActionIsDiscardable: boolean;

  readonly undoActionName: string;

  readonly redoActionName: string;

  setActionName(actionName: string): void;

  readonly undoMenuItemTitle: string;

  readonly redoMenuItemTitle: string;

  undoMenuTitleForUndoActionName(actionName: string): string;

  redoMenuTitleForUndoActionName(actionName: string): string;
}

// @ts-ignore
declare class NSMutableArray<ObjectType = interop.Object> extends NSArray {
  addObject(anObject: ObjectType): void;

  insertObjectAtIndex(anObject: ObjectType, index: number): void;

  removeLastObject(): void;

  removeObjectAtIndex(index: number): void;

  replaceObjectAtIndexWithObject(index: number, anObject: ObjectType): void;

  init(): this;

  initWithCapacity(numItems: number): this;

  initWithCoder(coder: NSCoder): this;

  addObjectsFromArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  exchangeObjectAtIndexWithObjectAtIndex(idx1: number, idx2: number): void;

  removeAllObjects(): void;

  removeObjectInRange(anObject: ObjectType, range: _NSRange): void;

  removeObject(anObject: ObjectType): void;

  removeObjectIdenticalToInRange(anObject: ObjectType, range: _NSRange): void;

  removeObjectIdenticalTo(anObject: ObjectType): void;

  removeObjectsFromIndicesNumIndices(indices: interop.PointerConvertible, cnt: number): void;

  removeObjectsInArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  removeObjectsInRange(range: _NSRange): void;

  replaceObjectsInRangeWithObjectsFromArrayRange(range: _NSRange, otherArray: NSArray<interop.Object> | Array<interop.Object>, otherRange: _NSRange): void;

  replaceObjectsInRangeWithObjectsFromArray(range: _NSRange, otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  setArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): void;

  sortUsingFunctionContext(compare: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => number | null, context: interop.PointerConvertible): void;

  sortUsingSelector(comparator: string): void;

  insertObjectsAtIndexes(objects: NSArray<interop.Object> | Array<interop.Object>, indexes: NSIndexSet): void;

  removeObjectsAtIndexes(indexes: NSIndexSet): void;

  replaceObjectsAtIndexesWithObjects(indexes: NSIndexSet, objects: NSArray<interop.Object> | Array<interop.Object>): void;

  setObjectAtIndexedSubscript(obj: ObjectType, idx: number): void;

  sortUsingComparator(cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): void;

  sortWithOptionsUsingComparator(opts: interop.Enum<typeof NSSortOptions>, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): void;

  static arrayWithCapacity<ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;

  // @ts-ignore
  static arrayWithContentsOfFile<ObjectType>(path: string): NSMutableArray;

  // @ts-ignore
  static arrayWithContentsOfURL<ObjectType>(url: NSURL): NSMutableArray;

  // @ts-ignore
  initWithContentsOfFile(path: string): NSMutableArray;

  // @ts-ignore
  initWithContentsOfURL(url: NSURL): NSMutableArray;

  applyDifference(difference: NSOrderedCollectionDifference): void;

  sortUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): void;

  filterUsingPredicate(predicate: NSPredicate): void;
}

declare class NSXPCConnection extends NSObject implements NSXPCProxyCreating {
  readonly serviceName: string;

  initWithListenerEndpoint(endpoint: NSXPCListenerEndpoint): this;

  readonly endpoint: NSXPCListenerEndpoint;

  exportedInterface: NSXPCInterface;

  exportedObject: interop.Object;

  remoteObjectInterface: NSXPCInterface;

  readonly remoteObjectProxy: interop.Object;

  remoteObjectProxyWithErrorHandler(handler: (p1: NSError) => void): interop.Object;

  synchronousRemoteObjectProxyWithErrorHandler(handler: (p1: NSError) => void): interop.Object;

  interruptionHandler: () => void;

  invalidationHandler: () => void;

  resume(): void;

  suspend(): void;

  activate(): void;

  invalidate(): void;

  readonly auditSessionIdentifier: number;

  readonly processIdentifier: number;

  readonly effectiveUserIdentifier: number;

  readonly effectiveGroupIdentifier: number;

  static currentConnection(): NSXPCConnection;

  scheduleSendBarrierBlock(block: () => void): void;
}

declare class NSInvocation extends NSObject {
  static invocationWithMethodSignature(sig: NSMethodSignature): NSInvocation;

  readonly methodSignature: NSMethodSignature;

  retainArguments(): void;

  readonly argumentsRetained: boolean;

  target: interop.Object;

  selector: string;

  getReturnValue(retLoc: interop.PointerConvertible): void;

  setReturnValue(retLoc: interop.PointerConvertible): void;

  getArgumentAtIndex(argumentLocation: interop.PointerConvertible, idx: number): void;

  setArgumentAtIndex(argumentLocation: interop.PointerConvertible, idx: number): void;

  invoke(): void;

  invokeWithTarget(target: interop.Object): void;

  invokeUsingIMP(imp: () => void): void;
}

declare class NSCharacterSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  static readonly controlCharacterSet: NSCharacterSet;

  static readonly whitespaceCharacterSet: NSCharacterSet;

  static readonly whitespaceAndNewlineCharacterSet: NSCharacterSet;

  static readonly decimalDigitCharacterSet: NSCharacterSet;

  static readonly letterCharacterSet: NSCharacterSet;

  static readonly lowercaseLetterCharacterSet: NSCharacterSet;

  static readonly uppercaseLetterCharacterSet: NSCharacterSet;

  static readonly nonBaseCharacterSet: NSCharacterSet;

  static readonly alphanumericCharacterSet: NSCharacterSet;

  static readonly decomposableCharacterSet: NSCharacterSet;

  static readonly illegalCharacterSet: NSCharacterSet;

  static readonly punctuationCharacterSet: NSCharacterSet;

  static readonly capitalizedLetterCharacterSet: NSCharacterSet;

  static readonly symbolCharacterSet: NSCharacterSet;

  static readonly newlineCharacterSet: NSCharacterSet;

  static characterSetWithRange(aRange: _NSRange): NSCharacterSet;

  static characterSetWithCharactersInString(aString: string): NSCharacterSet;

  static characterSetWithBitmapRepresentation(data: NSData): NSCharacterSet;

  static characterSetWithContentsOfFile(fName: string): NSCharacterSet;

  initWithCoder(coder: NSCoder): this;

  characterIsMember(aCharacter: number): boolean;

  readonly bitmapRepresentation: NSData;

  readonly invertedSet: NSCharacterSet;

  longCharacterIsMember(theLongChar: number): boolean;

  isSupersetOfSet(theOtherSet: NSCharacterSet): boolean;

  hasMemberInPlane(thePlane: number): boolean;

  static readonly URLUserAllowedCharacterSet: NSCharacterSet;

  static readonly URLPasswordAllowedCharacterSet: NSCharacterSet;

  static readonly URLHostAllowedCharacterSet: NSCharacterSet;

  static readonly URLPathAllowedCharacterSet: NSCharacterSet;

  static readonly URLQueryAllowedCharacterSet: NSCharacterSet;

  static readonly URLFragmentAllowedCharacterSet: NSCharacterSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSURLSessionUploadTask extends NSURLSessionDataTask {
  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  cancelByProducingResumeData(completionHandler: (p1: NSData) => void | null): void;
}

declare class NSPurgeableData extends NSMutableData implements NSDiscardableContent {
  beginContentAccess(): boolean;

  endContentAccess(): void;

  discardContentIfPossible(): void;

  isContentDiscarded(): boolean;
}

declare class NSXPCCoder extends NSCoder {
  userInfo: NSObject;

  readonly connection: NSXPCConnection;
}

declare class NSUnitVolume extends NSDimension implements NSSecureCoding {
  static readonly megaliters: NSUnitVolume;

  static readonly kiloliters: NSUnitVolume;

  static readonly liters: NSUnitVolume;

  static readonly deciliters: NSUnitVolume;

  static readonly centiliters: NSUnitVolume;

  static readonly milliliters: NSUnitVolume;

  static readonly cubicKilometers: NSUnitVolume;

  static readonly cubicMeters: NSUnitVolume;

  static readonly cubicDecimeters: NSUnitVolume;

  static readonly cubicCentimeters: NSUnitVolume;

  static readonly cubicMillimeters: NSUnitVolume;

  static readonly cubicInches: NSUnitVolume;

  static readonly cubicFeet: NSUnitVolume;

  static readonly cubicYards: NSUnitVolume;

  static readonly cubicMiles: NSUnitVolume;

  static readonly acreFeet: NSUnitVolume;

  static readonly bushels: NSUnitVolume;

  static readonly teaspoons: NSUnitVolume;

  static readonly tablespoons: NSUnitVolume;

  static readonly fluidOunces: NSUnitVolume;

  static readonly cups: NSUnitVolume;

  static readonly pints: NSUnitVolume;

  static readonly quarts: NSUnitVolume;

  static readonly gallons: NSUnitVolume;

  static readonly imperialTeaspoons: NSUnitVolume;

  static readonly imperialTablespoons: NSUnitVolume;

  static readonly imperialFluidOunces: NSUnitVolume;

  static readonly imperialPints: NSUnitVolume;

  static readonly imperialQuarts: NSUnitVolume;

  static readonly imperialGallons: NSUnitVolume;

  static readonly metricCups: NSUnitVolume;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSFormatter extends NSObject implements NSCopying, NSCoding {
  stringForObjectValue(obj: interop.Object | null): string;

  attributedStringForObjectValueWithDefaultAttributes(obj: interop.Object, attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSAttributedString;

  editingStringForObjectValue(obj: interop.Object): string;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;

  isPartialStringValidNewEditingStringErrorDescription(partialString: string, newString: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  isPartialStringValidProposedSelectedRangeOriginalStringOriginalSelectedRangeErrorDescription(partialStringPtr: interop.PointerConvertible, proposedSelRangePtr: interop.PointerConvertible, origString: string, origSelRange: _NSRange, error: interop.PointerConvertible): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSPointerArray extends NSObject implements NSFastEnumeration, NSCopying, NSSecureCoding {
  initWithOptions(options: interop.Enum<typeof NSPointerFunctionsOptions>): this;

  initWithPointerFunctions(functions: NSPointerFunctions): this;

  static pointerArrayWithOptions(options: interop.Enum<typeof NSPointerFunctionsOptions>): NSPointerArray;

  static pointerArrayWithPointerFunctions(functions: NSPointerFunctions): NSPointerArray;

  readonly pointerFunctions: NSPointerFunctions;

  pointerAtIndex(index: number): interop.Pointer;

  addPointer(pointer: interop.PointerConvertible): void;

  removePointerAtIndex(index: number): void;

  insertPointerAtIndex(item: interop.PointerConvertible, index: number): void;

  replacePointerAtIndexWithPointer(index: number, item: interop.PointerConvertible): void;

  compact(): void;

  count: number;

  static strongObjectsPointerArray(): NSPointerArray;

  static weakObjectsPointerArray(): NSPointerArray;

  readonly allObjects: NSArray;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLSessionDataTask extends NSURLSessionTask {
  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

declare class NSMorphology extends NSObject implements NSCopying, NSSecureCoding {
  grammaticalGender: interop.Enum<typeof NSGrammaticalGender>;

  partOfSpeech: interop.Enum<typeof NSGrammaticalPartOfSpeech>;

  number: interop.Enum<typeof NSGrammaticalNumber>;

  grammaticalCase: interop.Enum<typeof NSGrammaticalCase>;

  determination: interop.Enum<typeof NSGrammaticalDetermination>;

  grammaticalPerson: interop.Enum<typeof NSGrammaticalPerson>;

  pronounType: interop.Enum<typeof NSGrammaticalPronounType>;

  definiteness: interop.Enum<typeof NSGrammaticalDefiniteness>;

  customPronounForLanguage(language: string): NSMorphologyCustomPronoun;

  setCustomPronounForLanguageError(features: NSMorphologyCustomPronoun | null, language: string, error: interop.PointerConvertible): boolean;

  readonly isUnspecified: boolean;

  static readonly userMorphology: NSMorphology;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLProtectionSpace extends NSObject implements NSSecureCoding, NSCopying {
  initWithHostPortProtocolRealmAuthenticationMethod(host: string, port: number, protocol: string | null, realm: string | null, authenticationMethod: string | null): this;

  initWithProxyHostPortTypeRealmAuthenticationMethod(host: string, port: number, type: string | null, realm: string | null, authenticationMethod: string | null): this;

  readonly realm: string;

  readonly receivesCredentialSecurely: boolean;

  readonly isProxy: boolean;

  readonly host: string;

  readonly port: number;

  readonly proxyType: string;

  readonly protocol: string;

  readonly authenticationMethod: string;

  readonly distinguishedNames: NSArray;

  readonly serverTrust: interop.Pointer;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSNetServiceBrowser extends NSObject {
  init(): this;

  delegate: NSNetServiceBrowserDelegate;

  includesPeerToPeer: boolean;

  scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  searchForBrowsableDomains(): void;

  searchForRegistrationDomains(): void;

  searchForServicesOfTypeInDomain(type: string, domainString: string): void;

  stop(): void;
}

declare class NSValueTransformer extends NSObject {
  static setValueTransformerForName(transformer: NSValueTransformer | null, name: string): void;

  static valueTransformerForName(name: string): NSValueTransformer;

  static valueTransformerNames(): NSArray;

  static transformedValueClass(): interop.Object;

  static allowsReverseTransformation(): boolean;

  transformedValue(value: interop.Object | null): interop.Object;

  reverseTransformedValue(value: interop.Object | null): interop.Object;
}

declare class NSUnitEnergy extends NSDimension implements NSSecureCoding {
  static readonly kilojoules: NSUnitEnergy;

  static readonly joules: NSUnitEnergy;

  static readonly kilocalories: NSUnitEnergy;

  static readonly calories: NSUnitEnergy;

  static readonly kilowattHours: NSUnitEnergy;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSArray<ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  objectAtIndex(index: number): ObjectType;

  init(): this;

  initWithObjectsCount(objects: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  arrayByAddingObject(anObject: ObjectType): NSArray;

  arrayByAddingObjectsFromArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  componentsJoinedByString(separator: string): string;

  containsObject(anObject: ObjectType): boolean;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  descriptionWithLocaleIndent(locale: interop.Object | null, level: number): string;

  firstObjectCommonWithArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): ObjectType;

  getObjectsRange(objects: interop.PointerConvertible, range: _NSRange): void;

  indexOfObject(anObject: ObjectType): number;

  indexOfObjectInRange(anObject: ObjectType, range: _NSRange): number;

  indexOfObjectIdenticalTo(anObject: ObjectType): number;

  indexOfObjectIdenticalToInRange(anObject: ObjectType, range: _NSRange): number;

  isEqualToArray(otherArray: NSArray<interop.Object> | Array<interop.Object>): boolean;

  readonly firstObject: ObjectType;

  readonly lastObject: ObjectType;

  objectEnumerator(): NSEnumerator;

  reverseObjectEnumerator(): NSEnumerator;

  readonly sortedArrayHint: NSData;

  sortedArrayUsingFunctionContext(comparator: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => number | null, context: interop.PointerConvertible): NSArray;

  sortedArrayUsingFunctionContextHint(comparator: (p1: interop.Object, p2: interop.Object, p3: interop.PointerConvertible) => number | null, context: interop.PointerConvertible, hint: NSData | null): NSArray;

  sortedArrayUsingSelector(comparator: string): NSArray;

  subarrayWithRange(range: _NSRange): NSArray;

  writeToURLError(url: NSURL, error: interop.PointerConvertible): boolean;

  makeObjectsPerformSelector(aSelector: string): void;

  makeObjectsPerformSelectorWithObject(aSelector: string, argument: interop.Object | null): void;

  objectsAtIndexes(indexes: NSIndexSet): NSArray;

  objectAtIndexedSubscript(idx: number): ObjectType;

  enumerateObjectsUsingBlock(block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  enumerateObjectsWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  enumerateObjectsAtIndexesOptionsUsingBlock(s: NSIndexSet, opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  indexOfObjectPassingTest(predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): number;

  indexOfObjectWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): number;

  indexOfObjectAtIndexesOptionsPassingTest(s: NSIndexSet, opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): number;

  indexesOfObjectsPassingTest(predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): NSIndexSet;

  indexesOfObjectsWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): NSIndexSet;

  indexesOfObjectsAtIndexesOptionsPassingTest(s: NSIndexSet, opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): NSIndexSet;

  sortedArrayUsingComparator(cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): NSArray;

  sortedArrayWithOptionsUsingComparator(opts: interop.Enum<typeof NSSortOptions>, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): NSArray;

  indexOfObjectInSortedRangeOptionsUsingComparator(obj: ObjectType, r: _NSRange, opts: interop.Enum<typeof NSBinarySearchingOptions>, cmp: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): number;

  static array<ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static arrayWithObject<ObjectType, This extends abstract new (...args: any) => any>(this: This, anObject: ObjectType): InstanceType<This>;

  static arrayWithObjectsCount<ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static arrayWithObjects<ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObj: ObjectType): InstanceType<This>;

  static arrayWithArray<ObjectType, This extends abstract new (...args: any) => any>(this: This, array: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjects(firstObj: ObjectType): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithArrayCopyItems(array: NSArray<interop.Object> | Array<interop.Object>, flag: boolean): this;

  initWithContentsOfURLError(url: NSURL, error: interop.PointerConvertible): NSArray;

  static arrayWithContentsOfURLError<ObjectType>(url: NSURL, error: interop.PointerConvertible): NSArray;

  differenceFromArrayWithOptionsUsingEquivalenceTest(other: NSArray<interop.Object> | Array<interop.Object>, options: interop.Enum<typeof NSOrderedCollectionDifferenceCalculationOptions>, block: (p1: interop.Object, p2: interop.Object) => boolean): NSOrderedCollectionDifference;

  differenceFromArrayWithOptions(other: NSArray<interop.Object> | Array<interop.Object>, options: interop.Enum<typeof NSOrderedCollectionDifferenceCalculationOptions>): NSOrderedCollectionDifference;

  differenceFromArray(other: NSArray<interop.Object> | Array<interop.Object>): NSOrderedCollectionDifference;

  arrayByApplyingDifference(difference: NSOrderedCollectionDifference): NSArray;

  getObjects(objects: interop.PointerConvertible): void;

  static arrayWithContentsOfFile<ObjectType>(path: string): NSArray;

  static arrayWithContentsOfURL<ObjectType>(url: NSURL): NSArray;

  initWithContentsOfFile(path: string): NSArray;

  initWithContentsOfURL(url: NSURL): NSArray;

  writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;

  writeToURLAtomically(url: NSURL, atomically: boolean): boolean;

  pathsMatchingExtensions(filterTypes: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;

  addObserverToObjectsAtIndexesForKeyPathOptionsContext(observer: NSObject, indexes: NSIndexSet, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverFromObjectsAtIndexesForKeyPathContext(observer: NSObject, indexes: NSIndexSet, keyPath: string, context: interop.PointerConvertible): void;

  removeObserverFromObjectsAtIndexesForKeyPath(observer: NSObject, indexes: NSIndexSet, keyPath: string): void;

  addObserverForKeyPathOptionsContext(observer: NSObject, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverForKeyPathContext(observer: NSObject, keyPath: string, context: interop.PointerConvertible): void;

  removeObserverForKeyPath(observer: NSObject, keyPath: string): void;

  sortedArrayUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  filteredArrayUsingPredicate(predicate: NSPredicate): NSArray;

  shuffledArrayWithRandomSource(randomSource: GKRandomSource): NSArray;

  shuffledArray(): NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSOrthography extends NSObject implements NSCopying, NSSecureCoding {
  readonly dominantScript: string;

  readonly languageMap: NSDictionary;

  initWithDominantScriptLanguageMap(script: string, map: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  initWithCoder(coder: NSCoder): this;

  languagesForScript(script: string): NSArray;

  dominantLanguageForScript(script: string): string;

  readonly dominantLanguage: string;

  readonly allScripts: NSArray;

  readonly allLanguages: NSArray;

  static defaultOrthographyForLanguage<This extends abstract new (...args: any) => any>(this: This, language: string): InstanceType<This>;

  static orthographyWithDominantScriptLanguageMap<This extends abstract new (...args: any) => any>(this: This, script: string, map: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSUnitConverter extends NSObject {
  baseUnitValueFromValue(value: number): number;

  valueFromBaseUnitValue(baseUnitValue: number): number;
}

declare class NSNull extends NSObject implements NSCopying, NSSecureCoding {
  static null(): NSNull;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLProtocol extends NSObject {
  initWithRequestCachedResponseClient(request: NSURLRequest, cachedResponse: NSCachedURLResponse | null, client: NSURLProtocolClient | null): this;

  readonly client: NSURLProtocolClient;

  readonly request: NSURLRequest;

  readonly cachedResponse: NSCachedURLResponse;

  static canInitWithRequest(request: NSURLRequest): boolean;

  static canonicalRequestForRequest(request: NSURLRequest): NSURLRequest;

  static requestIsCacheEquivalentToRequest(a: NSURLRequest, b: NSURLRequest): boolean;

  startLoading(): void;

  stopLoading(): void;

  static propertyForKeyInRequest(key: string, request: NSURLRequest): interop.Object;

  static setPropertyForKeyInRequest(value: interop.Object, key: string, request: NSMutableURLRequest): void;

  static removePropertyForKeyInRequest(key: string, request: NSMutableURLRequest): void;

  static registerClass(protocolClass: interop.Object): boolean;

  static unregisterClass(protocolClass: interop.Object): void;

  static canInitWithTask(task: NSURLSessionTask): boolean;

  initWithTaskCachedResponseClient(task: NSURLSessionTask, cachedResponse: NSCachedURLResponse | null, client: NSURLProtocolClient | null): this;

  readonly task: NSURLSessionTask;
}

declare class NSUnitArea extends NSDimension implements NSSecureCoding {
  static readonly squareMegameters: NSUnitArea;

  static readonly squareKilometers: NSUnitArea;

  static readonly squareMeters: NSUnitArea;

  static readonly squareCentimeters: NSUnitArea;

  static readonly squareMillimeters: NSUnitArea;

  static readonly squareMicrometers: NSUnitArea;

  static readonly squareNanometers: NSUnitArea;

  static readonly squareInches: NSUnitArea;

  static readonly squareFeet: NSUnitArea;

  static readonly squareYards: NSUnitArea;

  static readonly squareMiles: NSUnitArea;

  static readonly acres: NSUnitArea;

  static readonly ares: NSUnitArea;

  static readonly hectares: NSUnitArea;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSException extends NSObject implements NSCopying, NSSecureCoding {
  static exceptionWithNameReasonUserInfo(name: string, reason: string | null, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSException;

  initWithNameReasonUserInfo(aName: string, aReason: string | null, aUserInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  readonly name: string;

  readonly reason: string;

  readonly userInfo: NSDictionary;

  readonly callStackReturnAddresses: NSArray;

  readonly callStackSymbols: NSArray;

  raise(): void;

  static raiseFormat(name: string, format: string): void;

  static raiseFormatArguments(name: string, format: string, argList: string): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLResponse extends NSObject implements NSSecureCoding, NSCopying {
  initWithURLMIMETypeExpectedContentLengthTextEncodingName(URL: NSURL, MIMEType: string | null, length: number, name: string | null): this;

  readonly URL: NSURL;

  readonly MIMEType: string;

  readonly expectedContentLength: number;

  readonly textEncodingName: string;

  readonly suggestedFilename: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSUnitElectricResistance extends NSDimension implements NSSecureCoding {
  static readonly megaohms: NSUnitElectricResistance;

  static readonly kiloohms: NSUnitElectricResistance;

  static readonly ohms: NSUnitElectricResistance;

  static readonly milliohms: NSUnitElectricResistance;

  static readonly microohms: NSUnitElectricResistance;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSURLSessionTaskTransactionMetrics extends NSObject {
  readonly request: NSURLRequest;

  readonly response: NSURLResponse;

  readonly fetchStartDate: NSDate;

  readonly domainLookupStartDate: NSDate;

  readonly domainLookupEndDate: NSDate;

  readonly connectStartDate: NSDate;

  readonly secureConnectionStartDate: NSDate;

  readonly secureConnectionEndDate: NSDate;

  readonly connectEndDate: NSDate;

  readonly requestStartDate: NSDate;

  readonly requestEndDate: NSDate;

  readonly responseStartDate: NSDate;

  readonly responseEndDate: NSDate;

  readonly networkProtocolName: string;

  readonly isProxyConnection: boolean;

  readonly isReusedConnection: boolean;

  readonly resourceFetchType: interop.Enum<typeof NSURLSessionTaskMetricsResourceFetchType>;

  readonly countOfRequestHeaderBytesSent: number;

  readonly countOfRequestBodyBytesSent: number;

  readonly countOfRequestBodyBytesBeforeEncoding: number;

  readonly countOfResponseHeaderBytesReceived: number;

  readonly countOfResponseBodyBytesReceived: number;

  readonly countOfResponseBodyBytesAfterDecoding: number;

  readonly localAddress: string;

  readonly localPort: NSNumber;

  readonly remoteAddress: string;

  readonly remotePort: NSNumber;

  readonly negotiatedTLSProtocolVersion: NSNumber;

  readonly negotiatedTLSCipherSuite: NSNumber;

  readonly isCellular: boolean;

  readonly isExpensive: boolean;

  readonly isConstrained: boolean;

  readonly isMultipath: boolean;

  readonly domainResolutionProtocol: interop.Enum<typeof NSURLSessionTaskMetricsDomainResolutionProtocol>;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

declare class NSUnitLength extends NSDimension implements NSSecureCoding {
  static readonly megameters: NSUnitLength;

  static readonly kilometers: NSUnitLength;

  static readonly hectometers: NSUnitLength;

  static readonly decameters: NSUnitLength;

  static readonly meters: NSUnitLength;

  static readonly decimeters: NSUnitLength;

  static readonly centimeters: NSUnitLength;

  static readonly millimeters: NSUnitLength;

  static readonly micrometers: NSUnitLength;

  static readonly nanometers: NSUnitLength;

  static readonly picometers: NSUnitLength;

  static readonly inches: NSUnitLength;

  static readonly feet: NSUnitLength;

  static readonly yards: NSUnitLength;

  static readonly miles: NSUnitLength;

  static readonly scandinavianMiles: NSUnitLength;

  static readonly lightyears: NSUnitLength;

  static readonly nauticalMiles: NSUnitLength;

  static readonly fathoms: NSUnitLength;

  static readonly furlongs: NSUnitLength;

  static readonly astronomicalUnits: NSUnitLength;

  static readonly parsecs: NSUnitLength;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSHTTPCookie extends NSObject {
  initWithProperties(properties: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  static cookieWithProperties(properties: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSHTTPCookie;

  static requestHeaderFieldsWithCookies(cookies: NSArray<interop.Object> | Array<interop.Object>): NSDictionary;

  static cookiesWithResponseHeaderFieldsForURL(headerFields: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, URL: NSURL): NSArray;

  readonly properties: NSDictionary;

  readonly version: number;

  readonly name: string;

  readonly value: string;

  readonly expiresDate: NSDate;

  readonly isSessionOnly: boolean;

  readonly domain: string;

  readonly path: string;

  readonly isSecure: boolean;

  readonly isHTTPOnly: boolean;

  readonly comment: string;

  readonly commentURL: NSURL;

  readonly portList: NSArray;

  readonly sameSitePolicy: string;
}

// @ts-ignore
declare class NSMutableURLRequest extends NSURLRequest {
  // @ts-ignore
  URL: NSURL;

  // @ts-ignore
  cachePolicy: interop.Enum<typeof NSURLRequestCachePolicy>;

  // @ts-ignore
  timeoutInterval: number;

  // @ts-ignore
  mainDocumentURL: NSURL;

  // @ts-ignore
  networkServiceType: interop.Enum<typeof NSURLRequestNetworkServiceType>;

  // @ts-ignore
  allowsCellularAccess: boolean;

  // @ts-ignore
  allowsExpensiveNetworkAccess: boolean;

  // @ts-ignore
  allowsConstrainedNetworkAccess: boolean;

  // @ts-ignore
  assumesHTTP3Capable: boolean;

  // @ts-ignore
  attribution: interop.Enum<typeof NSURLRequestAttribution>;

  // @ts-ignore
  requiresDNSSECValidation: boolean;

  // @ts-ignore
  HTTPMethod: string;

  // @ts-ignore
  get allHTTPHeaderFields(): NSDictionary;
  // @ts-ignore
  set allHTTPHeaderFields(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  setValueForHTTPHeaderField(value: string | null, field: string): void;

  addValueForHTTPHeaderField(value: string, field: string): void;

  // @ts-ignore
  HTTPBody: NSData;

  // @ts-ignore
  HTTPBodyStream: NSInputStream;

  // @ts-ignore
  HTTPShouldHandleCookies: boolean;

  // @ts-ignore
  HTTPShouldUsePipelining: boolean;
}

declare class NSUnitSpeed extends NSDimension implements NSSecureCoding {
  static readonly metersPerSecond: NSUnitSpeed;

  static readonly kilometersPerHour: NSUnitSpeed;

  static readonly milesPerHour: NSUnitSpeed;

  static readonly knots: NSUnitSpeed;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSTermOfAddress extends NSObject implements NSCopying, NSSecureCoding {
  static neutral<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static feminine<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static masculine<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static localizedForLanguageIdentifierWithPronouns<This extends abstract new (...args: any) => any>(this: This, language: string, pronouns: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  readonly languageIdentifier: string;

  readonly pronouns: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSAssertionHandler extends NSObject {
  static readonly currentHandler: NSAssertionHandler;

  handleFailureInMethodObjectFileLineNumberDescription(selector: string, object: interop.Object, fileName: string, line: number, format: string | null): void;

  handleFailureInFunctionFileLineNumberDescription(functionName: string, fileName: string, line: number, format: string | null): void;
}

declare class NSBundleResourceRequest extends NSObject implements NSProgressReporting {
  initWithTags(tags: NSSet): this;

  initWithTagsBundle(tags: NSSet, bundle: NSBundle): this;

  loadingPriority: number;

  readonly tags: NSSet;

  readonly bundle: NSBundle;

  beginAccessingResourcesWithCompletionHandler(completionHandler: (p1: NSError) => void | null): void;

  conditionallyBeginAccessingResourcesWithCompletionHandler(completionHandler: (p1: boolean) => void): void;

  endAccessingResources(): void;

  readonly progress: NSProgress;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSFileCoordinator extends NSObject {
  static addFilePresenter(filePresenter: NSFilePresenter): void;

  static removeFilePresenter(filePresenter: NSFilePresenter): void;

  static readonly filePresenters: NSArray;

  initWithFilePresenter(filePresenterOrNil: NSFilePresenter | null): this;

  purposeIdentifier: string;

  coordinateAccessWithIntentsQueueByAccessor(intents: NSArray<interop.Object> | Array<interop.Object>, queue: NSOperationQueue, accessor: (p1: NSError) => void | null): void;

  coordinateReadingItemAtURLOptionsErrorByAccessor(url: NSURL, options: interop.Enum<typeof NSFileCoordinatorReadingOptions>, outError: interop.PointerConvertible, reader: (p1: NSURL) => void): void;

  coordinateWritingItemAtURLOptionsErrorByAccessor(url: NSURL, options: interop.Enum<typeof NSFileCoordinatorWritingOptions>, outError: interop.PointerConvertible, writer: (p1: NSURL) => void): void;

  coordinateReadingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor(readingURL: NSURL, readingOptions: interop.Enum<typeof NSFileCoordinatorReadingOptions>, writingURL: NSURL, writingOptions: interop.Enum<typeof NSFileCoordinatorWritingOptions>, outError: interop.PointerConvertible, readerWriter: (p1: NSURL, p2: NSURL) => void): void;

  coordinateWritingItemAtURLOptionsWritingItemAtURLOptionsErrorByAccessor(url1: NSURL, options1: interop.Enum<typeof NSFileCoordinatorWritingOptions>, url2: NSURL, options2: interop.Enum<typeof NSFileCoordinatorWritingOptions>, outError: interop.PointerConvertible, writer: (p1: NSURL, p2: NSURL) => void): void;

  prepareForReadingItemsAtURLsOptionsWritingItemsAtURLsOptionsErrorByAccessor(readingURLs: NSArray<interop.Object> | Array<interop.Object>, readingOptions: interop.Enum<typeof NSFileCoordinatorReadingOptions>, writingURLs: NSArray<interop.Object> | Array<interop.Object>, writingOptions: interop.Enum<typeof NSFileCoordinatorWritingOptions>, outError: interop.PointerConvertible, batchAccessor: (p1: () => void) => void): void;

  itemAtURLWillMoveToURL(oldURL: NSURL, newURL: NSURL): void;

  itemAtURLDidMoveToURL(oldURL: NSURL, newURL: NSURL): void;

  itemAtURLDidChangeUbiquityAttributes(url: NSURL, attributes: NSSet): void;

  cancel(): void;
}

declare class NSSecureUnarchiveFromDataTransformer extends NSValueTransformer {
  static readonly allowedTopLevelClasses: NSArray;
}

declare class NSURLSessionWebSocketMessage extends NSObject {
  initWithData(data: NSData): this;

  initWithString(string: string): this;

  readonly type: interop.Enum<typeof NSURLSessionWebSocketMessageType>;

  readonly data: NSData;

  readonly string: string;
}

declare class NSISO8601DateFormatter extends NSFormatter implements NSSecureCoding {
  timeZone: NSTimeZone;

  formatOptions: interop.Enum<typeof NSISO8601DateFormatOptions>;

  init(): this;

  stringFromDate(date: NSDate): string;

  dateFromString(string: string): NSDate;

  static stringFromDateTimeZoneFormatOptions(date: NSDate, timeZone: NSTimeZone, formatOptions: interop.Enum<typeof NSISO8601DateFormatOptions>): string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitAcceleration extends NSDimension implements NSSecureCoding {
  static readonly metersPerSecondSquared: NSUnitAcceleration;

  static readonly gravity: NSUnitAcceleration;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSPersonNameComponentsFormatter extends NSFormatter {
  style: interop.Enum<typeof NSPersonNameComponentsFormatterStyle>;

  isPhonetic: boolean;

  locale: NSLocale;

  static localizedStringFromPersonNameComponentsStyleOptions(components: NSPersonNameComponents, nameFormatStyle: interop.Enum<typeof NSPersonNameComponentsFormatterStyle>, nameOptions: interop.Enum<typeof NSPersonNameComponentsFormatterOptions>): string;

  stringFromPersonNameComponents(components: NSPersonNameComponents): string;

  annotatedStringFromPersonNameComponents(components: NSPersonNameComponents): NSAttributedString;

  personNameComponentsFromString(string: string): NSPersonNameComponents;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;
}

declare class NSFileHandle extends NSObject implements NSSecureCoding {
  readonly availableData: NSData;

  initWithFileDescriptorCloseOnDealloc(fd: number, closeopt: boolean): this;

  initWithCoder(coder: NSCoder): this;

  readDataToEndOfFileAndReturnError(error: interop.PointerConvertible): NSData;

  readDataUpToLengthError(length: number, error: interop.PointerConvertible): NSData;

  writeDataError(data: NSData, error: interop.PointerConvertible): boolean;

  getOffsetError(offsetInFile: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  seekToEndReturningOffsetError(offsetInFile: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  seekToOffsetError(offset: number, error: interop.PointerConvertible): boolean;

  truncateAtOffsetError(offset: number, error: interop.PointerConvertible): boolean;

  synchronizeAndReturnError(error: interop.PointerConvertible): boolean;

  closeAndReturnError(error: interop.PointerConvertible): boolean;

  static readonly fileHandleWithStandardInput: NSFileHandle;

  static readonly fileHandleWithStandardOutput: NSFileHandle;

  static readonly fileHandleWithStandardError: NSFileHandle;

  static readonly fileHandleWithNullDevice: NSFileHandle;

  static fileHandleForReadingAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static fileHandleForWritingAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static fileHandleForUpdatingAtPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  static fileHandleForReadingFromURLError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, error: interop.PointerConvertible): InstanceType<This>;

  static fileHandleForWritingToURLError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, error: interop.PointerConvertible): InstanceType<This>;

  static fileHandleForUpdatingURLError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, error: interop.PointerConvertible): InstanceType<This>;

  readInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  readInBackgroundAndNotify(): void;

  readToEndOfFileInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  readToEndOfFileInBackgroundAndNotify(): void;

  acceptConnectionInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  acceptConnectionInBackgroundAndNotify(): void;

  waitForDataInBackgroundAndNotifyForModes(modes: NSArray<interop.Object> | Array<interop.Object> | null): void;

  waitForDataInBackgroundAndNotify(): void;

  readabilityHandler: (p1: NSFileHandle) => void;

  writeabilityHandler: (p1: NSFileHandle) => void;

  initWithFileDescriptor(fd: number): this;

  readonly fileDescriptor: number;

  readDataToEndOfFile(): NSData;

  readDataOfLength(length: number): NSData;

  writeData(data: NSData): void;

  readonly offsetInFile: number;

  seekToEndOfFile(): number;

  seekToFileOffset(offset: number): void;

  truncateFileAtOffset(offset: number): void;

  synchronizeFile(): void;

  closeFile(): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSEnergyFormatter extends NSFormatter {
  numberFormatter: NSNumberFormatter;

  unitStyle: interop.Enum<typeof NSFormattingUnitStyle>;

  isForFoodEnergyUse: boolean;

  stringFromValueUnit(value: number, unit: interop.Enum<typeof NSEnergyFormatterUnit>): string;

  stringFromJoules(numberInJoules: number): string;

  unitStringFromValueUnit(value: number, unit: interop.Enum<typeof NSEnergyFormatterUnit>): string;

  unitStringFromJoulesUsedUnit(numberInJoules: number, unitp: interop.PointerConvertible): string;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;
}

declare class NSUUID extends NSObject implements NSCopying, NSSecureCoding {
  static UUID<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  init(): this;

  initWithUUIDString(string: string): this;

  initWithUUIDBytes(bytes: interop.PointerConvertible): this;

  getUUIDBytes(uuid: interop.PointerConvertible): void;

  compare(otherUUID: NSUUID): interop.Enum<typeof NSComparisonResult>;

  readonly UUIDString: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSProxy extends NativeObject implements NSObjectProtocol {
  static alloc<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static allocWithZone(zone: interop.PointerConvertible): interop.Object;

  static class(): interop.Object;

  forwardInvocation(invocation: NSInvocation): void;

  methodSignatureForSelector(sel: string): NSMethodSignature;

  dealloc(): void;

  finalize(): void;

  readonly description: string;

  readonly debugDescription: string;

  static respondsToSelector(aSelector: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;
}

declare class NSUserActivity extends NSObject {
  initWithActivityType(activityType: string): this;

  init(): this;

  readonly activityType: string;

  title: string;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  addUserInfoEntriesFromDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  requiredUserInfoKeys: NSSet;

  needsSave: boolean;

  webpageURL: NSURL;

  referrerURL: NSURL;

  expirationDate: NSDate;

  keywords: NSSet;

  supportsContinuationStreams: boolean;

  delegate: NSUserActivityDelegate;

  targetContentIdentifier: string;

  becomeCurrent(): void;

  resignCurrent(): void;

  invalidate(): void;

  getContinuationStreamsWithCompletionHandler(completionHandler: (p1: NSInputStream, p2: NSOutputStream, p3: NSError) => void | null): void;

  isEligibleForHandoff: boolean;

  isEligibleForSearch: boolean;

  isEligibleForPublicIndexing: boolean;

  isEligibleForPrediction: boolean;

  persistentIdentifier: string;

  static deleteSavedUserActivitiesWithPersistentIdentifiersCompletionHandler(persistentIdentifiers: NSArray<interop.Object> | Array<interop.Object>, handler: () => void): void;

  static deleteAllSavedUserActivitiesWithCompletionHandler(handler: () => void): void;

  readonly detectedBarcodeDescriptor: CIBarcodeDescriptor;

  contentAttributeSet: CSSearchableItemAttributeSet;

  readonly interaction: INInteraction;

  suggestedInvocationPhrase: string;

  shortcutAvailability: interop.Enum<typeof INShortcutAvailabilityOptions>;

  mapItem: MKMapItem;
}

declare class NSString extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  readonly length: number;

  characterAtIndex(index: number): number;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  substringFromIndex(from: number): string;

  substringToIndex(to: number): string;

  substringWithRange(range: _NSRange): string;

  getCharactersRange(buffer: interop.PointerConvertible, range: _NSRange): void;

  compare(string: string): interop.Enum<typeof NSComparisonResult>;

  compareOptions(string: string, mask: interop.Enum<typeof NSStringCompareOptions>): interop.Enum<typeof NSComparisonResult>;

  compareOptionsRange(string: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToCompare: _NSRange): interop.Enum<typeof NSComparisonResult>;

  compareOptionsRangeLocale(string: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToCompare: _NSRange, locale: interop.Object | null): interop.Enum<typeof NSComparisonResult>;

  caseInsensitiveCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  localizedCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  localizedCaseInsensitiveCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  localizedStandardCompare(string: string): interop.Enum<typeof NSComparisonResult>;

  isEqualToString(aString: string): boolean;

  hasPrefix(str: string): boolean;

  hasSuffix(str: string): boolean;

  commonPrefixWithStringOptions(str: string, mask: interop.Enum<typeof NSStringCompareOptions>): string;

  containsString(str: string): boolean;

  localizedCaseInsensitiveContainsString(str: string): boolean;

  localizedStandardContainsString(str: string): boolean;

  localizedStandardRangeOfString(str: string): _NSRange;

  rangeOfString(searchString: string): _NSRange;

  rangeOfStringOptions(searchString: string, mask: interop.Enum<typeof NSStringCompareOptions>): _NSRange;

  rangeOfStringOptionsRange(searchString: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToSearch: _NSRange): _NSRange;

  rangeOfStringOptionsRangeLocale(searchString: string, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToSearch: _NSRange, locale: NSLocale | null): _NSRange;

  rangeOfCharacterFromSet(searchSet: NSCharacterSet): _NSRange;

  rangeOfCharacterFromSetOptions(searchSet: NSCharacterSet, mask: interop.Enum<typeof NSStringCompareOptions>): _NSRange;

  rangeOfCharacterFromSetOptionsRange(searchSet: NSCharacterSet, mask: interop.Enum<typeof NSStringCompareOptions>, rangeOfReceiverToSearch: _NSRange): _NSRange;

  rangeOfComposedCharacterSequenceAtIndex(index: number): _NSRange;

  rangeOfComposedCharacterSequencesForRange(range: _NSRange): _NSRange;

  stringByAppendingString(aString: string): string;

  stringByAppendingFormat(format: string): string;

  readonly doubleValue: number;

  readonly floatValue: number;

  readonly intValue: number;

  readonly integerValue: number;

  readonly longLongValue: number;

  readonly boolValue: boolean;

  readonly uppercaseString: string;

  readonly lowercaseString: string;

  readonly capitalizedString: string;

  readonly localizedUppercaseString: string;

  readonly localizedLowercaseString: string;

  readonly localizedCapitalizedString: string;

  uppercaseStringWithLocale(locale: NSLocale | null): string;

  lowercaseStringWithLocale(locale: NSLocale | null): string;

  capitalizedStringWithLocale(locale: NSLocale | null): string;

  getLineStartEndContentsEndForRange(startPtr: interop.PointerConvertible, lineEndPtr: interop.PointerConvertible, contentsEndPtr: interop.PointerConvertible, range: _NSRange): void;

  lineRangeForRange(range: _NSRange): _NSRange;

  getParagraphStartEndContentsEndForRange(startPtr: interop.PointerConvertible, parEndPtr: interop.PointerConvertible, contentsEndPtr: interop.PointerConvertible, range: _NSRange): void;

  paragraphRangeForRange(range: _NSRange): _NSRange;

  enumerateSubstringsInRangeOptionsUsingBlock(range: _NSRange, opts: interop.Enum<typeof NSStringEnumerationOptions>, block: (p1: string, p2: _NSRange, p3: _NSRange, p4: interop.PointerConvertible) => void | null): void;

  enumerateLinesUsingBlock(block: (p1: string, p2: interop.PointerConvertible) => void): void;

  readonly UTF8String: string;

  readonly fastestEncoding: number;

  readonly smallestEncoding: number;

  dataUsingEncodingAllowLossyConversion(encoding: number, lossy: boolean): NSData;

  dataUsingEncoding(encoding: number): NSData;

  canBeConvertedToEncoding(encoding: number): boolean;

  cStringUsingEncoding(encoding: number): string;

  getCStringMaxLengthEncoding(buffer: string, maxBufferCount: number, encoding: number): boolean;

  getBytesMaxLengthUsedLengthEncodingOptionsRangeRemainingRange(buffer: interop.PointerConvertible, maxBufferCount: number, usedBufferCount: interop.PointerConvertible, encoding: number, options: interop.Enum<typeof NSStringEncodingConversionOptions>, range: _NSRange, leftover: interop.PointerConvertible): boolean;

  maximumLengthOfBytesUsingEncoding(enc: number): number;

  lengthOfBytesUsingEncoding(enc: number): number;

  static readonly availableStringEncodings: interop.Pointer;

  static localizedNameOfStringEncoding(encoding: number): string;

  static readonly defaultCStringEncoding: number;

  readonly decomposedStringWithCanonicalMapping: string;

  readonly precomposedStringWithCanonicalMapping: string;

  readonly decomposedStringWithCompatibilityMapping: string;

  readonly precomposedStringWithCompatibilityMapping: string;

  componentsSeparatedByString(separator: string): NSArray;

  componentsSeparatedByCharactersInSet(separator: NSCharacterSet): NSArray;

  stringByTrimmingCharactersInSet(set: NSCharacterSet): string;

  stringByPaddingToLengthWithStringStartingAtIndex(newLength: number, padString: string, padIndex: number): string;

  stringByFoldingWithOptionsLocale(options: interop.Enum<typeof NSStringCompareOptions>, locale: NSLocale | null): string;

  stringByReplacingOccurrencesOfStringWithStringOptionsRange(target: string, replacement: string, options: interop.Enum<typeof NSStringCompareOptions>, searchRange: _NSRange): string;

  stringByReplacingOccurrencesOfStringWithString(target: string, replacement: string): string;

  stringByReplacingCharactersInRangeWithString(range: _NSRange, replacement: string): string;

  stringByApplyingTransformReverse(transform: string, reverse: boolean): string;

  writeToURLAtomicallyEncodingError(url: NSURL, useAuxiliaryFile: boolean, enc: number, error: interop.PointerConvertible): boolean;

  writeToFileAtomicallyEncodingError(path: string, useAuxiliaryFile: boolean, enc: number, error: interop.PointerConvertible): boolean;

  readonly description: string;

  readonly hash: number;

  initWithCharactersNoCopyLengthFreeWhenDone(characters: interop.PointerConvertible, length: number, freeBuffer: boolean): this;

  initWithCharactersNoCopyLengthDeallocator(chars: interop.PointerConvertible, len: number, deallocator: (p1: interop.PointerConvertible, p2: number) => void | null): this;

  initWithCharactersLength(characters: interop.PointerConvertible, length: number): this;

  initWithUTF8String(nullTerminatedCString: string): this;

  initWithString(aString: string): this;

  initWithFormat(format: string): this;

  initWithFormatArguments(format: string, argList: string): this;

  initWithFormatLocale(format: string, locale: interop.Object | null): this;

  initWithFormatLocaleArguments(format: string, locale: interop.Object | null, argList: string): this;

  initWithValidatedFormatValidFormatSpecifiersError(format: string, validFormatSpecifiers: string, error: interop.PointerConvertible): this;

  initWithValidatedFormatValidFormatSpecifiersLocaleError(format: string, validFormatSpecifiers: string, locale: interop.Object | null, error: interop.PointerConvertible): this;

  initWithValidatedFormatValidFormatSpecifiersArgumentsError(format: string, validFormatSpecifiers: string, argList: string, error: interop.PointerConvertible): this;

  initWithValidatedFormatValidFormatSpecifiersLocaleArgumentsError(format: string, validFormatSpecifiers: string, locale: interop.Object | null, argList: string, error: interop.PointerConvertible): this;

  initWithDataEncoding(data: NSData, encoding: number): this;

  initWithBytesLengthEncoding(bytes: interop.PointerConvertible, len: number, encoding: number): this;

  initWithBytesNoCopyLengthEncodingFreeWhenDone(bytes: interop.PointerConvertible, len: number, encoding: number, freeBuffer: boolean): this;

  initWithBytesNoCopyLengthEncodingDeallocator(bytes: interop.PointerConvertible, len: number, encoding: number, deallocator: (p1: interop.PointerConvertible, p2: number) => void | null): this;

  static string<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static stringWithString<This extends abstract new (...args: any) => any>(this: This, string: string): InstanceType<This>;

  static stringWithCharactersLength<This extends abstract new (...args: any) => any>(this: This, characters: interop.PointerConvertible, length: number): InstanceType<This>;

  static stringWithUTF8String<This extends abstract new (...args: any) => any>(this: This, nullTerminatedCString: string): InstanceType<This>;

  static stringWithFormat<This extends abstract new (...args: any) => any>(this: This, format: string): InstanceType<This>;

  static localizedStringWithFormat<This extends abstract new (...args: any) => any>(this: This, format: string): InstanceType<This>;

  static stringWithValidatedFormatValidFormatSpecifiersError<This extends abstract new (...args: any) => any>(this: This, format: string, validFormatSpecifiers: string, error: interop.PointerConvertible): InstanceType<This>;

  static localizedStringWithValidatedFormatValidFormatSpecifiersError<This extends abstract new (...args: any) => any>(this: This, format: string, validFormatSpecifiers: string, error: interop.PointerConvertible): InstanceType<This>;

  initWithCStringEncoding(nullTerminatedCString: string, encoding: number): this;

  static stringWithCStringEncoding<This extends abstract new (...args: any) => any>(this: This, cString: string, enc: number): InstanceType<This>;

  initWithContentsOfURLEncodingError(url: NSURL, enc: number, error: interop.PointerConvertible): this;

  initWithContentsOfFileEncodingError(path: string, enc: number, error: interop.PointerConvertible): this;

  static stringWithContentsOfURLEncodingError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, enc: number, error: interop.PointerConvertible): InstanceType<This>;

  static stringWithContentsOfFileEncodingError<This extends abstract new (...args: any) => any>(this: This, path: string, enc: number, error: interop.PointerConvertible): InstanceType<This>;

  initWithContentsOfURLUsedEncodingError(url: NSURL, enc: interop.PointerConvertible, error: interop.PointerConvertible): this;

  initWithContentsOfFileUsedEncodingError(path: string, enc: interop.PointerConvertible, error: interop.PointerConvertible): this;

  static stringWithContentsOfURLUsedEncodingError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, enc: interop.PointerConvertible, error: interop.PointerConvertible): InstanceType<This>;

  static stringWithContentsOfFileUsedEncodingError<This extends abstract new (...args: any) => any>(this: This, path: string, enc: interop.PointerConvertible, error: interop.PointerConvertible): InstanceType<This>;

  static stringEncodingForDataEncodingOptionsConvertedStringUsedLossyConversion(data: NSData, opts: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, string: interop.PointerConvertible, usedLossyConversion: interop.PointerConvertible): number;

  propertyList(): interop.Object;

  propertyListFromStringsFileFormat(): NSDictionary;

  cString(): string;

  lossyCString(): string;

  cStringLength(): number;

  getCString(bytes: string): void;

  getCStringMaxLength(bytes: string, maxLength: number): void;

  getCStringMaxLengthRangeRemainingRange(bytes: string, maxLength: number, aRange: _NSRange, leftoverRange: interop.PointerConvertible): void;

  writeToFileAtomically(path: string, useAuxiliaryFile: boolean): boolean;

  writeToURLAtomically(url: NSURL, atomically: boolean): boolean;

  initWithContentsOfFile(path: string): interop.Object;

  initWithContentsOfURL(url: NSURL): interop.Object;

  static stringWithContentsOfFile(path: string): interop.Object;

  static stringWithContentsOfURL(url: NSURL): interop.Object;

  initWithCStringNoCopyLengthFreeWhenDone(bytes: string, length: number, freeBuffer: boolean): interop.Object;

  initWithCStringLength(bytes: string, length: number): interop.Object;

  initWithCString(bytes: string): interop.Object;

  static stringWithCStringLength(bytes: string, length: number): interop.Object;

  static stringWithCString(bytes: string): interop.Object;

  getCharacters(buffer: interop.PointerConvertible): void;

  variantFittingPresentationWidth(width: number): string;

  static pathWithComponents(components: NSArray<interop.Object> | Array<interop.Object>): string;

  readonly pathComponents: NSArray;

  readonly isAbsolutePath: boolean;

  readonly lastPathComponent: string;

  readonly stringByDeletingLastPathComponent: string;

  stringByAppendingPathComponent(str: string): string;

  readonly pathExtension: string;

  readonly stringByDeletingPathExtension: string;

  stringByAppendingPathExtension(str: string): string;

  readonly stringByAbbreviatingWithTildeInPath: string;

  readonly stringByExpandingTildeInPath: string;

  readonly stringByStandardizingPath: string;

  readonly stringByResolvingSymlinksInPath: string;

  stringsByAppendingPaths(paths: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  completePathIntoStringCaseSensitiveMatchesIntoArrayFilterTypes(outputName: interop.PointerConvertible, flag: boolean, outputArray: interop.PointerConvertible, filterTypes: NSArray<interop.Object> | Array<interop.Object> | null): number;

  readonly fileSystemRepresentation: string;

  getFileSystemRepresentationMaxLength(cname: string, max: number): boolean;

  stringByAddingPercentEncodingWithAllowedCharacters(allowedCharacters: NSCharacterSet): string;

  readonly stringByRemovingPercentEncoding: string;

  stringByAddingPercentEscapesUsingEncoding(enc: number): string;

  stringByReplacingPercentEscapesUsingEncoding(enc: number): string;

  linguisticTagsInRangeSchemeOptionsOrthographyTokenRanges(range: _NSRange, scheme: string, options: interop.Enum<typeof NSLinguisticTaggerOptions>, orthography: NSOrthography | null, tokenRanges: interop.PointerConvertible): NSArray;

  enumerateLinguisticTagsInRangeSchemeOptionsOrthographyUsingBlock(range: _NSRange, scheme: string, options: interop.Enum<typeof NSLinguisticTaggerOptions>, orthography: NSOrthography | null, block: (p1: string, p2: _NSRange, p3: _NSRange, p4: interop.PointerConvertible) => void | null): void;

  sizeWithFont(font: UIFont): CGSize;

  sizeWithFontForWidthLineBreakMode(font: UIFont, width: number, lineBreakMode: interop.Enum<typeof NSLineBreakMode>): CGSize;

  drawAtPointWithFont(point: CGPoint, font: UIFont): CGSize;

  drawAtPointForWidthWithFontLineBreakMode(point: CGPoint, width: number, font: UIFont, lineBreakMode: interop.Enum<typeof NSLineBreakMode>): CGSize;

  sizeWithFontConstrainedToSize(font: UIFont, size: CGSize): CGSize;

  sizeWithFontConstrainedToSizeLineBreakMode(font: UIFont, size: CGSize, lineBreakMode: interop.Enum<typeof NSLineBreakMode>): CGSize;

  drawInRectWithFont(rect: CGRect, font: UIFont): CGSize;

  drawInRectWithFontLineBreakMode(rect: CGRect, font: UIFont, lineBreakMode: interop.Enum<typeof NSLineBreakMode>): CGSize;

  drawInRectWithFontLineBreakModeAlignment(rect: CGRect, font: UIFont, lineBreakMode: interop.Enum<typeof NSLineBreakMode>, alignment: interop.Enum<typeof NSTextAlignment>): CGSize;

  sizeWithFontMinFontSizeActualFontSizeForWidthLineBreakMode(font: UIFont, minFontSize: number, actualFontSize: interop.PointerConvertible, width: number, lineBreakMode: interop.Enum<typeof NSLineBreakMode>): CGSize;

  drawAtPointForWidthWithFontFontSizeLineBreakModeBaselineAdjustment(point: CGPoint, width: number, font: UIFont, fontSize: number, lineBreakMode: interop.Enum<typeof NSLineBreakMode>, baselineAdjustment: interop.Enum<typeof UIBaselineAdjustment>): CGSize;

  drawAtPointForWidthWithFontMinFontSizeActualFontSizeLineBreakModeBaselineAdjustment(point: CGPoint, width: number, font: UIFont, minFontSize: number, actualFontSize: interop.PointerConvertible, lineBreakMode: interop.Enum<typeof NSLineBreakMode>, baselineAdjustment: interop.Enum<typeof UIBaselineAdjustment>): CGSize;

  sizeWithAttributes(attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): CGSize;

  drawAtPointWithAttributes(point: CGPoint, attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  drawInRectWithAttributes(rect: CGRect, attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  drawWithRectOptionsAttributesContext(rect: CGRect, options: interop.Enum<typeof NSStringDrawingOptions>, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, context: NSStringDrawingContext | null): void;

  boundingRectWithSizeOptionsAttributesContext(size: CGSize, options: interop.Enum<typeof NSStringDrawingOptions>, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, context: NSStringDrawingContext | null): CGRect;

  static deferredLocalizedIntentsStringWithFormat(format: string): string;

  static deferredLocalizedIntentsStringWithFormatFromTable(format: string, table: string | null): string;

  static deferredLocalizedIntentsStringWithFormatFromTableArguments(format: string, table: string | null, arguments$: string): string;

  static localizedUserNotificationStringForKeyArguments(key: string, arguments$: NSArray<interop.Object> | Array<interop.Object> | null): string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSURLSessionTaskMetrics extends NSObject {
  readonly transactionMetrics: NSArray;

  readonly taskInterval: NSDateInterval;

  readonly redirectCount: number;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

declare class NSIndexSet extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  static indexSet<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static indexSetWithIndex<This extends abstract new (...args: any) => any>(this: This, value: number): InstanceType<This>;

  static indexSetWithIndexesInRange<This extends abstract new (...args: any) => any>(this: This, range: _NSRange): InstanceType<This>;

  initWithIndexesInRange(range: _NSRange): this;

  initWithIndexSet(indexSet: NSIndexSet): this;

  initWithIndex(value: number): this;

  isEqualToIndexSet(indexSet: NSIndexSet): boolean;

  readonly count: number;

  readonly firstIndex: number;

  readonly lastIndex: number;

  indexGreaterThanIndex(value: number): number;

  indexLessThanIndex(value: number): number;

  indexGreaterThanOrEqualToIndex(value: number): number;

  indexLessThanOrEqualToIndex(value: number): number;

  getIndexesMaxCountInIndexRange(indexBuffer: interop.PointerConvertible, bufferSize: number, range: interop.PointerConvertible): number;

  countOfIndexesInRange(range: _NSRange): number;

  containsIndex(value: number): boolean;

  containsIndexesInRange(range: _NSRange): boolean;

  containsIndexes(indexSet: NSIndexSet): boolean;

  intersectsIndexesInRange(range: _NSRange): boolean;

  enumerateIndexesUsingBlock(block: (p1: number, p2: interop.PointerConvertible) => void): void;

  enumerateIndexesWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: number, p2: interop.PointerConvertible) => void): void;

  enumerateIndexesInRangeOptionsUsingBlock(range: _NSRange, opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: number, p2: interop.PointerConvertible) => void): void;

  indexPassingTest(predicate: (p1: number, p2: interop.PointerConvertible) => boolean): number;

  indexWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: number, p2: interop.PointerConvertible) => boolean): number;

  indexInRangeOptionsPassingTest(range: _NSRange, opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: number, p2: interop.PointerConvertible) => boolean): number;

  indexesPassingTest(predicate: (p1: number, p2: interop.PointerConvertible) => boolean): NSIndexSet;

  indexesWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: number, p2: interop.PointerConvertible) => boolean): NSIndexSet;

  indexesInRangeOptionsPassingTest(range: _NSRange, opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: number, p2: interop.PointerConvertible) => boolean): NSIndexSet;

  enumerateRangesUsingBlock(block: (p1: _NSRange, p2: interop.PointerConvertible) => void): void;

  enumerateRangesWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: _NSRange, p2: interop.PointerConvertible) => void): void;

  enumerateRangesInRangeOptionsUsingBlock(range: _NSRange, opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: _NSRange, p2: interop.PointerConvertible) => void): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSXPCListener extends NSObject {
  static serviceListener(): NSXPCListener;

  static anonymousListener(): NSXPCListener;

  delegate: NSXPCListenerDelegate;

  readonly endpoint: NSXPCListenerEndpoint;

  resume(): void;

  suspend(): void;

  activate(): void;

  invalidate(): void;
}

declare class NSURLSessionWebSocketTask extends NSURLSessionTask {
  sendMessageCompletionHandler(message: NSURLSessionWebSocketMessage, completionHandler: (p1: NSError) => void | null): void;

  receiveMessageWithCompletionHandler(completionHandler: (p1: NSURLSessionWebSocketMessage, p2: NSError) => void | null): void;

  sendPingWithPongReceiveHandler(pongReceiveHandler: (p1: NSError) => void | null): void;

  cancelWithCloseCodeReason(closeCode: interop.Enum<typeof NSURLSessionWebSocketCloseCode>, reason: NSData | null): void;

  maximumMessageSize: number;

  readonly closeCode: interop.Enum<typeof NSURLSessionWebSocketCloseCode>;

  readonly closeReason: NSData;
}

declare class NSURLSessionDownloadTask extends NSURLSessionTask {
  cancelByProducingResumeData(completionHandler: (p1: NSData) => void | null): void;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

declare class NSLocale extends NSObject implements NSCopying, NSSecureCoding {
  objectForKey(key: string): interop.Object;

  displayNameForKeyValue(key: string, value: interop.Object): string;

  initWithLocaleIdentifier(string: string): this;

  initWithCoder(coder: NSCoder): this;

  readonly localeIdentifier: string;

  localizedStringForLocaleIdentifier(localeIdentifier: string): string;

  readonly languageCode: string;

  localizedStringForLanguageCode(languageCode: string): string;

  readonly languageIdentifier: string;

  readonly countryCode: string;

  localizedStringForCountryCode(countryCode: string): string;

  readonly regionCode: string;

  readonly scriptCode: string;

  localizedStringForScriptCode(scriptCode: string): string;

  readonly variantCode: string;

  localizedStringForVariantCode(variantCode: string): string;

  readonly exemplarCharacterSet: NSCharacterSet;

  readonly calendarIdentifier: string;

  localizedStringForCalendarIdentifier(calendarIdentifier: string): string;

  readonly collationIdentifier: string;

  localizedStringForCollationIdentifier(collationIdentifier: string): string;

  readonly usesMetricSystem: boolean;

  readonly decimalSeparator: string;

  readonly groupingSeparator: string;

  readonly currencySymbol: string;

  readonly currencyCode: string;

  localizedStringForCurrencyCode(currencyCode: string): string;

  readonly collatorIdentifier: string;

  localizedStringForCollatorIdentifier(collatorIdentifier: string): string;

  readonly quotationBeginDelimiter: string;

  readonly quotationEndDelimiter: string;

  readonly alternateQuotationBeginDelimiter: string;

  readonly alternateQuotationEndDelimiter: string;

  static readonly autoupdatingCurrentLocale: NSLocale;

  static readonly currentLocale: NSLocale;

  static readonly systemLocale: NSLocale;

  static localeWithLocaleIdentifier<This extends abstract new (...args: any) => any>(this: This, ident: string): InstanceType<This>;

  static readonly availableLocaleIdentifiers: NSArray;

  static readonly ISOLanguageCodes: NSArray;

  static readonly ISOCountryCodes: NSArray;

  static readonly ISOCurrencyCodes: NSArray;

  static readonly commonISOCurrencyCodes: NSArray;

  static readonly preferredLanguages: NSArray;

  static componentsFromLocaleIdentifier(string: string): NSDictionary;

  static localeIdentifierFromComponents(dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): string;

  static canonicalLocaleIdentifierFromString(string: string): string;

  static canonicalLanguageIdentifierFromString(string: string): string;

  static localeIdentifierFromWindowsLocaleCode(lcid: number): string;

  static windowsLocaleCodeFromLocaleIdentifier(localeIdentifier: string): number;

  static characterDirectionForLanguage(isoLangCode: string): interop.Enum<typeof NSLocaleLanguageDirection>;

  static lineDirectionForLanguage(isoLangCode: string): interop.Enum<typeof NSLocaleLanguageDirection>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSMetadataQuery extends NSObject {
  delegate: NSMetadataQueryDelegate;

  predicate: NSPredicate;

  get sortDescriptors(): NSArray;
  set sortDescriptors(value: NSArray<interop.Object> | Array<interop.Object>);

  get valueListAttributes(): NSArray;
  set valueListAttributes(value: NSArray<interop.Object> | Array<interop.Object>);

  get groupingAttributes(): NSArray;
  set groupingAttributes(value: NSArray<interop.Object> | Array<interop.Object>);

  notificationBatchingInterval: number;

  get searchScopes(): NSArray;
  set searchScopes(value: NSArray<interop.Object> | Array<interop.Object>);

  get searchItems(): NSArray;
  set searchItems(value: NSArray<interop.Object> | Array<interop.Object>);

  operationQueue: NSOperationQueue;

  startQuery(): boolean;

  stopQuery(): void;

  readonly isStarted: boolean;

  readonly isGathering: boolean;

  readonly isStopped: boolean;

  disableUpdates(): void;

  enableUpdates(): void;

  readonly resultCount: number;

  resultAtIndex(idx: number): interop.Object;

  enumerateResultsUsingBlock(block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  enumerateResultsWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  readonly results: NSArray;

  indexOfResult(result: interop.Object): number;

  readonly valueLists: NSDictionary;

  readonly groupedResults: NSArray;

  valueOfAttributeForResultAtIndex(attrName: string, idx: number): interop.Object;
}

declare class NSMetadataQueryAttributeValueTuple extends NSObject {
  readonly attribute: string;

  readonly value: interop.Object;

  readonly count: number;
}

declare class NSBlockOperation extends NSOperation {
  static blockOperationWithBlock<This extends abstract new (...args: any) => any>(this: This, block: () => void): InstanceType<This>;

  addExecutionBlock(block: () => void): void;

  readonly executionBlocks: NSArray;
}

declare class NSCompoundPredicate extends NSPredicate {
  initWithTypeSubpredicates(type: interop.Enum<typeof NSCompoundPredicateType>, subpredicates: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithCoder(coder: NSCoder): this;

  readonly compoundPredicateType: interop.Enum<typeof NSCompoundPredicateType>;

  readonly subpredicates: NSArray;

  static andPredicateWithSubpredicates(subpredicates: NSArray<interop.Object> | Array<interop.Object>): NSCompoundPredicate;

  static orPredicateWithSubpredicates(subpredicates: NSArray<interop.Object> | Array<interop.Object>): NSCompoundPredicate;

  static notPredicateWithSubpredicate(predicate: NSPredicate): NSCompoundPredicate;
}

declare class NSRunLoop extends NSObject {
  static readonly currentRunLoop: NSRunLoop;

  static readonly mainRunLoop: NSRunLoop;

  readonly currentMode: string;

  getCFRunLoop(): interop.Pointer;

  addTimerForMode(timer: NSTimer, mode: string): void;

  addPortForMode(aPort: NSPort, mode: string): void;

  removePortForMode(aPort: NSPort, mode: string): void;

  limitDateForMode(mode: string): NSDate;

  acceptInputForModeBeforeDate(mode: string, limitDate: NSDate): void;

  run(): void;

  runUntilDate(limitDate: NSDate): void;

  runModeBeforeDate(mode: string, limitDate: NSDate): boolean;

  performInModesBlock(modes: NSArray<interop.Object> | Array<interop.Object>, block: () => void): void;

  performBlock(block: () => void): void;

  performSelectorTargetArgumentOrderModes(aSelector: string, target: interop.Object, arg: interop.Object | null, order: number, modes: NSArray<interop.Object> | Array<interop.Object>): void;

  cancelPerformSelectorTargetArgument(aSelector: string, target: interop.Object, arg: interop.Object | null): void;

  cancelPerformSelectorsWithTarget(target: interop.Object): void;
}

declare class NSHTTPURLResponse extends NSURLResponse {
  initWithURLStatusCodeHTTPVersionHeaderFields(url: NSURL, statusCode: number, HTTPVersion: string | null, headerFields: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  readonly statusCode: number;

  readonly allHeaderFields: NSDictionary;

  valueForHTTPHeaderField(field: string): string;

  static localizedStringForStatusCode(statusCode: number): string;
}

declare class NSCache<KeyType = interop.Object, ObjectType = interop.Object> extends NSObject {
  name: string;

  delegate: NSCacheDelegate;

  objectForKey(key: KeyType): ObjectType;

  setObjectForKey(obj: ObjectType, key: KeyType): void;

  setObjectForKeyCost(obj: ObjectType, key: KeyType, g: number): void;

  removeObjectForKey(key: KeyType): void;

  removeAllObjects(): void;

  totalCostLimit: number;

  countLimit: number;

  evictsObjectsWithDiscardedContent: boolean;
}

declare class NSFileWrapper extends NSObject implements NSSecureCoding {
  initWithURLOptionsError(url: NSURL, options: interop.Enum<typeof NSFileWrapperReadingOptions>, outError: interop.PointerConvertible): this;

  initDirectoryWithFileWrappers(childrenByPreferredName: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  initRegularFileWithContents(contents: NSData): this;

  initSymbolicLinkWithDestinationURL(url: NSURL): this;

  initWithSerializedRepresentation(serializeRepresentation: NSData): this;

  initWithCoder(inCoder: NSCoder): this;

  readonly isDirectory: boolean;

  readonly isRegularFile: boolean;

  readonly isSymbolicLink: boolean;

  preferredFilename: string;

  filename: string;

  get fileAttributes(): NSDictionary;
  set fileAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  matchesContentsOfURL(url: NSURL): boolean;

  readFromURLOptionsError(url: NSURL, options: interop.Enum<typeof NSFileWrapperReadingOptions>, outError: interop.PointerConvertible): boolean;

  writeToURLOptionsOriginalContentsURLError(url: NSURL, options: interop.Enum<typeof NSFileWrapperWritingOptions>, originalContentsURL: NSURL | null, outError: interop.PointerConvertible): boolean;

  readonly serializedRepresentation: NSData;

  addFileWrapper(child: NSFileWrapper): string;

  addRegularFileWithContentsPreferredFilename(data: NSData, fileName: string): string;

  removeFileWrapper(child: NSFileWrapper): void;

  readonly fileWrappers: NSDictionary;

  keyForFileWrapper(child: NSFileWrapper): string;

  readonly regularFileContents: NSData;

  readonly symbolicLinkDestinationURL: NSURL;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSURLRequest extends NSObject implements NSSecureCoding, NSCopying, NSMutableCopying {
  static requestWithURL<This extends abstract new (...args: any) => any>(this: This, URL: NSURL): InstanceType<This>;

  static readonly supportsSecureCoding: boolean;

  static requestWithURLCachePolicyTimeoutInterval<This extends abstract new (...args: any) => any>(this: This, URL: NSURL, cachePolicy: interop.Enum<typeof NSURLRequestCachePolicy>, timeoutInterval: number): InstanceType<This>;

  initWithURL(URL: NSURL): this;

  initWithURLCachePolicyTimeoutInterval(URL: NSURL, cachePolicy: interop.Enum<typeof NSURLRequestCachePolicy>, timeoutInterval: number): this;

  readonly URL: NSURL;

  readonly cachePolicy: interop.Enum<typeof NSURLRequestCachePolicy>;

  readonly timeoutInterval: number;

  readonly mainDocumentURL: NSURL;

  readonly networkServiceType: interop.Enum<typeof NSURLRequestNetworkServiceType>;

  readonly allowsCellularAccess: boolean;

  readonly allowsExpensiveNetworkAccess: boolean;

  readonly allowsConstrainedNetworkAccess: boolean;

  readonly assumesHTTP3Capable: boolean;

  readonly attribution: interop.Enum<typeof NSURLRequestAttribution>;

  readonly requiresDNSSECValidation: boolean;

  readonly HTTPMethod: string;

  readonly allHTTPHeaderFields: NSDictionary;

  valueForHTTPHeaderField(field: string): string;

  readonly HTTPBody: NSData;

  readonly HTTPBodyStream: NSInputStream;

  readonly HTTPShouldHandleCookies: boolean;

  readonly HTTPShouldUsePipelining: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSAttributedString extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  readonly string: string;

  attributesAtIndexEffectiveRange(location: number, range: interop.PointerConvertible): NSDictionary;

  readonly length: number;

  attributeAtIndexEffectiveRange(attrName: string, location: number, range: interop.PointerConvertible): interop.Object;

  attributedSubstringFromRange(range: _NSRange): NSAttributedString;

  attributesAtIndexLongestEffectiveRangeInRange(location: number, range: interop.PointerConvertible, rangeLimit: _NSRange): NSDictionary;

  attributeAtIndexLongestEffectiveRangeInRange(attrName: string, location: number, range: interop.PointerConvertible, rangeLimit: _NSRange): interop.Object;

  isEqualToAttributedString(other: NSAttributedString): boolean;

  initWithString(str: string): this;

  initWithStringAttributes(str: string, attrs: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  initWithAttributedString(attrStr: NSAttributedString): this;

  enumerateAttributesInRangeOptionsUsingBlock(enumerationRange: _NSRange, opts: interop.Enum<typeof NSAttributedStringEnumerationOptions>, block: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p2: _NSRange, p3: interop.PointerConvertible) => void): void;

  enumerateAttributeInRangeOptionsUsingBlock(attrName: string, enumerationRange: _NSRange, opts: interop.Enum<typeof NSAttributedStringEnumerationOptions>, block: (p1: interop.Object, p2: _NSRange, p3: interop.PointerConvertible) => void | null): void;

  initWithContentsOfMarkdownFileAtURLOptionsBaseURLError(markdownFile: NSURL, options: NSAttributedStringMarkdownParsingOptions | null, baseURL: NSURL | null, error: interop.PointerConvertible): this;

  initWithMarkdownOptionsBaseURLError(markdown: NSData, options: NSAttributedStringMarkdownParsingOptions | null, baseURL: NSURL | null, error: interop.PointerConvertible): this;

  initWithMarkdownStringOptionsBaseURLError(markdownString: string, options: NSAttributedStringMarkdownParsingOptions | null, baseURL: NSURL | null, error: interop.PointerConvertible): this;

  initWithFormatOptionsLocale(format: NSAttributedString, options: interop.Enum<typeof NSAttributedStringFormattingOptions>, locale: NSLocale | null): this;

  initWithFormatOptionsLocaleArguments(format: NSAttributedString, options: interop.Enum<typeof NSAttributedStringFormattingOptions>, locale: NSLocale | null, arguments$: string): this;

  static localizedAttributedStringWithFormat<This extends abstract new (...args: any) => any>(this: This, format: NSAttributedString): InstanceType<This>;

  static localizedAttributedStringWithFormatOptions<This extends abstract new (...args: any) => any>(this: This, format: NSAttributedString, options: interop.Enum<typeof NSAttributedStringFormattingOptions>): InstanceType<This>;

  initWithFormatOptionsLocaleContext(format: NSAttributedString, options: interop.Enum<typeof NSAttributedStringFormattingOptions>, locale: NSLocale | null, context: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  initWithFormatOptionsLocaleContextArguments(format: NSAttributedString, options: interop.Enum<typeof NSAttributedStringFormattingOptions>, locale: NSLocale | null, context: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, arguments$: string): this;

  static localizedAttributedStringWithFormatContext<This extends abstract new (...args: any) => any>(this: This, format: NSAttributedString, context: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): InstanceType<This>;

  static localizedAttributedStringWithFormatOptionsContext<This extends abstract new (...args: any) => any>(this: This, format: NSAttributedString, options: interop.Enum<typeof NSAttributedStringFormattingOptions>, context: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): InstanceType<This>;

  attributedStringByInflectingString(): NSAttributedString;

  static attributedStringWithAttachment(attachment: NSTextAttachment): NSAttributedString;

  initWithURLOptionsDocumentAttributesError(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, dict: interop.PointerConvertible, error: interop.PointerConvertible): this;

  initWithDataOptionsDocumentAttributesError(data: NSData, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, dict: interop.PointerConvertible, error: interop.PointerConvertible): this;

  dataFromRangeDocumentAttributesError(range: _NSRange, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, error: interop.PointerConvertible): NSData;

  fileWrapperFromRangeDocumentAttributesError(range: _NSRange, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, error: interop.PointerConvertible): NSFileWrapper;

  containsAttachmentsInRange(range: _NSRange): boolean;

  initWithFileURLOptionsDocumentAttributesError(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, dict: interop.PointerConvertible, error: interop.PointerConvertible): this;

  size(): CGSize;

  drawAtPoint(point: CGPoint): void;

  drawInRect(rect: CGRect): void;

  drawWithRectOptionsContext(rect: CGRect, options: interop.Enum<typeof NSStringDrawingOptions>, context: NSStringDrawingContext | null): void;

  boundingRectWithSizeOptionsContext(size: CGSize, options: interop.Enum<typeof NSStringDrawingOptions>, context: NSStringDrawingContext | null): CGRect;

  static loadFromHTMLWithRequestOptionsCompletionHandler(request: NSURLRequest, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: (p1: NSAttributedString, p2: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p3: NSError) => void): void;

  static loadFromHTMLWithFileURLOptionsCompletionHandler(fileURL: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: (p1: NSAttributedString, p2: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p3: NSError) => void): void;

  static loadFromHTMLWithStringOptionsCompletionHandler(string: string, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: (p1: NSAttributedString, p2: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p3: NSError) => void): void;

  static loadFromHTMLWithDataOptionsCompletionHandler(data: NSData, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: (p1: NSAttributedString, p2: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p3: NSError) => void): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCachedURLResponse extends NSObject implements NSSecureCoding, NSCopying {
  initWithResponseData(response: NSURLResponse, data: NSData): this;

  initWithResponseDataUserInfoStoragePolicy(response: NSURLResponse, data: NSData, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, storagePolicy: interop.Enum<typeof NSURLCacheStoragePolicy>): this;

  readonly response: NSURLResponse;

  readonly data: NSData;

  readonly userInfo: NSDictionary;

  readonly storagePolicy: interop.Enum<typeof NSURLCacheStoragePolicy>;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSURLCache extends NSObject {
  static sharedURLCache: NSURLCache;

  initWithMemoryCapacityDiskCapacityDiskPath(memoryCapacity: number, diskCapacity: number, path: string | null): this;

  initWithMemoryCapacityDiskCapacityDirectoryURL(memoryCapacity: number, diskCapacity: number, directoryURL: NSURL | null): this;

  cachedResponseForRequest(request: NSURLRequest): NSCachedURLResponse;

  storeCachedResponseForRequest(cachedResponse: NSCachedURLResponse, request: NSURLRequest): void;

  removeCachedResponseForRequest(request: NSURLRequest): void;

  removeAllCachedResponses(): void;

  removeCachedResponsesSinceDate(date: NSDate): void;

  memoryCapacity: number;

  diskCapacity: number;

  readonly currentMemoryUsage: number;

  readonly currentDiskUsage: number;

  storeCachedResponseForDataTask(cachedResponse: NSCachedURLResponse, dataTask: NSURLSessionDataTask): void;

  getCachedResponseForDataTaskCompletionHandler(dataTask: NSURLSessionDataTask, completionHandler: (p1: NSCachedURLResponse) => void | null): void;

  removeCachedResponseForDataTask(dataTask: NSURLSessionDataTask): void;
}

declare class NSURLSessionTask extends NSObject implements NSCopying, NSProgressReporting {
  readonly taskIdentifier: number;

  readonly originalRequest: NSURLRequest;

  readonly currentRequest: NSURLRequest;

  readonly response: NSURLResponse;

  delegate: NSURLSessionTaskDelegate;

  readonly progress: NSProgress;

  earliestBeginDate: NSDate;

  countOfBytesClientExpectsToSend: number;

  countOfBytesClientExpectsToReceive: number;

  readonly countOfBytesSent: number;

  readonly countOfBytesReceived: number;

  readonly countOfBytesExpectedToSend: number;

  readonly countOfBytesExpectedToReceive: number;

  taskDescription: string;

  cancel(): void;

  readonly state: interop.Enum<typeof NSURLSessionTaskState>;

  readonly error: NSError;

  suspend(): void;

  resume(): void;

  priority: number;

  prefersIncrementalDelivery: boolean;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSURLAuthenticationChallenge extends NSObject implements NSSecureCoding {
  initWithProtectionSpaceProposedCredentialPreviousFailureCountFailureResponseErrorSender(space: NSURLProtectionSpace, credential: NSURLCredential | null, previousFailureCount: number, response: NSURLResponse | null, error: NSError | null, sender: NSURLAuthenticationChallengeSender): this;

  initWithAuthenticationChallengeSender(challenge: NSURLAuthenticationChallenge, sender: NSURLAuthenticationChallengeSender): this;

  readonly protectionSpace: NSURLProtectionSpace;

  readonly proposedCredential: NSURLCredential;

  readonly previousFailureCount: number;

  readonly failureResponse: NSURLResponse;

  readonly error: NSError;

  readonly sender: NSURLAuthenticationChallengeSender;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSThread extends NSObject {
  static readonly currentThread: NSThread;

  static detachNewThreadWithBlock(block: () => void): void;

  static detachNewThreadSelectorToTargetWithObject(selector: string, target: interop.Object, argument: interop.Object | null): void;

  static isMultiThreaded(): boolean;

  readonly threadDictionary: NSMutableDictionary;

  static sleepUntilDate(date: NSDate): void;

  static sleepForTimeInterval(ti: number): void;

  static exit(): void;

  static threadPriority(): number;

  static setThreadPriority(p: number): boolean;

  threadPriority: number;

  qualityOfService: interop.Enum<typeof NSQualityOfService>;

  static readonly callStackReturnAddresses: NSArray;

  static readonly callStackSymbols: NSArray;

  name: string;

  stackSize: number;

  readonly isMainThread: boolean;

  static readonly isMainThread: boolean;

  static readonly mainThread: NSThread;

  init(): this;

  initWithTargetSelectorObject(target: interop.Object, selector: string, argument: interop.Object | null): this;

  initWithBlock(block: () => void): this;

  readonly isExecuting: boolean;

  readonly isFinished: boolean;

  readonly isCancelled: boolean;

  cancel(): void;

  start(): void;

  main(): void;
}

declare class NSNotificationCenter extends NSObject {
  static readonly defaultCenter: NSNotificationCenter;

  addObserverSelectorNameObject(observer: interop.Object, aSelector: string, aName: string | null, anObject: interop.Object | null): void;

  postNotification(notification: NSNotification): void;

  postNotificationNameObject(aName: string, anObject: interop.Object | null): void;

  postNotificationNameObjectUserInfo(aName: string, anObject: interop.Object | null, aUserInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  removeObserver(observer: interop.Object): void;

  removeObserverNameObject(observer: interop.Object, aName: string | null, anObject: interop.Object | null): void;

  addObserverForNameObjectQueueUsingBlock(name: string | null, obj: interop.Object | null, queue: NSOperationQueue | null, block: (p1: NSNotification) => void): NSObject;
}

// @ts-ignore
declare class NSMutableData extends NSData {
  readonly mutableBytes: interop.Pointer;

  // @ts-ignore
  length: number;

  appendBytesLength(bytes: interop.PointerConvertible, length: number): void;

  appendData(other: NSData): void;

  increaseLengthBy(extraLength: number): void;

  replaceBytesInRangeWithBytes(range: _NSRange, bytes: interop.PointerConvertible): void;

  resetBytesInRange(range: _NSRange): void;

  setData(data: NSData): void;

  replaceBytesInRangeWithBytesLength(range: _NSRange, replacementBytes: interop.PointerConvertible, replacementLength: number): void;

  static dataWithCapacity<This extends abstract new (...args: any) => any>(this: This, aNumItems: number): InstanceType<This>;

  static dataWithLength<This extends abstract new (...args: any) => any>(this: This, length: number): InstanceType<This>;

  initWithCapacity(capacity: number): this;

  initWithLength(length: number): this;

  decompressUsingAlgorithmError(algorithm: interop.Enum<typeof NSDataCompressionAlgorithm>, error: interop.PointerConvertible): boolean;

  compressUsingAlgorithmError(algorithm: interop.Enum<typeof NSDataCompressionAlgorithm>, error: interop.PointerConvertible): boolean;
}

declare class NSFileManager extends NSObject {
  static readonly defaultManager: NSFileManager;

  mountedVolumeURLsIncludingResourceValuesForKeysOptions(propertyKeys: NSArray<interop.Object> | Array<interop.Object> | null, options: interop.Enum<typeof NSVolumeEnumerationOptions>): NSArray;

  contentsOfDirectoryAtURLIncludingPropertiesForKeysOptionsError(url: NSURL, keys: NSArray<interop.Object> | Array<interop.Object> | null, mask: interop.Enum<typeof NSDirectoryEnumerationOptions>, error: interop.PointerConvertible): NSArray;

  URLsForDirectoryInDomains(directory: interop.Enum<typeof NSSearchPathDirectory>, domainMask: interop.Enum<typeof NSSearchPathDomainMask>): NSArray;

  URLForDirectoryInDomainAppropriateForURLCreateError(directory: interop.Enum<typeof NSSearchPathDirectory>, domain: interop.Enum<typeof NSSearchPathDomainMask>, url: NSURL | null, shouldCreate: boolean, error: interop.PointerConvertible): NSURL;

  getRelationshipOfDirectoryAtURLToItemAtURLError(outRelationship: interop.PointerConvertible, directoryURL: NSURL, otherURL: NSURL, error: interop.PointerConvertible): boolean;

  getRelationshipOfDirectoryInDomainToItemAtURLError(outRelationship: interop.PointerConvertible, directory: interop.Enum<typeof NSSearchPathDirectory>, domainMask: interop.Enum<typeof NSSearchPathDomainMask>, url: NSURL, error: interop.PointerConvertible): boolean;

  createDirectoryAtURLWithIntermediateDirectoriesAttributesError(url: NSURL, createIntermediates: boolean, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;

  createSymbolicLinkAtURLWithDestinationURLError(url: NSURL, destURL: NSURL, error: interop.PointerConvertible): boolean;

  delegate: NSFileManagerDelegate;

  setAttributesOfItemAtPathError(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, path: string, error: interop.PointerConvertible): boolean;

  createDirectoryAtPathWithIntermediateDirectoriesAttributesError(path: string, createIntermediates: boolean, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;

  contentsOfDirectoryAtPathError(path: string, error: interop.PointerConvertible): NSArray;

  subpathsOfDirectoryAtPathError(path: string, error: interop.PointerConvertible): NSArray;

  attributesOfItemAtPathError(path: string, error: interop.PointerConvertible): NSDictionary;

  attributesOfFileSystemForPathError(path: string, error: interop.PointerConvertible): NSDictionary;

  createSymbolicLinkAtPathWithDestinationPathError(path: string, destPath: string, error: interop.PointerConvertible): boolean;

  destinationOfSymbolicLinkAtPathError(path: string, error: interop.PointerConvertible): string;

  copyItemAtPathToPathError(srcPath: string, dstPath: string, error: interop.PointerConvertible): boolean;

  moveItemAtPathToPathError(srcPath: string, dstPath: string, error: interop.PointerConvertible): boolean;

  linkItemAtPathToPathError(srcPath: string, dstPath: string, error: interop.PointerConvertible): boolean;

  removeItemAtPathError(path: string, error: interop.PointerConvertible): boolean;

  copyItemAtURLToURLError(srcURL: NSURL, dstURL: NSURL, error: interop.PointerConvertible): boolean;

  moveItemAtURLToURLError(srcURL: NSURL, dstURL: NSURL, error: interop.PointerConvertible): boolean;

  linkItemAtURLToURLError(srcURL: NSURL, dstURL: NSURL, error: interop.PointerConvertible): boolean;

  removeItemAtURLError(URL: NSURL, error: interop.PointerConvertible): boolean;

  trashItemAtURLResultingItemURLError(url: NSURL, outResultingURL: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  fileAttributesAtPathTraverseLink(path: string, yorn: boolean): NSDictionary;

  changeFileAttributesAtPath(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, path: string): boolean;

  directoryContentsAtPath(path: string): NSArray;

  fileSystemAttributesAtPath(path: string): NSDictionary;

  pathContentOfSymbolicLinkAtPath(path: string): string;

  createSymbolicLinkAtPathPathContent(path: string, otherpath: string): boolean;

  createDirectoryAtPathAttributes(path: string, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): boolean;

  readonly currentDirectoryPath: string;

  changeCurrentDirectoryPath(path: string): boolean;

  fileExistsAtPath(path: string): boolean;

  fileExistsAtPathIsDirectory(path: string, isDirectory: interop.PointerConvertible): boolean;

  isReadableFileAtPath(path: string): boolean;

  isWritableFileAtPath(path: string): boolean;

  isExecutableFileAtPath(path: string): boolean;

  isDeletableFileAtPath(path: string): boolean;

  contentsEqualAtPathAndPath(path1: string, path2: string): boolean;

  displayNameAtPath(path: string): string;

  componentsToDisplayForPath(path: string): NSArray;

  enumeratorAtPath(path: string): NSDirectoryEnumerator;

  enumeratorAtURLIncludingPropertiesForKeysOptionsErrorHandler(url: NSURL, keys: NSArray<interop.Object> | Array<interop.Object> | null, mask: interop.Enum<typeof NSDirectoryEnumerationOptions>, handler: (p1: NSURL, p2: NSError) => boolean | null): NSDirectoryEnumerator;

  subpathsAtPath(path: string): NSArray;

  contentsAtPath(path: string): NSData;

  createFileAtPathContentsAttributes(path: string, data: NSData | null, attr: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): boolean;

  fileSystemRepresentationWithPath(path: string): string;

  stringWithFileSystemRepresentationLength(str: string, len: number): string;

  replaceItemAtURLWithItemAtURLBackupItemNameOptionsResultingItemURLError(originalItemURL: NSURL, newItemURL: NSURL, backupItemName: string | null, options: interop.Enum<typeof NSFileManagerItemReplacementOptions>, resultingURL: interop.PointerConvertible, error: interop.PointerConvertible): boolean;

  setUbiquitousItemAtURLDestinationURLError(flag: boolean, url: NSURL, destinationURL: NSURL, error: interop.PointerConvertible): boolean;

  isUbiquitousItemAtURL(url: NSURL): boolean;

  startDownloadingUbiquitousItemAtURLError(url: NSURL, error: interop.PointerConvertible): boolean;

  evictUbiquitousItemAtURLError(url: NSURL, error: interop.PointerConvertible): boolean;

  URLForUbiquityContainerIdentifier(containerIdentifier: string | null): NSURL;

  URLForPublishingUbiquitousItemAtURLExpirationDateError(url: NSURL, outDate: interop.PointerConvertible, error: interop.PointerConvertible): NSURL;

  readonly ubiquityIdentityToken: NSCoding;

  getFileProviderServicesForItemAtURLCompletionHandler(url: NSURL, completionHandler: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p2: NSError) => void | null): void;

  containerURLForSecurityApplicationGroupIdentifier(groupIdentifier: string): NSURL;

  readonly temporaryDirectory: NSURL;
}

declare class NSDirectoryEnumerator<ObjectType = interop.Object> extends NSEnumerator {
  readonly fileAttributes: NSDictionary;

  readonly directoryAttributes: NSDictionary;

  readonly isEnumeratingDirectoryPostOrder: boolean;

  skipDescendents(): void;

  readonly level: number;

  skipDescendants(): void;
}

declare class NSStream extends NSObject {
  open(): void;

  close(): void;

  delegate: NSStreamDelegate;

  propertyForKey(key: string): interop.Object;

  setPropertyForKey(property: interop.Object | null, key: string): boolean;

  scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  readonly streamStatus: interop.Enum<typeof NSStreamStatus>;

  readonly streamError: NSError;

  static getStreamsToHostWithNamePortInputStreamOutputStream(hostname: string, port: number, inputStream: interop.PointerConvertible, outputStream: interop.PointerConvertible): void;

  static getBoundStreamsWithBufferSizeInputStreamOutputStream(bufferSize: number, inputStream: interop.PointerConvertible, outputStream: interop.PointerConvertible): void;
}

declare class NSDataDetector extends NSRegularExpression {
  static dataDetectorWithTypesError(checkingTypes: number, error: interop.PointerConvertible): NSDataDetector;

  initWithTypesError(checkingTypes: number, error: interop.PointerConvertible): this;

  readonly checkingTypes: number;
}

declare class NSTextCheckingResult extends NSObject implements NSCopying, NSSecureCoding {
  readonly resultType: interop.Enum<typeof NSTextCheckingType>;

  readonly range: _NSRange;

  readonly orthography: NSOrthography;

  readonly grammarDetails: NSArray;

  readonly date: NSDate;

  readonly timeZone: NSTimeZone;

  readonly duration: number;

  readonly components: NSDictionary;

  readonly URL: NSURL;

  readonly replacementString: string;

  readonly alternativeStrings: NSArray;

  readonly regularExpression: NSRegularExpression;

  readonly phoneNumber: string;

  readonly numberOfRanges: number;

  rangeAtIndex(idx: number): _NSRange;

  rangeWithName(name: string): _NSRange;

  resultByAdjustingRangesWithOffset(offset: number): NSTextCheckingResult;

  readonly addressComponents: NSDictionary;

  static orthographyCheckingResultWithRangeOrthography(range: _NSRange, orthography: NSOrthography): NSTextCheckingResult;

  static spellCheckingResultWithRange(range: _NSRange): NSTextCheckingResult;

  static grammarCheckingResultWithRangeDetails(range: _NSRange, details: NSArray<interop.Object> | Array<interop.Object>): NSTextCheckingResult;

  static dateCheckingResultWithRangeDate(range: _NSRange, date: NSDate): NSTextCheckingResult;

  static dateCheckingResultWithRangeDateTimeZoneDuration(range: _NSRange, date: NSDate, timeZone: NSTimeZone, duration: number): NSTextCheckingResult;

  static addressCheckingResultWithRangeComponents(range: _NSRange, components: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSTextCheckingResult;

  static linkCheckingResultWithRangeURL(range: _NSRange, url: NSURL): NSTextCheckingResult;

  static quoteCheckingResultWithRangeReplacementString(range: _NSRange, replacementString: string): NSTextCheckingResult;

  static dashCheckingResultWithRangeReplacementString(range: _NSRange, replacementString: string): NSTextCheckingResult;

  static replacementCheckingResultWithRangeReplacementString(range: _NSRange, replacementString: string): NSTextCheckingResult;

  static correctionCheckingResultWithRangeReplacementString(range: _NSRange, replacementString: string): NSTextCheckingResult;

  static correctionCheckingResultWithRangeReplacementStringAlternativeStrings(range: _NSRange, replacementString: string, alternativeStrings: NSArray<interop.Object> | Array<interop.Object>): NSTextCheckingResult;

  static regularExpressionCheckingResultWithRangesCountRegularExpression(ranges: interop.PointerConvertible, count: number, regularExpression: NSRegularExpression): NSTextCheckingResult;

  static phoneNumberCheckingResultWithRangePhoneNumber(range: _NSRange, phoneNumber: string): NSTextCheckingResult;

  static transitInformationCheckingResultWithRangeComponents(range: _NSRange, components: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSTextCheckingResult;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore
declare class NSMachPort extends NSPort {
  static portWithMachPort(machPort: number): NSPort;

  initWithMachPort(machPort: number): this;

  // @ts-ignore
  setDelegate(anObject: NSMachPortDelegate | null): void;

  // @ts-ignore
  delegate(): NSMachPortDelegate;

  static portWithMachPortOptions(machPort: number, f: interop.Enum<typeof NSMachPortOptions>): NSPort;

  initWithMachPortOptions(machPort: number, f: interop.Enum<typeof NSMachPortOptions>): this;

  readonly machPort: number;

  scheduleInRunLoopForMode(runLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(runLoop: NSRunLoop, mode: string): void;
}

declare class NSMetadataQueryResultGroup extends NSObject {
  readonly attribute: string;

  readonly value: interop.Object;

  readonly subgroups: NSArray;

  readonly resultCount: number;

  resultAtIndex(idx: number): interop.Object;

  readonly results: NSArray;
}

declare class NSURLQueryItem extends NSObject implements NSSecureCoding, NSCopying {
  initWithNameValue(name: string, value: string | null): this;

  static queryItemWithNameValue<This extends abstract new (...args: any) => any>(this: This, name: string, value: string | null): InstanceType<This>;

  readonly name: string;

  readonly value: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSOperationQueue extends NSObject implements NSProgressReporting {
  readonly progress: NSProgress;

  addOperation(op: NSOperation): void;

  addOperationsWaitUntilFinished(ops: NSArray<interop.Object> | Array<interop.Object>, wait: boolean): void;

  addOperationWithBlock(block: () => void): void;

  addBarrierBlock(barrier: () => void): void;

  maxConcurrentOperationCount: number;

  isSuspended: boolean;

  name: string;

  qualityOfService: interop.Enum<typeof NSQualityOfService>;

  underlyingQueue: NSObject;

  cancelAllOperations(): void;

  waitUntilAllOperationsAreFinished(): void;

  static readonly currentQueue: NSOperationQueue;

  static readonly mainQueue: NSOperationQueue;

  readonly operations: NSArray;

  readonly operationCount: number;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSURLSessionStreamTask extends NSURLSessionTask {
  readDataOfMinLengthMaxLengthTimeoutCompletionHandler(minBytes: number, maxBytes: number, timeout: number, completionHandler: (p1: NSData, p2: boolean, p3: NSError) => void | null): void;

  writeDataTimeoutCompletionHandler(data: NSData, timeout: number, completionHandler: (p1: NSError) => void | null): void;

  captureStreams(): void;

  closeWrite(): void;

  closeRead(): void;

  startSecureConnection(): void;

  stopSecureConnection(): void;

  init(): this;

  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

declare class NSOperation extends NSObject {
  start(): void;

  main(): void;

  readonly isCancelled: boolean;

  cancel(): void;

  readonly isExecuting: boolean;

  readonly isFinished: boolean;

  readonly isConcurrent: boolean;

  readonly isAsynchronous: boolean;

  readonly isReady: boolean;

  addDependency(op: NSOperation): void;

  removeDependency(op: NSOperation): void;

  readonly dependencies: NSArray;

  queuePriority: interop.Enum<typeof NSOperationQueuePriority>;

  completionBlock: () => void;

  waitUntilFinished(): void;

  threadPriority: number;

  qualityOfService: interop.Enum<typeof NSQualityOfService>;

  name: string;
}

// @ts-ignore
declare class NSMutableDictionary<KeyType = interop.Object, ObjectType = interop.Object> extends NSDictionary {
  removeObjectForKey(aKey: KeyType): void;

  setObjectForKey(anObject: ObjectType, aKey: NSCopying): void;

  init(): this;

  initWithCapacity(numItems: number): this;

  initWithCoder(coder: NSCoder): this;

  addEntriesFromDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  removeAllObjects(): void;

  removeObjectsForKeys(keyArray: NSArray<interop.Object> | Array<interop.Object>): void;

  setDictionary(otherDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  setObjectForKeyedSubscript(obj: ObjectType | null, key: NSCopying): void;

  static dictionaryWithCapacity<KeyType, ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;

  // @ts-ignore
  static dictionaryWithContentsOfFile<KeyType, ObjectType>(path: string): NSMutableDictionary;

  // @ts-ignore
  static dictionaryWithContentsOfURL<KeyType, ObjectType>(url: NSURL): NSMutableDictionary;

  // @ts-ignore
  initWithContentsOfFile(path: string): NSMutableDictionary;

  // @ts-ignore
  initWithContentsOfURL(url: NSURL): NSMutableDictionary;

  static dictionaryWithSharedKeySet<KeyType, ObjectType>(keyset: interop.Object): NSMutableDictionary;

  // @ts-ignore
  setValueForKey(value: ObjectType | null, key: string): void;
}

declare class NSPropertyListSerialization extends NSObject {
  static propertyListIsValidForFormat(plist: interop.Object, format: interop.Enum<typeof NSPropertyListFormat>): boolean;

  static dataWithPropertyListFormatOptionsError(plist: interop.Object, format: interop.Enum<typeof NSPropertyListFormat>, opt: number, error: interop.PointerConvertible): NSData;

  static writePropertyListToStreamFormatOptionsError(plist: interop.Object, stream: NSOutputStream, format: interop.Enum<typeof NSPropertyListFormat>, opt: number, error: interop.PointerConvertible): number;

  static propertyListWithDataOptionsFormatError(data: NSData, opt: interop.Enum<typeof NSPropertyListMutabilityOptions>, format: interop.PointerConvertible, error: interop.PointerConvertible): interop.Object;

  static propertyListWithStreamOptionsFormatError(stream: NSInputStream, opt: interop.Enum<typeof NSPropertyListMutabilityOptions>, format: interop.PointerConvertible, error: interop.PointerConvertible): interop.Object;

  static dataFromPropertyListFormatErrorDescription(plist: interop.Object, format: interop.Enum<typeof NSPropertyListFormat>, errorString: interop.PointerConvertible): NSData;

  static propertyListFromDataMutabilityOptionFormatErrorDescription(data: NSData, opt: interop.Enum<typeof NSPropertyListMutabilityOptions>, format: interop.PointerConvertible, errorString: interop.PointerConvertible): interop.Object;
}

declare class NSURLCredential extends NSObject implements NSSecureCoding, NSCopying {
  readonly persistence: interop.Enum<typeof NSURLCredentialPersistence>;

  initWithUserPasswordPersistence(user: string, password: string, persistence: interop.Enum<typeof NSURLCredentialPersistence>): this;

  static credentialWithUserPasswordPersistence(user: string, password: string, persistence: interop.Enum<typeof NSURLCredentialPersistence>): NSURLCredential;

  readonly user: string;

  readonly password: string;

  readonly hasPassword: boolean;

  initWithIdentityCertificatesPersistence(identity: interop.PointerConvertible, certArray: NSArray<interop.Object> | Array<interop.Object> | null, persistence: interop.Enum<typeof NSURLCredentialPersistence>): this;

  static credentialWithIdentityCertificatesPersistence(identity: interop.PointerConvertible, certArray: NSArray<interop.Object> | Array<interop.Object> | null, persistence: interop.Enum<typeof NSURLCredentialPersistence>): NSURLCredential;

  readonly identity: interop.Pointer;

  readonly certificates: NSArray;

  initWithTrust(trust: interop.PointerConvertible): this;

  static credentialForTrust(trust: interop.PointerConvertible): NSURLCredential;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSInflectionRuleExplicit extends NSInflectionRule {
  initWithMorphology(morphology: NSMorphology): this;

  readonly morphology: NSMorphology;
}

declare class NSUnitMass extends NSDimension implements NSSecureCoding {
  static readonly kilograms: NSUnitMass;

  static readonly grams: NSUnitMass;

  static readonly decigrams: NSUnitMass;

  static readonly centigrams: NSUnitMass;

  static readonly milligrams: NSUnitMass;

  static readonly micrograms: NSUnitMass;

  static readonly nanograms: NSUnitMass;

  static readonly picograms: NSUnitMass;

  static readonly ounces: NSUnitMass;

  static readonly poundsMass: NSUnitMass;

  static readonly stones: NSUnitMass;

  static readonly metricTons: NSUnitMass;

  static readonly shortTons: NSUnitMass;

  static readonly carats: NSUnitMass;

  static readonly ouncesTroy: NSUnitMass;

  static readonly slugs: NSUnitMass;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSLengthFormatter extends NSFormatter {
  numberFormatter: NSNumberFormatter;

  unitStyle: interop.Enum<typeof NSFormattingUnitStyle>;

  isForPersonHeightUse: boolean;

  stringFromValueUnit(value: number, unit: interop.Enum<typeof NSLengthFormatterUnit>): string;

  stringFromMeters(numberInMeters: number): string;

  unitStringFromValueUnit(value: number, unit: interop.Enum<typeof NSLengthFormatterUnit>): string;

  unitStringFromMetersUsedUnit(numberInMeters: number, unitp: interop.PointerConvertible): string;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;
}

declare class NSNetService extends NSObject {
  initWithDomainTypeNamePort(domain: string, type: string, name: string, port: number): this;

  initWithDomainTypeName(domain: string, type: string, name: string): this;

  scheduleInRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  removeFromRunLoopForMode(aRunLoop: NSRunLoop, mode: string): void;

  delegate: NSNetServiceDelegate;

  includesPeerToPeer: boolean;

  readonly name: string;

  readonly type: string;

  readonly domain: string;

  readonly hostName: string;

  readonly addresses: NSArray;

  readonly port: number;

  publish(): void;

  publishWithOptions(options: interop.Enum<typeof NSNetServiceOptions>): void;

  resolve(): void;

  stop(): void;

  static dictionaryFromTXTRecordData(txtData: NSData): NSDictionary;

  static dataFromTXTRecordDictionary(txtDictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSData;

  resolveWithTimeout(timeout: number): void;

  getInputStreamOutputStream(inputStream: interop.PointerConvertible, outputStream: interop.PointerConvertible): boolean;

  setTXTRecordData(recordData: NSData | null): boolean;

  TXTRecordData(): NSData;

  startMonitoring(): void;

  stopMonitoring(): void;
}

// @ts-ignore
declare class NSDecimalNumber extends NSNumber {
  initWithMantissaExponentIsNegative(mantissa: number, exponent: number, flag: boolean): this;

  initWithDecimal(dcm: NSDecimal): this;

  initWithString(numberValue: string | null): this;

  initWithStringLocale(numberValue: string | null, locale: interop.Object | null): this;

  descriptionWithLocale(locale: interop.Object | null): string;

  readonly decimalValue: NSDecimal;

  static decimalNumberWithMantissaExponentIsNegative(mantissa: number, exponent: number, flag: boolean): NSDecimalNumber;

  static decimalNumberWithDecimal(dcm: NSDecimal): NSDecimalNumber;

  static decimalNumberWithString(numberValue: string | null): NSDecimalNumber;

  static decimalNumberWithStringLocale(numberValue: string | null, locale: interop.Object | null): NSDecimalNumber;

  static readonly zero: NSDecimalNumber;

  static readonly one: NSDecimalNumber;

  static readonly minimumDecimalNumber: NSDecimalNumber;

  static readonly maximumDecimalNumber: NSDecimalNumber;

  static readonly notANumber: NSDecimalNumber;

  decimalNumberByAdding(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberByAddingWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberBySubtracting(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberBySubtractingWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByMultiplyingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberByMultiplyingByWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByDividingBy(decimalNumber: NSDecimalNumber): NSDecimalNumber;

  decimalNumberByDividingByWithBehavior(decimalNumber: NSDecimalNumber, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByRaisingToPower(power: number): NSDecimalNumber;

  decimalNumberByRaisingToPowerWithBehavior(power: number, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByMultiplyingByPowerOf10(power: number): NSDecimalNumber;

  decimalNumberByMultiplyingByPowerOf10WithBehavior(power: number, behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  decimalNumberByRoundingAccordingToBehavior(behavior: NSDecimalNumberBehaviors | null): NSDecimalNumber;

  // @ts-ignore
  compare(decimalNumber: NSNumber): interop.Enum<typeof NSComparisonResult>;

  static defaultBehavior: NSDecimalNumberBehaviors;

  readonly objCType: string;

  readonly doubleValue: number;
}

declare class NSExpression extends NSObject implements NSSecureCoding, NSCopying {
  static expressionWithFormatArgumentArray(expressionFormat: string, arguments$: NSArray<interop.Object> | Array<interop.Object>): NSExpression;

  static expressionWithFormat(expressionFormat: string): NSExpression;

  static expressionWithFormatArguments(expressionFormat: string, argList: string): NSExpression;

  static expressionForConstantValue(obj: interop.Object | null): NSExpression;

  static expressionForEvaluatedObject(): NSExpression;

  static expressionForVariable(string: string): NSExpression;

  static expressionForKeyPath(keyPath: string): NSExpression;

  static expressionForFunctionArguments(name: string, parameters: NSArray<interop.Object> | Array<interop.Object>): NSExpression;

  static expressionForAggregate(subexpressions: NSArray<interop.Object> | Array<interop.Object>): NSExpression;

  static expressionForUnionSetWith(left: NSExpression, right: NSExpression): NSExpression;

  static expressionForIntersectSetWith(left: NSExpression, right: NSExpression): NSExpression;

  static expressionForMinusSetWith(left: NSExpression, right: NSExpression): NSExpression;

  static expressionForSubqueryUsingIteratorVariablePredicate(expression: NSExpression, variable: string, predicate: NSPredicate): NSExpression;

  static expressionForFunctionSelectorNameArguments(target: NSExpression, name: string, parameters: NSArray<interop.Object> | Array<interop.Object> | null): NSExpression;

  static expressionForAnyKey(): NSExpression;

  static expressionForBlockArguments(block: (p1: interop.Object, p2: NSArray<interop.Object> | Array<interop.Object>, p3: NSMutableDictionary) => interop.Object | null, arguments$: NSArray<interop.Object> | Array<interop.Object> | null): NSExpression;

  static expressionForConditionalTrueExpressionFalseExpression(predicate: NSPredicate, trueExpression: NSExpression, falseExpression: NSExpression): NSExpression;

  initWithExpressionType(type: interop.Enum<typeof NSExpressionType>): this;

  initWithCoder(coder: NSCoder): this;

  readonly expressionType: interop.Enum<typeof NSExpressionType>;

  readonly constantValue: interop.Object;

  readonly keyPath: string;

  readonly function: string;

  readonly variable: string;

  readonly operand: NSExpression;

  readonly arguments: NSArray;

  readonly collection: interop.Object;

  readonly predicate: NSPredicate;

  readonly leftExpression: NSExpression;

  readonly rightExpression: NSExpression;

  readonly trueExpression: NSExpression;

  readonly falseExpression: NSExpression;

  readonly expressionBlock: (p1: interop.Object, p2: NSArray<interop.Object> | Array<interop.Object>, p3: NSMutableDictionary) => interop.Object | null;

  expressionValueWithObjectContext(object: interop.Object | null, context: NSMutableDictionary | null): interop.Object;

  allowEvaluation(): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSUnitElectricCurrent extends NSDimension implements NSSecureCoding {
  static readonly megaamperes: NSUnitElectricCurrent;

  static readonly kiloamperes: NSUnitElectricCurrent;

  static readonly amperes: NSUnitElectricCurrent;

  static readonly milliamperes: NSUnitElectricCurrent;

  static readonly microamperes: NSUnitElectricCurrent;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSMapTable<KeyType = interop.Object, ObjectType = interop.Object> extends NSObject implements NSCopying, NSSecureCoding, NSFastEnumeration {
  initWithKeyOptionsValueOptionsCapacity(keyOptions: interop.Enum<typeof NSPointerFunctionsOptions>, valueOptions: interop.Enum<typeof NSPointerFunctionsOptions>, initialCapacity: number): this;

  initWithKeyPointerFunctionsValuePointerFunctionsCapacity(keyFunctions: NSPointerFunctions, valueFunctions: NSPointerFunctions, initialCapacity: number): this;

  static mapTableWithKeyOptionsValueOptions<KeyType, ObjectType>(keyOptions: interop.Enum<typeof NSPointerFunctionsOptions>, valueOptions: interop.Enum<typeof NSPointerFunctionsOptions>): NSMapTable;

  static strongToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable;

  static weakToStrongObjectsMapTable<KeyType, ObjectType>(): NSMapTable;

  static strongToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable;

  static weakToWeakObjectsMapTable<KeyType, ObjectType>(): NSMapTable;

  readonly keyPointerFunctions: NSPointerFunctions;

  readonly valuePointerFunctions: NSPointerFunctions;

  objectForKey(aKey: KeyType | null): ObjectType;

  removeObjectForKey(aKey: KeyType | null): void;

  setObjectForKey(anObject: ObjectType | null, aKey: KeyType | null): void;

  readonly count: number;

  keyEnumerator(): NSEnumerator;

  objectEnumerator(): NSEnumerator;

  removeAllObjects(): void;

  dictionaryRepresentation(): NSDictionary;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSMutableOrderedSet<ObjectType = interop.Object> extends NSOrderedSet {
  insertObjectAtIndex(object: ObjectType, idx: number): void;

  removeObjectAtIndex(idx: number): void;

  replaceObjectAtIndexWithObject(idx: number, object: ObjectType): void;

  initWithCoder(coder: NSCoder): this;

  init(): this;

  initWithCapacity(numItems: number): this;

  addObject(object: ObjectType): void;

  addObjectsCount(objects: interop.PointerConvertible, count: number): void;

  addObjectsFromArray(array: NSArray<interop.Object> | Array<interop.Object>): void;

  exchangeObjectAtIndexWithObjectAtIndex(idx1: number, idx2: number): void;

  moveObjectsAtIndexesToIndex(indexes: NSIndexSet, idx: number): void;

  insertObjectsAtIndexes(objects: NSArray<interop.Object> | Array<interop.Object>, indexes: NSIndexSet): void;

  setObjectAtIndex(obj: ObjectType, idx: number): void;

  setObjectAtIndexedSubscript(obj: ObjectType, idx: number): void;

  replaceObjectsInRangeWithObjectsCount(range: _NSRange, objects: interop.PointerConvertible, count: number): void;

  replaceObjectsAtIndexesWithObjects(indexes: NSIndexSet, objects: NSArray<interop.Object> | Array<interop.Object>): void;

  removeObjectsInRange(range: _NSRange): void;

  removeObjectsAtIndexes(indexes: NSIndexSet): void;

  removeAllObjects(): void;

  removeObject(object: ObjectType): void;

  removeObjectsInArray(array: NSArray<interop.Object> | Array<interop.Object>): void;

  intersectOrderedSet(other: NSOrderedSet): void;

  minusOrderedSet(other: NSOrderedSet): void;

  unionOrderedSet(other: NSOrderedSet): void;

  intersectSet(other: NSSet): void;

  minusSet(other: NSSet): void;

  unionSet(other: NSSet): void;

  sortUsingComparator(cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): void;

  sortWithOptionsUsingComparator(opts: interop.Enum<typeof NSSortOptions>, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): void;

  sortRangeOptionsUsingComparator(range: _NSRange, opts: interop.Enum<typeof NSSortOptions>, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): void;

  static orderedSetWithCapacity<ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;

  applyDifference(difference: NSOrderedCollectionDifference): void;

  sortUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): void;

  filterUsingPredicate(p: NSPredicate): void;
}

declare class NSOrderedSet<ObjectType = interop.Object> extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding, NSFastEnumeration {
  readonly count: number;

  objectAtIndex(idx: number): ObjectType;

  indexOfObject(object: ObjectType): number;

  init(): this;

  initWithObjectsCount(objects: interop.PointerConvertible, cnt: number): this;

  initWithCoder(coder: NSCoder): this;

  getObjectsRange(objects: interop.PointerConvertible, range: _NSRange): void;

  objectsAtIndexes(indexes: NSIndexSet): NSArray;

  readonly firstObject: ObjectType;

  readonly lastObject: ObjectType;

  isEqualToOrderedSet(other: NSOrderedSet): boolean;

  containsObject(object: ObjectType): boolean;

  intersectsOrderedSet(other: NSOrderedSet): boolean;

  intersectsSet(set: NSSet): boolean;

  isSubsetOfOrderedSet(other: NSOrderedSet): boolean;

  isSubsetOfSet(set: NSSet): boolean;

  objectAtIndexedSubscript(idx: number): ObjectType;

  objectEnumerator(): NSEnumerator;

  reverseObjectEnumerator(): NSEnumerator;

  readonly reversedOrderedSet: NSOrderedSet;

  readonly array: NSArray;

  readonly set: NSSet;

  enumerateObjectsUsingBlock(block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  enumerateObjectsWithOptionsUsingBlock(opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  enumerateObjectsAtIndexesOptionsUsingBlock(s: NSIndexSet, opts: interop.Enum<typeof NSEnumerationOptions>, block: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => void): void;

  indexOfObjectPassingTest(predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): number;

  indexOfObjectWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): number;

  indexOfObjectAtIndexesOptionsPassingTest(s: NSIndexSet, opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): number;

  indexesOfObjectsPassingTest(predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): NSIndexSet;

  indexesOfObjectsWithOptionsPassingTest(opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): NSIndexSet;

  indexesOfObjectsAtIndexesOptionsPassingTest(s: NSIndexSet, opts: interop.Enum<typeof NSEnumerationOptions>, predicate: (p1: interop.Object, p2: number, p3: interop.PointerConvertible) => boolean): NSIndexSet;

  indexOfObjectInSortedRangeOptionsUsingComparator(object: ObjectType, range: _NSRange, opts: interop.Enum<typeof NSBinarySearchingOptions>, cmp: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): number;

  sortedArrayUsingComparator(cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): NSArray;

  sortedArrayWithOptionsUsingComparator(opts: interop.Enum<typeof NSSortOptions>, cmptr: (p1: interop.Object, p2: interop.Object) => interop.Enum<typeof NSComparisonResult>): NSArray;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  descriptionWithLocaleIndent(locale: interop.Object | null, level: number): string;

  static orderedSet<ObjectType, This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static orderedSetWithObject<ObjectType, This extends abstract new (...args: any) => any>(this: This, object: ObjectType): InstanceType<This>;

  static orderedSetWithObjectsCount<ObjectType, This extends abstract new (...args: any) => any>(this: This, objects: interop.PointerConvertible, cnt: number): InstanceType<This>;

  static orderedSetWithObjects<ObjectType, This extends abstract new (...args: any) => any>(this: This, firstObj: ObjectType): InstanceType<This>;

  static orderedSetWithOrderedSet<ObjectType, This extends abstract new (...args: any) => any>(this: This, set: NSOrderedSet): InstanceType<This>;

  static orderedSetWithOrderedSetRangeCopyItems<ObjectType, This extends abstract new (...args: any) => any>(this: This, set: NSOrderedSet, range: _NSRange, flag: boolean): InstanceType<This>;

  static orderedSetWithArray<ObjectType, This extends abstract new (...args: any) => any>(this: This, array: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static orderedSetWithArrayRangeCopyItems<ObjectType, This extends abstract new (...args: any) => any>(this: This, array: NSArray<interop.Object> | Array<interop.Object>, range: _NSRange, flag: boolean): InstanceType<This>;

  static orderedSetWithSet<ObjectType, This extends abstract new (...args: any) => any>(this: This, set: NSSet): InstanceType<This>;

  static orderedSetWithSetCopyItems<ObjectType, This extends abstract new (...args: any) => any>(this: This, set: NSSet, flag: boolean): InstanceType<This>;

  initWithObject(object: ObjectType): this;

  initWithObjects(firstObj: ObjectType): this;

  initWithOrderedSet(set: NSOrderedSet): this;

  initWithOrderedSetCopyItems(set: NSOrderedSet, flag: boolean): this;

  initWithOrderedSetRangeCopyItems(set: NSOrderedSet, range: _NSRange, flag: boolean): this;

  initWithArray(array: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithArrayCopyItems(set: NSArray<interop.Object> | Array<interop.Object>, flag: boolean): this;

  initWithArrayRangeCopyItems(set: NSArray<interop.Object> | Array<interop.Object>, range: _NSRange, flag: boolean): this;

  initWithSet(set: NSSet): this;

  initWithSetCopyItems(set: NSSet, flag: boolean): this;

  differenceFromOrderedSetWithOptionsUsingEquivalenceTest(other: NSOrderedSet, options: interop.Enum<typeof NSOrderedCollectionDifferenceCalculationOptions>, block: (p1: interop.Object, p2: interop.Object) => boolean): NSOrderedCollectionDifference;

  differenceFromOrderedSetWithOptions(other: NSOrderedSet, options: interop.Enum<typeof NSOrderedCollectionDifferenceCalculationOptions>): NSOrderedCollectionDifference;

  differenceFromOrderedSet(other: NSOrderedSet): NSOrderedCollectionDifference;

  orderedSetByApplyingDifference(difference: NSOrderedCollectionDifference): NSOrderedSet;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;

  addObserverForKeyPathOptionsContext(observer: NSObject, keyPath: string, options: interop.Enum<typeof NSKeyValueObservingOptions>, context: interop.PointerConvertible): void;

  removeObserverForKeyPathContext(observer: NSObject, keyPath: string, context: interop.PointerConvertible): void;

  removeObserverForKeyPath(observer: NSObject, keyPath: string): void;

  sortedArrayUsingDescriptors(sortDescriptors: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  filteredOrderedSetUsingPredicate(p: NSPredicate): NSOrderedSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSInflectionRule extends NSObject implements NSCopying, NSSecureCoding {
  static readonly automaticRule: NSInflectionRule;

  static canInflectLanguage(language: string): boolean;

  static readonly canInflectPreferredLocalization: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSHTTPCookieStorage extends NSObject {
  static readonly sharedHTTPCookieStorage: NSHTTPCookieStorage;

  static sharedCookieStorageForGroupContainerIdentifier(identifier: string): NSHTTPCookieStorage;

  readonly cookies: NSArray;

  setCookie(cookie: NSHTTPCookie): void;

  deleteCookie(cookie: NSHTTPCookie): void;

  removeCookiesSinceDate(date: NSDate): void;

  cookiesForURL(URL: NSURL): NSArray;

  setCookiesForURLMainDocumentURL(cookies: NSArray<interop.Object> | Array<interop.Object>, URL: NSURL | null, mainDocumentURL: NSURL | null): void;

  cookieAcceptPolicy: interop.Enum<typeof NSHTTPCookieAcceptPolicy>;

  sortedCookiesUsingDescriptors(sortOrder: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  storeCookiesForTask(cookies: NSArray<interop.Object> | Array<interop.Object>, task: NSURLSessionTask): void;

  getCookiesForTaskCompletionHandler(task: NSURLSessionTask, completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>) => void | null): void;
}

declare class NSUnitIlluminance extends NSDimension implements NSSecureCoding {
  static readonly lux: NSUnitIlluminance;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSError extends NSObject implements NSCopying, NSSecureCoding {
  initWithDomainCodeUserInfo(domain: string, code: number, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  static errorWithDomainCodeUserInfo<This extends abstract new (...args: any) => any>(this: This, domain: string, code: number, dict: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  readonly domain: string;

  readonly code: number;

  readonly userInfo: NSDictionary;

  readonly localizedDescription: string;

  readonly localizedFailureReason: string;

  readonly localizedRecoverySuggestion: string;

  readonly localizedRecoveryOptions: NSArray;

  readonly recoveryAttempter: interop.Object;

  readonly helpAnchor: string;

  readonly underlyingErrors: NSArray;

  static setUserInfoValueProviderForDomainProvider(errorDomain: string, provider: (p1: NSError, p2: string) => interop.Object | null): void;

  static userInfoValueProviderForDomain(errorDomain: string): (p1: NSError, p2: string) => interop.Object | null;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSBundle extends NSObject {
  static readonly mainBundle: NSBundle;

  static bundleWithPath<This extends abstract new (...args: any) => any>(this: This, path: string): InstanceType<This>;

  initWithPath(path: string): this;

  static bundleWithURL<This extends abstract new (...args: any) => any>(this: This, url: NSURL): InstanceType<This>;

  initWithURL(url: NSURL): this;

  static bundleForClass(aClass: interop.Object): NSBundle;

  static bundleWithIdentifier(identifier: string): NSBundle;

  static readonly allBundles: NSArray;

  static readonly allFrameworks: NSArray;

  load(): boolean;

  readonly isLoaded: boolean;

  unload(): boolean;

  preflightAndReturnError(error: interop.PointerConvertible): boolean;

  loadAndReturnError(error: interop.PointerConvertible): boolean;

  readonly bundleURL: NSURL;

  readonly resourceURL: NSURL;

  readonly executableURL: NSURL;

  URLForAuxiliaryExecutable(executableName: string): NSURL;

  readonly privateFrameworksURL: NSURL;

  readonly sharedFrameworksURL: NSURL;

  readonly sharedSupportURL: NSURL;

  readonly builtInPlugInsURL: NSURL;

  readonly appStoreReceiptURL: NSURL;

  readonly bundlePath: string;

  readonly resourcePath: string;

  readonly executablePath: string;

  pathForAuxiliaryExecutable(executableName: string): string;

  readonly privateFrameworksPath: string;

  readonly sharedFrameworksPath: string;

  readonly sharedSupportPath: string;

  readonly builtInPlugInsPath: string;

  static URLForResourceWithExtensionSubdirectoryInBundleWithURL(name: string | null, ext: string | null, subpath: string | null, bundleURL: NSURL): NSURL;

  static URLsForResourcesWithExtensionSubdirectoryInBundleWithURL(ext: string | null, subpath: string | null, bundleURL: NSURL): NSArray;

  URLForResourceWithExtension(name: string | null, ext: string | null): NSURL;

  URLForResourceWithExtensionSubdirectory(name: string | null, ext: string | null, subpath: string | null): NSURL;

  URLForResourceWithExtensionSubdirectoryLocalization(name: string | null, ext: string | null, subpath: string | null, localizationName: string | null): NSURL;

  URLsForResourcesWithExtensionSubdirectory(ext: string | null, subpath: string | null): NSArray;

  URLsForResourcesWithExtensionSubdirectoryLocalization(ext: string | null, subpath: string | null, localizationName: string | null): NSArray;

  static pathForResourceOfTypeInDirectory(name: string | null, ext: string | null, bundlePath: string): string;

  static pathsForResourcesOfTypeInDirectory(ext: string | null, bundlePath: string): NSArray;

  pathForResourceOfType(name: string | null, ext: string | null): string;

  pathForResourceOfTypeInDirectory(name: string | null, ext: string | null, subpath: string | null): string;

  pathForResourceOfTypeInDirectoryForLocalization(name: string | null, ext: string | null, subpath: string | null, localizationName: string | null): string;

  pathsForResourcesOfTypeInDirectory(ext: string | null, subpath: string | null): NSArray;

  pathsForResourcesOfTypeInDirectoryForLocalization(ext: string | null, subpath: string | null, localizationName: string | null): NSArray;

  localizedStringForKeyValueTable(key: string, value: string | null, tableName: string | null): string;

  localizedAttributedStringForKeyValueTable(key: string, value: string | null, tableName: string | null): NSAttributedString;

  readonly bundleIdentifier: string;

  readonly infoDictionary: NSDictionary;

  readonly localizedInfoDictionary: NSDictionary;

  objectForInfoDictionaryKey(key: string): interop.Object;

  classNamed(className: string): interop.Object;

  readonly principalClass: interop.Object;

  readonly preferredLocalizations: NSArray;

  readonly localizations: NSArray;

  readonly developmentLocalization: string;

  static preferredLocalizationsFromArray(localizationsArray: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  static preferredLocalizationsFromArrayForPreferences(localizationsArray: NSArray<interop.Object> | Array<interop.Object>, preferencesArray: NSArray<interop.Object> | Array<interop.Object> | null): NSArray;

  readonly executableArchitectures: NSArray;

  setPreservationPriorityForTags(priority: number, tags: NSSet): void;

  preservationPriorityForTag(tag: string): number;

  loadNibNamedOwnerOptions(name: string, owner: interop.Object | null, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;
}

declare class NSListFormatter extends NSFormatter {
  locale: NSLocale;

  itemFormatter: NSFormatter;

  static localizedStringByJoiningStrings(strings: NSArray<interop.Object> | Array<interop.Object>): string;

  stringFromItems(items: NSArray<interop.Object> | Array<interop.Object>): string;

  stringForObjectValue(obj: interop.Object | null): string;
}

declare class NSUnitInformationStorage extends NSDimension implements NSSecureCoding {
  static readonly bytes: NSUnitInformationStorage;

  static readonly bits: NSUnitInformationStorage;

  static readonly nibbles: NSUnitInformationStorage;

  static readonly yottabytes: NSUnitInformationStorage;

  static readonly zettabytes: NSUnitInformationStorage;

  static readonly exabytes: NSUnitInformationStorage;

  static readonly petabytes: NSUnitInformationStorage;

  static readonly terabytes: NSUnitInformationStorage;

  static readonly gigabytes: NSUnitInformationStorage;

  static readonly megabytes: NSUnitInformationStorage;

  static readonly kilobytes: NSUnitInformationStorage;

  static readonly yottabits: NSUnitInformationStorage;

  static readonly zettabits: NSUnitInformationStorage;

  static readonly exabits: NSUnitInformationStorage;

  static readonly petabits: NSUnitInformationStorage;

  static readonly terabits: NSUnitInformationStorage;

  static readonly gigabits: NSUnitInformationStorage;

  static readonly megabits: NSUnitInformationStorage;

  static readonly kilobits: NSUnitInformationStorage;

  static readonly yobibytes: NSUnitInformationStorage;

  static readonly zebibytes: NSUnitInformationStorage;

  static readonly exbibytes: NSUnitInformationStorage;

  static readonly pebibytes: NSUnitInformationStorage;

  static readonly tebibytes: NSUnitInformationStorage;

  static readonly gibibytes: NSUnitInformationStorage;

  static readonly mebibytes: NSUnitInformationStorage;

  static readonly kibibytes: NSUnitInformationStorage;

  static readonly yobibits: NSUnitInformationStorage;

  static readonly zebibits: NSUnitInformationStorage;

  static readonly exbibits: NSUnitInformationStorage;

  static readonly pebibits: NSUnitInformationStorage;

  static readonly tebibits: NSUnitInformationStorage;

  static readonly gibibits: NSUnitInformationStorage;

  static readonly mebibits: NSUnitInformationStorage;

  static readonly kibibits: NSUnitInformationStorage;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSRelativeDateTimeFormatter extends NSFormatter {
  dateTimeStyle: interop.Enum<typeof NSRelativeDateTimeFormatterStyle>;

  unitsStyle: interop.Enum<typeof NSRelativeDateTimeFormatterUnitsStyle>;

  formattingContext: interop.Enum<typeof NSFormattingContext>;

  calendar: NSCalendar;

  locale: NSLocale;

  localizedStringFromDateComponents(dateComponents: NSDateComponents): string;

  localizedStringFromTimeInterval(timeInterval: number): string;

  localizedStringForDateRelativeToDate(date: NSDate, referenceDate: NSDate): string;

  stringForObjectValue(obj: interop.Object | null): string;
}

declare class NSScanner extends NSObject implements NSCopying {
  readonly string: string;

  scanLocation: number;

  charactersToBeSkipped: NSCharacterSet;

  caseSensitive: boolean;

  locale: interop.Object;

  initWithString(string: string): this;

  scanInt(result: interop.PointerConvertible): boolean;

  scanInteger(result: interop.PointerConvertible): boolean;

  scanLongLong(result: interop.PointerConvertible): boolean;

  scanUnsignedLongLong(result: interop.PointerConvertible): boolean;

  scanFloat(result: interop.PointerConvertible): boolean;

  scanDouble(result: interop.PointerConvertible): boolean;

  scanHexInt(result: interop.PointerConvertible): boolean;

  scanHexLongLong(result: interop.PointerConvertible): boolean;

  scanHexFloat(result: interop.PointerConvertible): boolean;

  scanHexDouble(result: interop.PointerConvertible): boolean;

  scanStringIntoString(string: string, result: interop.PointerConvertible): boolean;

  scanCharactersFromSetIntoString(set: NSCharacterSet, result: interop.PointerConvertible): boolean;

  scanUpToStringIntoString(string: string, result: interop.PointerConvertible): boolean;

  scanUpToCharactersFromSetIntoString(set: NSCharacterSet, result: interop.PointerConvertible): boolean;

  readonly isAtEnd: boolean;

  static scannerWithString<This extends abstract new (...args: any) => any>(this: This, string: string): InstanceType<This>;

  static localizedScannerWithString(string: string): interop.Object;

  scanDecimal(dcm: interop.PointerConvertible): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSMeasurementFormatter extends NSFormatter implements NSSecureCoding {
  unitOptions: interop.Enum<typeof NSMeasurementFormatterUnitOptions>;

  unitStyle: interop.Enum<typeof NSFormattingUnitStyle>;

  locale: NSLocale;

  numberFormatter: NSNumberFormatter;

  stringFromMeasurement(measurement: NSMeasurement): string;

  stringFromUnit(unit: NSUnit): string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSByteCountFormatter extends NSFormatter {
  static stringFromByteCountCountStyle(byteCount: number, countStyle: interop.Enum<typeof NSByteCountFormatterCountStyle>): string;

  stringFromByteCount(byteCount: number): string;

  static stringFromMeasurementCountStyle(measurement: NSMeasurement, countStyle: interop.Enum<typeof NSByteCountFormatterCountStyle>): string;

  stringFromMeasurement(measurement: NSMeasurement): string;

  stringForObjectValue(obj: interop.Object | null): string;

  allowedUnits: interop.Enum<typeof NSByteCountFormatterUnits>;

  countStyle: interop.Enum<typeof NSByteCountFormatterCountStyle>;

  allowsNonnumericFormatting: boolean;

  includesUnit: boolean;

  includesCount: boolean;

  includesActualByteCount: boolean;

  isAdaptive: boolean;

  zeroPadsFractionDigits: boolean;

  formattingContext: interop.Enum<typeof NSFormattingContext>;
}

declare class NSUnitElectricCharge extends NSDimension implements NSSecureCoding {
  static readonly coulombs: NSUnitElectricCharge;

  static readonly megaampereHours: NSUnitElectricCharge;

  static readonly kiloampereHours: NSUnitElectricCharge;

  static readonly ampereHours: NSUnitElectricCharge;

  static readonly milliampereHours: NSUnitElectricCharge;

  static readonly microampereHours: NSUnitElectricCharge;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSDate extends NSObject implements NSCopying, NSSecureCoding {
  readonly timeIntervalSinceReferenceDate: number;

  init(): this;

  initWithTimeIntervalSinceReferenceDate(ti: number): this;

  initWithCoder(coder: NSCoder): this;

  timeIntervalSinceDate(anotherDate: NSDate): number;

  readonly timeIntervalSinceNow: number;

  readonly timeIntervalSince1970: number;

  addTimeInterval(seconds: number): interop.Object;

  dateByAddingTimeInterval(ti: number): this;

  earlierDate(anotherDate: NSDate): NSDate;

  laterDate(anotherDate: NSDate): NSDate;

  compare(other: NSDate): interop.Enum<typeof NSComparisonResult>;

  isEqualToDate(otherDate: NSDate): boolean;

  readonly description: string;

  descriptionWithLocale(locale: interop.Object | null): string;

  static readonly timeIntervalSinceReferenceDate: number;

  static date<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dateWithTimeIntervalSinceNow<This extends abstract new (...args: any) => any>(this: This, secs: number): InstanceType<This>;

  static dateWithTimeIntervalSinceReferenceDate<This extends abstract new (...args: any) => any>(this: This, ti: number): InstanceType<This>;

  static dateWithTimeIntervalSince1970<This extends abstract new (...args: any) => any>(this: This, secs: number): InstanceType<This>;

  static dateWithTimeIntervalSinceDate<This extends abstract new (...args: any) => any>(this: This, secsToBeAdded: number, date: NSDate): InstanceType<This>;

  static readonly distantFuture: NSDate;

  static readonly distantPast: NSDate;

  static readonly now: NSDate;

  initWithTimeIntervalSinceNow(secs: number): this;

  initWithTimeIntervalSince1970(secs: number): this;

  initWithTimeIntervalSinceDate(secsToBeAdded: number, date: NSDate): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSPersonNameComponents extends NSObject implements NSCopying, NSSecureCoding {
  namePrefix: string;

  givenName: string;

  middleName: string;

  familyName: string;

  nameSuffix: string;

  nickname: string;

  phoneticRepresentation: NSPersonNameComponents;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSMeasurement<UnitType = interop.Object> extends NSObject implements NSCopying, NSSecureCoding {
  readonly unit: UnitType;

  readonly doubleValue: number;

  initWithDoubleValueUnit(doubleValue: number, unit: UnitType): this;

  canBeConvertedToUnit(unit: NSUnit): boolean;

  measurementByConvertingToUnit(unit: NSUnit): NSMeasurement;

  measurementByAddingMeasurement(measurement: NSMeasurement): NSMeasurement;

  measurementBySubtractingMeasurement(measurement: NSMeasurement): NSMeasurement;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitAngle extends NSDimension implements NSSecureCoding {
  static readonly degrees: NSUnitAngle;

  static readonly arcMinutes: NSUnitAngle;

  static readonly arcSeconds: NSUnitAngle;

  static readonly radians: NSUnitAngle;

  static readonly gradians: NSUnitAngle;

  static readonly revolutions: NSUnitAngle;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitPressure extends NSDimension implements NSSecureCoding {
  static readonly newtonsPerMetersSquared: NSUnitPressure;

  static readonly gigapascals: NSUnitPressure;

  static readonly megapascals: NSUnitPressure;

  static readonly kilopascals: NSUnitPressure;

  static readonly hectopascals: NSUnitPressure;

  static readonly inchesOfMercury: NSUnitPressure;

  static readonly bars: NSUnitPressure;

  static readonly millibars: NSUnitPressure;

  static readonly millimetersOfMercury: NSUnitPressure;

  static readonly poundsForcePerSquareInch: NSUnitPressure;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSPresentationIntent extends NSObject implements NSCopying, NSSecureCoding {
  readonly intentKind: interop.Enum<typeof NSPresentationIntentKind>;

  readonly parentIntent: NSPresentationIntent;

  static paragraphIntentWithIdentityNestedInsideIntent(identity: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static headerIntentWithIdentityLevelNestedInsideIntent(identity: number, level: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static codeBlockIntentWithIdentityLanguageHintNestedInsideIntent(identity: number, languageHint: string | null, parent: NSPresentationIntent | null): NSPresentationIntent;

  static thematicBreakIntentWithIdentityNestedInsideIntent(identity: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static orderedListIntentWithIdentityNestedInsideIntent(identity: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static unorderedListIntentWithIdentityNestedInsideIntent(identity: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static listItemIntentWithIdentityOrdinalNestedInsideIntent(identity: number, ordinal: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static blockQuoteIntentWithIdentityNestedInsideIntent(identity: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static tableIntentWithIdentityColumnCountAlignmentsNestedInsideIntent(identity: number, columnCount: number, alignments: NSArray<interop.Object> | Array<interop.Object>, parent: NSPresentationIntent | null): NSPresentationIntent;

  static tableHeaderRowIntentWithIdentityNestedInsideIntent(identity: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static tableRowIntentWithIdentityRowNestedInsideIntent(identity: number, row: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  static tableCellIntentWithIdentityColumnNestedInsideIntent(identity: number, column: number, parent: NSPresentationIntent | null): NSPresentationIntent;

  readonly identity: number;

  readonly ordinal: number;

  readonly columnAlignments: NSArray;

  readonly columnCount: number;

  readonly headerLevel: number;

  readonly languageHint: string;

  readonly column: number;

  readonly row: number;

  readonly indentationLevel: number;

  isEquivalentToPresentationIntent(other: NSPresentationIntent): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitFrequency extends NSDimension implements NSSecureCoding {
  static readonly terahertz: NSUnitFrequency;

  static readonly gigahertz: NSUnitFrequency;

  static readonly megahertz: NSUnitFrequency;

  static readonly kilohertz: NSUnitFrequency;

  static readonly hertz: NSUnitFrequency;

  static readonly millihertz: NSUnitFrequency;

  static readonly microhertz: NSUnitFrequency;

  static readonly nanohertz: NSUnitFrequency;

  static readonly framesPerSecond: NSUnitFrequency;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSUnitElectricPotentialDifference extends NSDimension implements NSSecureCoding {
  static readonly megavolts: NSUnitElectricPotentialDifference;

  static readonly kilovolts: NSUnitElectricPotentialDifference;

  static readonly volts: NSUnitElectricPotentialDifference;

  static readonly millivolts: NSUnitElectricPotentialDifference;

  static readonly microvolts: NSUnitElectricPotentialDifference;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSDecimalNumberHandler extends NSObject implements NSDecimalNumberBehaviors, NSCoding {
  static readonly defaultDecimalNumberHandler: NSDecimalNumberHandler;

  initWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero(roundingMode: interop.Enum<typeof NSRoundingMode>, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): this;

  static decimalNumberHandlerWithRoundingModeScaleRaiseOnExactnessRaiseOnOverflowRaiseOnUnderflowRaiseOnDivideByZero<This extends abstract new (...args: any) => any>(this: This, roundingMode: interop.Enum<typeof NSRoundingMode>, scale: number, exact: boolean, overflow: boolean, underflow: boolean, divideByZero: boolean): InstanceType<This>;

  roundingMode(): interop.Enum<typeof NSRoundingMode>;

  scale(): number;

  exceptionDuringOperationErrorLeftOperandRightOperand(operation: string, error: interop.Enum<typeof NSCalculationError>, leftOperand: NSDecimalNumber, rightOperand: NSDecimalNumber | null): NSDecimalNumber;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore
declare class NSKeyedUnarchiver extends NSCoder {
  initForReadingFromDataError(data: NSData, error: interop.PointerConvertible): this;

  static unarchivedObjectOfClassFromDataError(cls: interop.Object, data: NSData, error: interop.PointerConvertible): interop.Object;

  static unarchivedArrayOfObjectsOfClassFromDataError(cls: interop.Object, data: NSData, error: interop.PointerConvertible): NSArray;

  static unarchivedDictionaryWithKeysOfClassObjectsOfClassFromDataError(keyCls: interop.Object, valueCls: interop.Object, data: NSData, error: interop.PointerConvertible): NSDictionary;

  static unarchivedObjectOfClassesFromDataError(classes: NSSet, data: NSData, error: interop.PointerConvertible): interop.Object;

  static unarchivedArrayOfObjectsOfClassesFromDataError(classes: NSSet, data: NSData, error: interop.PointerConvertible): NSArray;

  static unarchivedDictionaryWithKeysOfClassesObjectsOfClassesFromDataError(keyClasses: NSSet, valueClasses: NSSet, data: NSData, error: interop.PointerConvertible): NSDictionary;

  init(): this;

  initForReadingWithData(data: NSData): this;

  static unarchiveObjectWithData(data: NSData): interop.Object;

  static unarchiveTopLevelObjectWithDataError(data: NSData, error: interop.PointerConvertible): interop.Object;

  static unarchiveObjectWithFile(path: string): interop.Object;

  delegate: NSKeyedUnarchiverDelegate;

  finishDecoding(): void;

  static setClassForClassName(cls: interop.Object | null, codedName: string): void;

  setClassForClassName(cls: interop.Object | null, codedName: string): void;

  static classForClassName(codedName: string): interop.Object;

  classForClassName(codedName: string): interop.Object;

  containsValueForKey(key: string): boolean;

  decodeObjectForKey(key: string): interop.Object;

  decodeBoolForKey(key: string): boolean;

  decodeIntForKey(key: string): number;

  decodeInt32ForKey(key: string): number;

  decodeInt64ForKey(key: string): number;

  decodeFloatForKey(key: string): number;

  decodeDoubleForKey(key: string): number;

  decodeBytesForKeyReturnedLength(key: string, lengthp: interop.PointerConvertible): interop.Pointer;

  // @ts-ignore
  requiresSecureCoding: boolean;

  // @ts-ignore
  decodingFailurePolicy: interop.Enum<typeof NSDecodingFailurePolicy>;
}

declare class NSPointerFunctions extends NSObject implements NSCopying {
  initWithOptions(options: interop.Enum<typeof NSPointerFunctionsOptions>): this;

  static pointerFunctionsWithOptions(options: interop.Enum<typeof NSPointerFunctionsOptions>): NSPointerFunctions;

  hashFunction: (p1: interop.PointerConvertible, p2: (p1: interop.PointerConvertible) => number) => number | null;

  isEqualFunction: (p1: interop.PointerConvertible, p2: interop.PointerConvertible, p3: (p1: interop.PointerConvertible) => number) => boolean | null;

  sizeFunction: (p1: interop.PointerConvertible) => number;

  descriptionFunction: (p1: interop.PointerConvertible) => string | null;

  relinquishFunction: (p1: interop.PointerConvertible, p2: (p1: interop.PointerConvertible) => number) => void | null;

  acquireFunction: (p1: interop.PointerConvertible, p2: (p1: interop.PointerConvertible) => number, p3: boolean) => interop.Pointer | null;

  usesStrongWriteBarrier: boolean;

  usesWeakReadAndWriteBarriers: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSUnit extends NSObject implements NSCopying, NSSecureCoding {
  readonly symbol: string;

  initWithSymbol(symbol: string): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSSimpleCString extends NSString {
}

declare class NSMetadataItem extends NSObject {
  valueForAttribute(key: string): interop.Object;

  valuesForAttributes(keys: NSArray<interop.Object> | Array<interop.Object>): NSDictionary;

  readonly attributes: NSArray;
}

declare class NSTimer extends NSObject {
  static timerWithTimeIntervalInvocationRepeats(ti: number, invocation: NSInvocation, yesOrNo: boolean): NSTimer;

  static scheduledTimerWithTimeIntervalInvocationRepeats(ti: number, invocation: NSInvocation, yesOrNo: boolean): NSTimer;

  static timerWithTimeIntervalTargetSelectorUserInfoRepeats(ti: number, aTarget: interop.Object, aSelector: string, userInfo: interop.Object | null, yesOrNo: boolean): NSTimer;

  static scheduledTimerWithTimeIntervalTargetSelectorUserInfoRepeats(ti: number, aTarget: interop.Object, aSelector: string, userInfo: interop.Object | null, yesOrNo: boolean): NSTimer;

  static timerWithTimeIntervalRepeatsBlock(interval: number, repeats: boolean, block: (p1: NSTimer) => void): NSTimer;

  static scheduledTimerWithTimeIntervalRepeatsBlock(interval: number, repeats: boolean, block: (p1: NSTimer) => void): NSTimer;

  initWithFireDateIntervalRepeatsBlock(date: NSDate, interval: number, repeats: boolean, block: (p1: NSTimer) => void): this;

  initWithFireDateIntervalTargetSelectorUserInfoRepeats(date: NSDate, ti: number, t: interop.Object, s: string, ui: interop.Object | null, rep: boolean): this;

  fire(): void;

  fireDate: NSDate;

  readonly timeInterval: number;

  tolerance: number;

  invalidate(): void;

  readonly isValid: boolean;

  readonly userInfo: interop.Object;
}

declare class NSURLComponents extends NSObject implements NSCopying {
  init(): this;

  initWithURLResolvingAgainstBaseURL(url: NSURL, resolve: boolean): this;

  static componentsWithURLResolvingAgainstBaseURL<This extends abstract new (...args: any) => any>(this: This, url: NSURL, resolve: boolean): InstanceType<This>;

  initWithString(URLString: string): this;

  static componentsWithString<This extends abstract new (...args: any) => any>(this: This, URLString: string): InstanceType<This>;

  initWithStringEncodingInvalidCharacters(URLString: string, encodingInvalidCharacters: boolean): this;

  static componentsWithStringEncodingInvalidCharacters<This extends abstract new (...args: any) => any>(this: This, URLString: string, encodingInvalidCharacters: boolean): InstanceType<This>;

  readonly URL: NSURL;

  URLRelativeToURL(baseURL: NSURL | null): NSURL;

  readonly string: string;

  scheme: string;

  user: string;

  password: string;

  host: string;

  port: NSNumber;

  path: string;

  query: string;

  fragment: string;

  percentEncodedUser: string;

  percentEncodedPassword: string;

  percentEncodedHost: string;

  percentEncodedPath: string;

  percentEncodedQuery: string;

  percentEncodedFragment: string;

  encodedHost: string;

  readonly rangeOfScheme: _NSRange;

  readonly rangeOfUser: _NSRange;

  readonly rangeOfPassword: _NSRange;

  readonly rangeOfHost: _NSRange;

  readonly rangeOfPort: _NSRange;

  readonly rangeOfPath: _NSRange;

  readonly rangeOfQuery: _NSRange;

  readonly rangeOfFragment: _NSRange;

  get queryItems(): NSArray;
  set queryItems(value: NSArray<interop.Object> | Array<interop.Object>);

  get percentEncodedQueryItems(): NSArray;
  set percentEncodedQueryItems(value: NSArray<interop.Object> | Array<interop.Object>);

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSCoder extends NSObject {
  encodeValueOfObjCTypeAt(type: string, addr: interop.PointerConvertible): void;

  encodeDataObject(data: NSData): void;

  decodeDataObject(): NSData;

  decodeValueOfObjCTypeAtSize(type: string, data: interop.PointerConvertible, size: number): void;

  versionForClassName(className: string): number;

  encodeObject(object: interop.Object | null): void;

  encodeRootObject(rootObject: interop.Object): void;

  encodeBycopyObject(anObject: interop.Object | null): void;

  encodeByrefObject(anObject: interop.Object | null): void;

  encodeConditionalObject(object: interop.Object | null): void;

  encodeValuesOfObjCTypes(types: string): void;

  encodeArrayOfObjCTypeCountAt(type: string, count: number, array: interop.PointerConvertible): void;

  encodeBytesLength(byteaddr: interop.PointerConvertible, length: number): void;

  decodeObject(): interop.Object;

  decodeTopLevelObjectAndReturnError(error: interop.PointerConvertible): interop.Object;

  decodeValuesOfObjCTypes(types: string): void;

  decodeArrayOfObjCTypeCountAt(itemType: string, count: number, array: interop.PointerConvertible): void;

  decodeBytesWithReturnedLength(lengthp: interop.PointerConvertible): interop.Pointer;

  setObjectZone(zone: interop.PointerConvertible): void;

  objectZone(): interop.Pointer;

  readonly systemVersion: number;

  readonly allowsKeyedCoding: boolean;

  encodeObjectForKey(object: interop.Object | null, key: string): void;

  encodeConditionalObjectForKey(object: interop.Object | null, key: string): void;

  encodeBoolForKey(value: boolean, key: string): void;

  encodeIntForKey(value: number, key: string): void;

  encodeInt32ForKey(value: number, key: string): void;

  encodeInt64ForKey(value: number, key: string): void;

  encodeFloatForKey(value: number, key: string): void;

  encodeDoubleForKey(value: number, key: string): void;

  encodeBytesLengthForKey(bytes: interop.PointerConvertible, length: number, key: string): void;

  containsValueForKey(key: string): boolean;

  decodeObjectForKey(key: string): interop.Object;

  decodeTopLevelObjectForKeyError(key: string, error: interop.PointerConvertible): interop.Object;

  decodeBoolForKey(key: string): boolean;

  decodeIntForKey(key: string): number;

  decodeInt32ForKey(key: string): number;

  decodeInt64ForKey(key: string): number;

  decodeFloatForKey(key: string): number;

  decodeDoubleForKey(key: string): number;

  decodeBytesForKeyReturnedLength(key: string, lengthp: interop.PointerConvertible): interop.Pointer;

  encodeIntegerForKey(value: number, key: string): void;

  decodeIntegerForKey(key: string): number;

  readonly requiresSecureCoding: boolean;

  decodeObjectOfClassForKey(aClass: interop.Object, key: string): interop.Object;

  decodeTopLevelObjectOfClassForKeyError(aClass: interop.Object, key: string, error: interop.PointerConvertible): interop.Object;

  decodeArrayOfObjectsOfClassForKey(cls: interop.Object, key: string): NSArray;

  decodeDictionaryWithKeysOfClassObjectsOfClassForKey(keyCls: interop.Object, objectCls: interop.Object, key: string): NSDictionary;

  decodeObjectOfClassesForKey(classes: NSSet | null, key: string): interop.Object;

  decodeTopLevelObjectOfClassesForKeyError(classes: NSSet | null, key: string, error: interop.PointerConvertible): interop.Object;

  decodeArrayOfObjectsOfClassesForKey(classes: NSSet, key: string): NSArray;

  decodeDictionaryWithKeysOfClassesObjectsOfClassesForKey(keyClasses: NSSet, objectClasses: NSSet, key: string): NSDictionary;

  decodePropertyListForKey(key: string): interop.Object;

  readonly allowedClasses: NSSet;

  failWithError(error: NSError): void;

  readonly decodingFailurePolicy: interop.Enum<typeof NSDecodingFailurePolicy>;

  readonly error: NSError;

  decodeValueOfObjCTypeAt(type: string, data: interop.PointerConvertible): void;

  encodeCMTimeForKey(time: CMTime, key: string): void;

  decodeCMTimeForKey(key: string): CMTime;

  encodeCMTimeRangeForKey(timeRange: CMTimeRange, key: string): void;

  decodeCMTimeRangeForKey(key: string): CMTimeRange;

  encodeCMTimeMappingForKey(timeMapping: CMTimeMapping, key: string): void;

  decodeCMTimeMappingForKey(key: string): CMTimeMapping;

  encodeCGPointForKey(point: CGPoint, key: string): void;

  encodeCGVectorForKey(vector: CGVector, key: string): void;

  encodeCGSizeForKey(size: CGSize, key: string): void;

  encodeCGRectForKey(rect: CGRect, key: string): void;

  encodeCGAffineTransformForKey(transform: CGAffineTransform, key: string): void;

  encodeUIEdgeInsetsForKey(insets: UIEdgeInsets, key: string): void;

  encodeDirectionalEdgeInsetsForKey(insets: NSDirectionalEdgeInsets, key: string): void;

  encodeUIOffsetForKey(offset: UIOffset, key: string): void;

  decodeCGPointForKey(key: string): CGPoint;

  decodeCGVectorForKey(key: string): CGVector;

  decodeCGSizeForKey(key: string): CGSize;

  decodeCGRectForKey(key: string): CGRect;

  decodeCGAffineTransformForKey(key: string): CGAffineTransform;

  decodeUIEdgeInsetsForKey(key: string): UIEdgeInsets;

  decodeDirectionalEdgeInsetsForKey(key: string): NSDirectionalEdgeInsets;

  decodeUIOffsetForKey(key: string): UIOffset;
}

declare class NSMutableString extends NSString {
  replaceCharactersInRangeWithString(range: _NSRange, aString: string): void;

  insertStringAtIndex(aString: string, loc: number): void;

  deleteCharactersInRange(range: _NSRange): void;

  appendString(aString: string): void;

  appendFormat(format: string): void;

  setString(aString: string): void;

  replaceOccurrencesOfStringWithStringOptionsRange(target: string, replacement: string, options: interop.Enum<typeof NSStringCompareOptions>, searchRange: _NSRange): number;

  applyTransformReverseRangeUpdatedRange(transform: string, reverse: boolean, range: _NSRange, resultingRange: interop.PointerConvertible): boolean;

  initWithCapacity(capacity: number): NSMutableString;

  static stringWithCapacity(capacity: number): NSMutableString;
}

// @ts-ignore
declare class NSMutableCharacterSet extends NSCharacterSet implements NSCopying, NSMutableCopying, NSSecureCoding {
  addCharactersInRange(aRange: _NSRange): void;

  removeCharactersInRange(aRange: _NSRange): void;

  addCharactersInString(aString: string): void;

  removeCharactersInString(aString: string): void;

  formUnionWithCharacterSet(otherSet: NSCharacterSet): void;

  formIntersectionWithCharacterSet(otherSet: NSCharacterSet): void;

  invert(): void;

  // @ts-ignore
  static readonly controlCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly whitespaceCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly whitespaceAndNewlineCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly decimalDigitCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly letterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly lowercaseLetterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly uppercaseLetterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly nonBaseCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly alphanumericCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly decomposableCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly illegalCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly punctuationCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly capitalizedLetterCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly symbolCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static readonly newlineCharacterSet: NSMutableCharacterSet;

  // @ts-ignore
  static characterSetWithRange(aRange: _NSRange): NSMutableCharacterSet;

  // @ts-ignore
  static characterSetWithCharactersInString(aString: string): NSMutableCharacterSet;

  // @ts-ignore
  static characterSetWithBitmapRepresentation(data: NSData): NSMutableCharacterSet;

  // @ts-ignore
  static characterSetWithContentsOfFile(fName: string): NSMutableCharacterSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSEnumerator<ObjectType = interop.Object> extends NSObject implements NSFastEnumeration {
  nextObject(): ObjectType;

  readonly allObjects: NSArray;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;
}

declare class NSDateComponentsFormatter extends NSFormatter {
  stringForObjectValue(obj: interop.Object | null): string;

  stringFromDateComponents(components: NSDateComponents): string;

  stringFromDateToDate(startDate: NSDate, endDate: NSDate): string;

  stringFromTimeInterval(ti: number): string;

  static localizedStringFromDateComponentsUnitsStyle(components: NSDateComponents, unitsStyle: interop.Enum<typeof NSDateComponentsFormatterUnitsStyle>): string;

  unitsStyle: interop.Enum<typeof NSDateComponentsFormatterUnitsStyle>;

  allowedUnits: interop.Enum<typeof NSCalendarUnit>;

  zeroFormattingBehavior: interop.Enum<typeof NSDateComponentsFormatterZeroFormattingBehavior>;

  calendar: NSCalendar;

  referenceDate: NSDate;

  allowsFractionalUnits: boolean;

  maximumUnitCount: number;

  collapsesLargestUnit: boolean;

  includesApproximationPhrase: boolean;

  includesTimeRemainingPhrase: boolean;

  formattingContext: interop.Enum<typeof NSFormattingContext>;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;
}

declare class NSConstantString extends NSSimpleCString {
}

declare class NSMassFormatter extends NSFormatter {
  numberFormatter: NSNumberFormatter;

  unitStyle: interop.Enum<typeof NSFormattingUnitStyle>;

  isForPersonMassUse: boolean;

  stringFromValueUnit(value: number, unit: interop.Enum<typeof NSMassFormatterUnit>): string;

  stringFromKilograms(numberInKilograms: number): string;

  unitStringFromValueUnit(value: number, unit: interop.Enum<typeof NSMassFormatterUnit>): string;

  unitStringFromKilogramsUsedUnit(numberInKilograms: number, unitp: interop.PointerConvertible): string;

  getObjectValueForStringErrorDescription(obj: interop.PointerConvertible, string: string, error: interop.PointerConvertible): boolean;
}

declare class NSMutableSet<ObjectType = interop.Object> extends NSSet {
  addObject(object: ObjectType): void;

  removeObject(object: ObjectType): void;

  initWithCoder(coder: NSCoder): this;

  init(): this;

  initWithCapacity(numItems: number): this;

  addObjectsFromArray(array: NSArray<interop.Object> | Array<interop.Object>): void;

  intersectSet(otherSet: NSSet): void;

  minusSet(otherSet: NSSet): void;

  removeAllObjects(): void;

  unionSet(otherSet: NSSet): void;

  setSet(otherSet: NSSet): void;

  static setWithCapacity<ObjectType, This extends abstract new (...args: any) => any>(this: This, numItems: number): InstanceType<This>;

  filterUsingPredicate(predicate: NSPredicate): void;
}

declare class NSMutableIndexSet extends NSIndexSet {
  addIndexes(indexSet: NSIndexSet): void;

  removeIndexes(indexSet: NSIndexSet): void;

  removeAllIndexes(): void;

  addIndex(value: number): void;

  removeIndex(value: number): void;

  addIndexesInRange(range: _NSRange): void;

  removeIndexesInRange(range: _NSRange): void;

  shiftIndexesStartingAtIndexBy(index: number, delta: number): void;
}

