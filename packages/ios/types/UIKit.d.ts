/// <reference types="@nativescript/objc-node-api" />
/// <reference path="./Runtime.d.ts" />
/// <reference path="./Foundation.d.ts" />

declare const UITableViewIndexSearch: string;

declare const UIPasteboardTypeAutomatic: string;

declare const NSTabColumnTerminatorsAttributeName: string;

declare const UITextContentTypeJobTitle: string;

declare const UIApplicationDidChangeStatusBarOrientationNotification: string;

declare const UITextContentTypeCreditCardExpiration: string;

declare const UIMenuServices: string;

declare const NSUnderlinePatternDash: interop.Enum<typeof NSUnderlineStyle>;

declare const UIStackViewSpacingUseDefault: number;

declare const UITableViewSelectionDidChangeNotification: string;

declare const UIDeviceOrientationDidChangeNotification: string;

declare const UIPointerAccessoryPositionTop: UIPointerAccessoryPosition;

declare const UINibProxiedObjectsKey: string;

declare const UIImagePickerControllerOriginalImage: string;

declare const UIActivityTypeMessage: string;

declare const UIAccessibilitySpeechAttributePitch: string;

declare const UIApplicationStateRestorationUserInterfaceIdiomKey: string;

declare const UILayoutPriorityDragThatCannotResizeScene: number;

declare const UIAccessibilityUnfocusedElementKey: string;

declare const UIAccessibilityTraitCausesPageTurn: number;

declare const UIFontDescriptorSystemDesignDefault: string;

declare const UIAccessibilityTraitKeyboardKey: number;

declare const UIKeyInputUpArrow: string;

declare const UIAccessibilityTextAttributeContext: string;

declare const UIWindowLevelStatusBar: number;

declare const UITransitionContextFromViewControllerKey: string;

declare const UIFontWidthExpanded: number;

declare const UIActionPaste: string;

declare const UIAccessibilityTraitPlaysSound: number;

declare const UIKeyboardWillChangeFrameNotification: string;

declare const NSControlCharacterHorizontalTabAction: number;

declare const UIFontTextStyleTitle1: string;

declare const NSWritingDirectionAttributeName: string;

declare const UIConfigurationColorTransformerGrayscale: (p1: UIColor) => UIColor;

declare const UIMenuControllerDidShowMenuNotification: string;

declare const UIKeyInputF11: string;

declare const UIImagePickerControllerMediaType: string;

declare const UIAccessibilityHearingDevicePairedEarDidChangeNotification: string;

declare const UIApplicationWillEnterForegroundNotification: string;

declare const UIActivityItemsConfigurationInteractionShare: string;

declare const UIScreenCapturedDidChangeNotification: string;

declare const UIPasteboardDetectionPatternNumber: string;

declare const UIAccessibilityInvertColorsStatusDidChangeNotification: string;

declare const NSDirectionalEdgeInsetsZero: NSDirectionalEdgeInsets;

declare const UIActivityTypeAddToHomeScreen: string;

declare const UIMenuShare: string;

declare const UIActivityTypeCollaborationInviteWithLink: string;

declare const UIApplicationUserDidTakeScreenshotNotification: string;

declare const UIMenuTransformations: string;

declare const UIAccessibilityButtonShapesEnabledStatusDidChangeNotification: string;

declare const NSTextListMarkerDecimal: string;

declare const NSStrokeWidthAttributeName: string;

declare const UIPointerAccessoryPositionRight: UIPointerAccessoryPosition;

declare const NSTextListMarkerLowercaseLatin: string;

declare const UIActivityItemsConfigurationPreviewIntentFullSize: string;

declare const UITextContentTypeMiddleName: string;

declare const UIFontWeightLight: number;

declare const UIFontDescriptorNameAttribute: string;

declare const UIAccessibilityTextualContextFileSystem: string;

declare const UIKeyboardFrameEndUserInfoKey: string;

declare const NSTextListMarkerLowercaseAlpha: string;

declare const UIActivityTypeCopyToPasteboard: string;

declare const UIApplicationLaunchOptionsBluetoothCentralsKey: string;

declare const NSAttachmentCharacter: number;

declare const UIKeyboardDidChangeFrameNotification: string;

declare const NSTextListMarkerLowercaseHexadecimal: string;

declare const UIKeyboardCenterBeginUserInfoKey: string;

declare const UIPrintErrorDomain: string;

declare const NSTextListMarkerUppercaseHexadecimal: string;

declare const NSTextContentStorageUnsupportedAttributeAddedNotification: string;

declare const UIFontTextStyleFootnote: string;

declare const UIAccessibilityScreenChangedNotification: number;

declare const UISceneWillEnterForegroundNotification: string;

declare const UIImagePickerControllerMediaURL: string;

declare const UIFontTextStyleSubheadline: string;

declare const UIActivityTypePostToFlickr: string;

declare const UITextWritingDirectionLeftToRight: interop.Enum<typeof NSWritingDirection>;

declare const UIAccessibilityElementFocusedNotification: string;

declare const UIAccessibilityNotificationVoiceOverIdentifier: string;

declare const UIPointerAccessoryPositionLeft: UIPointerAccessoryPosition;

declare const UIMenuHelp: string;

declare const UIPointerAccessoryPositionBottom: UIPointerAccessoryPosition;

declare const UIActivityTypeOpenInIBooks: string;

declare const UIAccessibilitySpeakSelectionStatusDidChangeNotification: string;

declare const UIFontWeightBold: number;

declare const NSTextListMarkerBox: string;

declare const NSUnderlinePatternSolid: interop.Enum<typeof NSUnderlineStyle>;

declare const UIFontTextStyleHeadline: string;

declare const UIActivityTypeMarkupAsPDF: string;

declare const UIActivityTypeAirDrop: string;

declare const UIActivityTypePostToTencentWeibo: string;

declare const UIActivityTypePostToVimeo: string;

declare const UIApplicationLaunchOptionsUserActivityDictionaryKey: string;

declare const UIActivityTypeAddToReadingList: string;

declare const UIActivityTypeAssignToContact: string;

declare const UIActivityTypePrint: string;

declare const UIActivityTypePostToTwitter: string;

declare const UIActivityTypePostToFacebook: string;

declare const UIDocumentBrowserErrorDomain: string;

declare const NSTextListMarkerUppercaseLatin: string;

declare const NSTextListMarkerUppercaseAlpha: string;

declare const UIScrollViewDecelerationRateFast: number;

declare const NSTextListMarkerOctal: string;

declare const NSTextListMarkerSquare: string;

declare const NSTextListMarkerHyphen: string;

declare const NSTextListMarkerDisc: string;

declare const UICollectionElementKindSectionFooter: string;

declare const NSTextListMarkerDiamond: string;

declare const NSTextListMarkerCircle: string;

declare const UIPointerAccessoryPositionTopLeft: UIPointerAccessoryPosition;

declare const UIPointerAccessoryPositionBottomLeft: UIPointerAccessoryPosition;

declare const UIPointerAccessoryPositionBottomRight: UIPointerAccessoryPosition;

declare const UITextItemTagAttributeName: string;

declare const UIFloatRangeZero: UIFloatRange;

declare const UISheetPresentationControllerDetentInactive: number;

declare const UISheetPresentationControllerDetentIdentifierLarge: string;

declare const UISheetPresentationControllerDetentIdentifierMedium: string;

declare const NSControlCharacterParagraphBreakAction: number;

declare const NSControlCharacterWhitespaceAction: number;

declare const NSControlCharacterZeroAdvancementAction: number;

declare const NSTextStorageDidProcessEditingNotification: string;

declare const NSTextStorageWillProcessEditingNotification: string;

declare const UIApplicationDidFinishLaunchingNotification: string;

declare const UIActivityItemsConfigurationPreviewIntentThumbnail: string;

declare const UIActivityItemsConfigurationMetadataKeyTitle: string;

declare const UIKeyboardBoundsUserInfoKey: string;

declare const UIScreenModeDidChangeNotification: string;

declare const UIKeyboardCenterEndUserInfoKey: string;

declare const UIKeyboardFrameBeginUserInfoKey: string;

declare const UIKeyboardDidHideNotification: string;

declare const UIKeyboardWillHideNotification: string;

declare const UIKeyboardWillShowNotification: string;

declare const UIWindowDidBecomeHiddenNotification: string;

declare const UIWindowLevelAlert: number;

declare const UIWindowLevelNormal: number;

declare const UITextViewTextDidEndEditingNotification: string;

declare const UITextViewTextDidBeginEditingNotification: string;

declare const UISegmentedControlNoSegment: number;

declare const UITransitionContextFromViewKey: string;

declare const UIScreenReferenceDisplayModeStatusDidChangeNotification: string;

declare const UIScreenDidConnectNotification: string;

declare const UIPasteboardTypeListColor: NSArray;

declare const UIPasteboardTypeListImage: NSArray;

declare const UIPasteboardTypeListURL: NSArray;

declare const UIPasteboardTypeListString: NSArray;

declare const UIPasteboardRemovedNotification: string;

declare const UIPasteboardChangedNotification: string;

declare const UIPasteboardOptionLocalOnly: string;

declare const UIPasteboardOptionExpirationDate: string;

declare const UIPasteboardDetectionPatternEmailAddress: string;

declare const UIPasteboardDetectionPatternPhoneNumber: string;

declare const UITransitionContextToViewKey: string;

declare const UIPasteboardDetectionPatternProbableWebSearch: string;

declare const UIAccessibilityTextAttributeCustom: string;

declare const UIPasteboardDetectionPatternProbableWebURL: string;

declare const UIPageViewControllerOptionInterPageSpacingKey: string;

declare const UINibExternalObjects: string;

declare const UIMenuControllerMenuFrameDidChangeNotification: string;

declare const UIMenuControllerDidHideMenuNotification: string;

declare const UIMenuControllerWillShowMenuNotification: string;

declare const UIWindowSceneSessionRoleExternalDisplayNonInteractive: string;

declare const UIWindowSceneSessionRoleApplication: string;

declare const UIUserNotificationActionResponseTypedTextKey: string;

declare const UIImagePickerControllerImageURL: string;

declare const UIPasteboardChangedTypesRemovedKey: string;

declare const UIImagePickerControllerPHAsset: string;

declare const UIImagePickerControllerMediaMetadata: string;

declare const UIImagePickerControllerReferenceURL: string;

declare const NSUserActivityDocumentURLKey: string;

declare const UIDocumentStateChangedNotification: string;

declare const UIListContentImageStandardDimension: number;

declare const UIListSeparatorAutomaticInsets: NSDirectionalEdgeInsets;

declare const UITableViewAutomaticDimension: number;

declare const UICellAccessoryStandardDimension: number;

declare const UICollectionLayoutSectionOrthogonalScrollingDecelerationRateNormal: number;

declare const UICollectionLayoutSectionOrthogonalScrollingDecelerationRateAutomatic: number;

declare const UICollectionViewFlowLayoutAutomaticSize: CGSize;

declare const UICollectionElementKindSectionHeader: string;

declare const UIConfigurationColorTransformerMonochromeTint: (p1: UIColor) => UIColor;

declare const UIConfigurationColorTransformerPreferredTint: (p1: UIColor) => UIColor;

declare const UIAccessibilityShouldDifferentiateWithoutColorDidChangeNotification: string;

declare const UIAccessibilityTraitToggleButton: number;

declare const UIAccessibilityShakeToUndoDidChangeNotification: string;

declare const UIActivityTypeSaveToCameraRoll: string;

declare const UIApplicationKeyboardExtensionPointIdentifier: string;

declare const UIAccessibilitySpeakScreenStatusDidChangeNotification: string;

declare const UIAccessibilitySwitchControlStatusDidChangeNotification: string;

declare const UIFontDescriptorSizeAttribute: string;

declare const UIAccessibilityReduceTransparencyStatusDidChangeNotification: string;

declare const UIAccessibilityBoldTextStatusDidChangeNotification: string;

declare const UIAccessibilityGuidedAccessStatusDidChangeNotification: string;

declare const UIAccessibilityClosedCaptioningStatusDidChangeNotification: string;

declare const UIViewControllerHierarchyInconsistencyException: string;

declare const UIActivityTypeSharePlay: string;

declare const UISceneDidActivateNotification: string;

declare const UIApplicationStateRestorationSystemVersionKey: string;

declare const UIApplicationOpenExternalURLOptionsEventAttributionKey: string;

declare const UIApplicationOpenURLOptionsOpenInPlaceKey: string;

declare const UIApplicationOpenURLOptionsAnnotationKey: string;

declare const UIApplicationLaunchOptionsUserActivityTypeKey: string;

declare const UIApplicationLaunchOptionsEventAttributionKey: string;

declare const UIApplicationLaunchOptionsNewsstandDownloadsKey: string;

declare const UIApplicationLaunchOptionsAnnotationKey: string;

declare const UIApplicationLaunchOptionsLocalNotificationKey: string;

declare const UIApplicationLaunchOptionsRemoteNotificationKey: string;

declare const UIApplicationLaunchOptionsSourceApplicationKey: string;

declare const UIApplicationLaunchOptionsURLKey: string;

declare const UIApplicationDidChangeStatusBarFrameNotification: string;

declare const NSStrikethroughColorAttributeName: string;

declare const UIApplicationWillChangeStatusBarFrameNotification: string;

declare const UIApplicationDidReceiveMemoryWarningNotification: string;

declare const UIApplicationWillResignActiveNotification: string;

declare const UIApplicationBackgroundFetchIntervalMinimum: number;

declare const UITextFieldDidEndEditingReasonKey: string;

declare const UITextFieldTextDidChangeNotification: string;

declare const UIFontTextStyleCaption1: string;

declare const UITextAttributeTextShadowOffset: string;

declare const UITextWritingDirectionRightToLeft: interop.Enum<typeof NSWritingDirection>;

declare const UITextInputCurrentInputModeDidChangeNotification: string;

declare const UITextInputTextColorKey: string;

declare const UISceneDidEnterBackgroundNotification: string;

declare const UITextInputTextBackgroundColorKey: string;

declare const UITextContentTypeCellularIMEI: string;

declare const UITextContentTypeCreditCardExpirationMonth: string;

declare const UIKeyInputF8: string;

declare const UITextFieldTextDidEndEditingNotification: string;

declare const UITextContentTypeCreditCardMiddleName: string;

declare const UITextContentTypeBirthdateMonth: string;

declare const UITextContentTypeDateTime: string;

declare const UITextContentTypeFlightNumber: string;

declare const UITextContentTypeShipmentTrackingNumber: string;

declare const UITextContentTypeCreditCardNumber: string;

declare const UITextContentTypeTelephoneNumber: string;

declare const UITextContentTypeAddressCityAndState: string;

declare const UITextContentTypeStreetAddressLine2: string;

declare const UITextContentTypeFullStreetAddress: string;

declare const UITextContentTypeLocation: string;

declare const UITextContentTypeOrganizationName: string;

declare const UIActivityItemsConfigurationMetadataKeyLinkPresentationMetadata: string;

declare const UITextContentTypeFamilyName: string;

declare const UITextContentTypeNamePrefix: string;

declare const UITextContentTypeName: string;

declare const UIScrollViewDecelerationRateNormal: number;

declare const UIActionPasteAndSearch: string;

declare const UILayoutFittingExpandedSize: CGSize;

declare const UIViewNoIntrinsicMetric: number;

declare const UIFocusUpdateAnimationCoordinatorKey: string;

declare const UIFocusDidUpdateNotification: string;

declare const UIWindowDidResignKeyNotification: string;

declare const UIFocusGroupPriorityCurrentlyFocused: number;

declare const UIFocusGroupPriorityPreviouslyFocused: number;

declare const UIContentSizeCategoryNewValueKey: string;

declare const UIContentSizeCategoryDidChangeNotification: string;

declare const UITextContentTypeCountryName: string;

declare const UIContentSizeCategoryAccessibilityLarge: string;

declare const UIContentSizeCategoryAccessibilityMedium: string;

declare const UIDeviceProximityStateDidChangeNotification: string;

declare const UIKeyInputRightArrow: string;

declare const UIKeyInputF9: string;

declare const UIKeyInputF7: string;

declare const UIKeyInputPageUp: string;

declare const UIKeyInputEscape: string;

declare const UIKeyInputLeftArrow: string;

declare const UILargeContentViewerInteractionEnabledStatusDidChangeNotification: string;

declare const UIMenuMinimizeAndZoom: string;

declare const UIMenuFullscreen: string;

declare const UIMenuAlignment: string;

declare const UIMenuWritingDirection: string;

declare const UIMenuTextStylePasteboard: string;

declare const UIMenuTextColor: string;

declare const UIMenuTextSize: string;

declare const UITextInputTextFontKey: string;

declare const UIMenuSubstitutionOptions: string;

declare const UIMenuSubstitutionsPanel: string;

declare const UIMenuSpellingOptions: string;

declare const UIContentSizeCategoryExtraLarge: string;

declare const UIMenuSpellingPanel: string;

declare const UIMenuSpelling: string;

declare const UIMenuTextStyle: string;

declare const UINavigationControllerHideShowBarDuration: number;

declare const UIMenuUndoRedo: string;

declare const UIMenuEdit: string;

declare const UIMenuApplication: string;

declare const UIFontTextStyleCaption2: string;

declare const UIFontTextStyleBody: string;

declare const UIAccessibilityGrayscaleStatusDidChangeNotification: string;

declare const UIFontFeatureTypeIdentifierKey: string;

declare const UIFontDescriptorTraitsAttribute: string;

declare const UIFontWidthCompressed: number;

declare const UIFontWidthCondensed: number;

declare const UIFontWeightBlack: number;

declare const UIFontWeightHeavy: number;

declare const UIFontWeightRegular: number;

declare const UIKeyInputPageDown: string;

declare const UIFontSlantTrait: string;

declare const UIFontWeightTrait: string;

declare const UIFontSymbolicTrait: string;

declare const UIFontDescriptorVisibleNameAttribute: string;

declare const UIFontDescriptorFaceAttribute: string;

declare const UIApplicationOpenURLOptionsSourceApplicationKey: string;

declare const UIFontDescriptorSystemDesignMonospaced: string;

declare const UIFontDescriptorSystemDesignRounded: string;

declare const UIViewControllerShowDetailTargetDidChangeNotification: string;

declare const UIFontTextStyleLargeTitle: string;

declare const UIFontWidthTrait: string;

declare const UITextContentTypeURL: string;

declare const UIPasteboardDetectionPatternFlightNumber: string;

declare const UIMenuStandardEdit: string;

declare const UIMenuSubstitutions: string;

declare const UIPointerAccessoryPositionTopRight: UIPointerAccessoryPosition;

declare const UISceneErrorDomain: string;

declare const UIFontDescriptorTextStyleAttribute: string;

declare const UIKeyboardAnimationDurationUserInfoKey: string;

declare const UIFontDescriptorFixedAdvanceAttribute: string;

declare const UITextContentTypeEmailAddress: string;

declare const UIFontDescriptorFeatureSettingsAttribute: string;

declare const UIApplicationOpenSettingsURLString: string;

declare const UIMenuRoot: string;

declare const UITextContentTypePostalCode: string;

declare const UIAccessibilityFocusedElementKey: string;

declare const UIDeviceBatteryLevelDidChangeNotification: string;

declare const UIFontTextStyleExtraLargeTitle: string;

declare const UIAccessibilityTextAttributeHeadingLevel: string;

declare const UIApplicationOpenURLOptionUniversalLinksOnly: string;

declare const UIMenuAbout: string;

declare const UIFontWeightUltraLight: number;

declare const UILayoutPriorityRequired: number;

declare const UITextFieldTextDidBeginEditingNotification: string;

declare const UIAccessibilityTraitNotEnabled: number;

declare const UIKeyInputF4: string;

declare const UITextContentTypeCreditCardFamilyName: string;

declare const UITextContentTypeUsername: string;

declare const NSLinkAttributeName: string;

declare const UIAccessibilityResumeAssistiveTechnologyNotification: number;

declare const UITextContentTypeNewPassword: string;

declare const UIMenuPrint: string;

declare const NSTextLayoutSectionsAttribute: string;

declare const UILayoutFittingCompressedSize: CGSize;

declare const UIApplicationOpenURLOptionsEventAttributionKey: string;

declare const UIPointerLockStateDidChangeNotification: string;

declare const UIBackgroundTaskInvalid: number;

declare const UIFocusGroupPriorityIgnored: number;

declare const UIAccessibilityVideoAutoplayStatusDidChangeNotification: string;

declare const UIAccessibilityAnnouncementNotification: number;

declare const UITransitionContextToViewControllerKey: string;

declare const UITextAttributeTextShadowColor: string;

declare const UIApplicationBackgroundRefreshStatusDidChangeNotification: string;

declare const NSSourceTextScalingDocumentAttribute: string;

declare const UIMenuLearn: string;

declare const UIAccessibilitySpeechAttributeQueueAnnouncement: string;

declare const NSUnderlineStyleAttributeName: string;

declare const UIAccessibilitySpeechAttributePunctuation: string;

declare const UIAccessibilityPriorityLow: string;

declare const UIAccessibilityPriorityHigh: string;

declare const UIAccessibilityTextualContextConsole: string;

declare const UITextContentTypePassword: string;

declare const UIAccessibilityTextualContextSourceCode: string;

declare const UIAccessibilityTextualContextSpreadsheet: string;

declare const UIAccessibilityTextualContextNarrative: string;

declare const UIAccessibilityTextualContextWordProcessing: string;

declare const UIAccessibilityNotificationSwitchControlIdentifier: string;

declare const UIAccessibilityAnnouncementKeyWasSuccessful: string;

declare const UIAccessibilityAnnouncementDidFinishNotification: string;

declare const UIAccessibilityPageScrolledNotification: number;

declare const UIAccessibilityTraitTabBar: number;

declare const UITextContentTypeNameSuffix: string;

declare const UIFontTextStyleCallout: string;

declare const UIAccessibilityTraitAllowsDirectInteraction: number;

declare const UIAccessibilityTraitAdjustable: number;

declare const UIAccessibilityTraitStartsMediaSession: number;

declare const UIAccessibilityTraitNone: number;

declare const NSUnderlinePatternDashDotDot: interop.Enum<typeof NSUnderlineStyle>;

declare const NSViewModeDocumentAttribute: string;

declare const UITextContentTypeCreditCardExpirationYear: string;

declare const NSUnderlinePatternDot: interop.Enum<typeof NSUnderlineStyle>;

declare const NSExpansionAttributeName: string;

declare const UIPasteboardChangedTypesAddedKey: string;

declare const NSTargetTextScalingDocumentOption: string;

declare const UIPageViewControllerOptionSpineLocationKey: string;

declare const NSCharacterEncodingDocumentOption: string;

declare const NSDefaultAttributesDocumentOption: string;

declare const NSCocoaVersionDocumentAttribute: string;

declare const UITextWritingDirectionNatural: interop.Enum<typeof NSWritingDirection>;

declare const NSTextScalingDocumentAttribute: string;

declare const UIKeyInputF6: string;

declare const NSDefaultTabIntervalDocumentAttribute: string;

declare const NSBackgroundColorDocumentAttribute: string;

declare const NSReadOnlyDocumentAttribute: string;

declare const NSDefaultFontExcludedDocumentAttribute: string;

declare const NSViewZoomDocumentAttribute: string;

declare const UIFontDescriptorMatrixAttribute: string;

declare const NSViewSizeDocumentAttribute: string;

declare const NSPaperMarginDocumentAttribute: string;

declare const NSPaperSizeDocumentAttribute: string;

declare const NSCharacterEncodingDocumentAttribute: string;

declare const UIKeyInputF1: string;

declare const NSTextLayoutSectionRange: string;

declare const NSTextLayoutSectionOrientation: string;

declare const NSRTFTextDocumentType: string;

declare const UIAccessibilityTraitButton: number;

declare const UIApplicationLaunchOptionsLocationKey: string;

declare const NSUnderlineColorAttributeName: string;

declare const UIApplicationWillTerminateNotification: string;

declare const NSAttachmentAttributeName: string;

declare const UIFontDescriptorCharacterSetAttribute: string;

declare const NSTextEffectAttributeName: string;

declare const NSShadowAttributeName: string;

declare const UIApplicationOpenNotificationSettingsURLString: string;

declare const NSTrackingAttributeName: string;

declare const NSBackgroundColorAttributeName: string;

declare const UIPasteboardNameFind: string;

declare const NSFontAttributeName: string;

declare const UIApplicationProtectedDataWillBecomeUnavailable: string;

declare const UIApplicationSignificantTimeChangeNotification: string;

declare const UITextContentTypeBirthdateYear: string;

declare const UITextAttributeFont: string;

declare const UIKeyInputHome: string;

declare const UIActivityItemsConfigurationMetadataKeyMessageBody: string;

declare const UIPasteboardDetectionPatternLink: string;

declare const UIApplicationWillChangeStatusBarOrientationNotification: string;

declare const UIAccessibilityLayoutChangedNotification: number;

declare const UIKeyInputF5: string;

declare const UIWindowDidBecomeVisibleNotification: string;

declare const UIAccessibilitySpeechAttributeAnnouncementPriority: string;

declare const UIApplicationStatusBarFrameUserInfoKey: string;

declare const UIAccessibilitySpeechAttributeLanguage: string;

declare const UIAccessibilitySpeechAttributeIPANotation: string;

declare const UIApplicationLaunchOptionsShortcutItemKey: string;

declare const UIFontWeightMedium: number;

declare const UIAccessibilityPauseAssistiveTechnologyNotification: number;

declare const UIScreenBrightnessDidChangeNotification: string;

declare const UIContentSizeCategoryExtraExtraExtraLarge: string;

declare const UIPasteboardDetectionPatternMoneyAmount: string;

declare const UITextContentTypeBirthdateDay: string;

declare const UIAccessibilityTraitSummaryElement: number;

declare const UITrackingRunLoopMode: string;

declare const UIAccessibilityVoiceOverStatusChanged: string;

declare const UIContentSizeCategoryExtraExtraLarge: string;

declare const UIActivityItemsConfigurationInteractionCopy: string;

declare const UITextContentTypeSublocality: string;

declare const NSHyphenationFactorDocumentAttribute: string;

declare const UIActivityTypeCollaborationCopyLink: string;

declare const UIMenuFont: string;

declare const UIKeyInputF10: string;

declare const UITextContentTypeCreditCardType: string;

declare const UIAccessibilityTraitSupportsZoom: number;

declare const UIApplicationStatusBarOrientationUserInfoKey: string;

declare const UIAccessibilityReduceMotionStatusDidChangeNotification: string;

declare const UIAccessibilityPrefersCrossFadeTransitionsStatusDidChangeNotification: string;

declare const UIMenuClose: string;

declare const NSPlainTextDocumentType: string;

declare const UIMenuSpeech: string;

declare const UIContentSizeCategoryExtraSmall: string;

declare const UIFontFeatureSelectorIdentifierKey: string;

declare const NSStrikethroughStyleAttributeName: string;

declare const UIImagePickerControllerCropRect: string;

declare const UILayoutPriorityDragThatCanResizeScene: number;

declare const UIFontWeightSemibold: number;

declare const NSParagraphStyleAttributeName: string;

declare const UISceneWillDeactivateNotification: string;

declare const UIAccessibilityDarkerSystemColorsStatusDidChangeNotification: string;

declare const UIApplicationLaunchOptionsCloudKitShareMetadataKey: string;

declare const NSKernAttributeName: string;

declare const NSDocumentTypeDocumentAttribute: string;

declare const UITextContentTypeCreditCardGivenName: string;

declare const UIPasteboardDetectionPatternCalendarEvent: string;

declare const NSUnderlinePatternDashDot: interop.Enum<typeof NSUnderlineStyle>;

declare const UIFontWidthStandard: number;

declare const UIMenuFind: string;

declare const UIMenuBringAllToFront: string;

declare const UIApplicationStateRestorationTimestampKey: string;

declare const NSLigatureAttributeName: string;

declare const UITextContentTypeGivenName: string;

declare const NSHTMLTextDocumentType: string;

declare const UIContentSizeCategoryAccessibilityExtraExtraLarge: string;

declare const UIAccessibilityAssistiveTechnologyKey: string;

declare const UIFontDescriptorSystemDesignSerif: string;

declare const UIMenuControllerWillHideMenuNotification: string;

declare const UIMenuAutoFill: string;

declare const UITextContentTypeStreetAddressLine1: string;

declare const UILayoutPriorityFittingSizeLevel: number;

declare const UIKeyInputDelete: string;

declare const UIMenuReplace: string;

declare const UISceneDidDisconnectNotification: string;

declare const UILayoutPriorityDefaultLow: number;

declare const UIMenuSidebar: string;

declare const UIActivityTypePostToWeibo: string;

declare const NSTextListMarkerCheck: string;

declare const UIMenuPreferences: string;

declare const UIContentSizeCategoryMedium: string;

declare const UIMenuFile: string;

declare const UIUserNotificationTextInputActionButtonTitleKey: string;

declare const UIPasteboardNameGeneral: string;

declare const NSTextListMarkerLowercaseRoman: string;

declare const UITextContentTypeNickname: string;

declare const UIAccessibilityAssistiveTouchStatusDidChangeNotification: string;

declare const NSControlCharacterContainerBreakAction: number;

declare const UIKeyInputF2: string;

declare const UICollectionLayoutSectionOrthogonalScrollingDecelerationRateFast: number;

declare const UIStackViewSpacingUseSystem: number;

declare const UIAccessibilityVoiceOverStatusDidChangeNotification: string;

declare const UILayoutPrioritySceneSizeStayPut: number;

declare const UIApplicationLaunchOptionsBluetoothPeripheralsKey: string;

declare const UIKeyboardAnimationCurveUserInfoKey: string;

declare const UIAccessibilityOnOffSwitchLabelsDidChangeNotification: string;

declare const UIContentSizeCategoryUnspecified: string;

declare const UIEdgeInsetsZero: UIEdgeInsets;

declare const UIMenuQuit: string;

declare const UISceneWillConnectNotification: string;

declare const UIOffsetZero: UIOffset;

declare const UIApplicationDidEnterBackgroundNotification: string;

declare const UITextContentTypeOneTimeCode: string;

declare const UIKeyInputDownArrow: string;

declare const UIKeyboardIsLocalUserInfoKey: string;

declare const UICommandTagShare: string;

declare const UIContentSizeCategorySmall: string;

declare const UIAccessibilityTraitHeader: number;

declare const UILayoutPriorityDefaultHigh: number;

declare const UIImagePickerControllerEditedImage: string;

declare const NSDefaultAttributesDocumentAttribute: string;

declare const UICollectionViewLayoutAutomaticDimension: number;

declare const NSVerticalGlyphFormAttributeName: string;

declare const UIFontWeightThin: number;

declare const UIActivityTypeMail: string;

declare const NSUnderlineByWord: interop.Enum<typeof NSUnderlineStyle>;

declare const UIStateRestorationViewControllerStoryboardKey: string;

declare const UIKeyInputEnd: string;

declare const UIContentSizeCategoryLarge: string;

declare const UIScreenDidDisconnectNotification: string;

declare const UIAccessibilityTraitImage: number;

declare const UIAccessibilityTraitSearchField: number;

declare const UIMenuView: string;

declare const UIFontTextStyleTitle2: string;

declare const UIContentSizeCategoryAccessibilityExtraLarge: string;

declare const UIAccessibilityAnnouncementKeyStringValue: string;

declare const UISplitViewControllerAutomaticDimension: number;

declare const UIMenuLookup: string;

declare const UIMenuDocument: string;

declare const NSObliquenessAttributeName: string;

declare const UIAccessibilityMonoAudioStatusDidChangeNotification: string;

declare const UIKeyInputF12: string;

declare const UITextContentTypeCellularEID: string;

declare const UIFontTextStyleExtraLargeTitle2: string;

declare const UIFocusMovementDidFailNotification: string;

declare const UIGuidedAccessErrorDomain: string;

declare const UIAccessibilityTraitSelected: number;

declare const NSTextEffectLetterpressStyle: string;

declare const UIMenuToolbar: string;

declare const UIAccessibilitySpeechAttributeSpellOut: string;

declare const UIFocusUpdateContextKey: string;

declare const UITextContentTypeAddressCity: string;

declare const UIPasteboardDetectionPatternShipmentTrackingNumber: string;

declare const UILocalNotificationDefaultSoundName: string;

declare const UITextContentTypeCreditCardName: string;

declare const UIFontTextStyleTitle3: string;

declare const UITextAttributeTextColor: string;

declare const UITextContentTypeCreditCardSecurityCode: string;

declare const UIAccessibilityPriorityDefault: string;

declare const UIAccessibilityTextualContextMessaging: string;

declare const UIContentSizeCategoryAccessibilityExtraExtraExtraLarge: string;

declare const UIKeyInputF3: string;

declare const UIFloatRangeInfinite: UIFloatRange;

declare const NSRTFDTextDocumentType: string;

declare const UIApplicationInvalidInterfaceOrientationException: string;

declare const UITextViewTextDidChangeNotification: string;

declare const NSDocumentTypeDocumentOption: string;

declare const UIMinimumKeepAliveTimeout: number;

declare const UITextContentTypeBirthdate: string;

declare const NSControlCharacterLineBreakAction: number;

declare const UIAccessibilityTraitUpdatesFrequently: number;

declare const UIFontDescriptorCascadeListAttribute: string;

declare const UIMenuOpenRecent: string;

declare const UIImagePickerControllerLivePhoto: string;

declare const UIMenuNewScene: string;

declare const NSStrokeColorAttributeName: string;

declare const UIApplicationStateRestorationBundleVersionKey: string;

declare const UIMenuFormat: string;

declare const UIMenuWindow: string;

declare const UIPointerLockStateSceneUserInfoKey: string;

declare const UIActionPasteAndGo: string;

declare const UIApplicationProtectedDataDidBecomeAvailable: string;

declare const UIActionPasteAndMatchStyle: string;

declare const UIApplicationBackgroundFetchIntervalNever: number;

declare const NSTextListMarkerUppercaseRoman: string;

declare const UIWindowDidBecomeKeyNotification: string;

declare const UIMenuText: string;

declare const UIAccessibilityTraitStaticText: number;

declare const UIKeyboardDidShowNotification: string;

declare const UIPasteboardDetectionPatternPostalAddress: string;

declare const UITextContentTypeAddressState: string;

declare const NSForegroundColorAttributeName: string;

declare const UIWindowSceneSessionRoleExternalDisplay: string;

declare const UIApplicationDidBecomeActiveNotification: string;

declare const UIFocusGroupPriorityPrioritized: number;

declare const NSBaselineOffsetAttributeName: string;

declare const UIAccessibilityTraitLink: number;

declare const UIFontDescriptorFamilyAttribute: string;

declare const UIDeviceBatteryStateDidChangeNotification: string;

declare const NSSourceTextScalingDocumentOption: string;

declare const UIMenuHide: string;

declare const UISheetPresentationControllerAutomaticDimension: number;

declare const UIBarMetrics: {
  Default: 0,
  Compact: 1,
  DefaultPrompt: 101,
  CompactPrompt: 102,
  LandscapePhone: 1,
  LandscapePhonePrompt: 102,
};

declare const UICollectionUpdateAction: {
  Insert: 0,
  Delete: 1,
  Reload: 2,
  Move: 3,
  None: 4,
};

declare const UIContextMenuInteractionCommitStyle: {
  Dismiss: 0,
  Pop: 1,
};

declare const UIContentInsetsReference: {
  Automatic: 0,
  None: 1,
  SafeArea: 2,
  LayoutMargins: 3,
  ReadableContent: 4,
};

declare const UIPasteControlDisplayMode: {
  IconAndLabel: 0,
  IconOnly: 1,
  LabelOnly: 2,
};

declare const UIImagePickerControllerImageURLExportPreset: {
  Compatible: 0,
  Current: 1,
};

declare const UISceneCaptureState: {
  Unspecified: -1,
  Inactive: 0,
  Active: 1,
};

declare const UIViewAutoresizing: {
  None: 0,
  FlexibleLeftMargin: 1,
  FlexibleWidth: 2,
  FlexibleRightMargin: 4,
  FlexibleTopMargin: 8,
  FlexibleHeight: 16,
  FlexibleBottomMargin: 32,
};

declare const UIInterfaceOrientationMask: {
  Portrait: 2,
  LandscapeLeft: 16,
  LandscapeRight: 8,
  PortraitUpsideDown: 4,
  Landscape: 24,
  All: 30,
  AllButUpsideDown: 26,
};

declare const UIDocumentChangeKind: {
  Done: 0,
  Undone: 1,
  Redone: 2,
  Cleared: 3,
};

declare const UICollectionViewFlowLayoutSectionInsetReference: {
  ContentInset: 0,
  SafeArea: 1,
  LayoutMargins: 2,
};

declare const UITextDropAction: {
  Insert: 0,
  ReplaceSelection: 1,
  ReplaceAll: 2,
};

declare const UIModalPresentationStyle: {
  FullScreen: 0,
  PageSheet: 1,
  FormSheet: 2,
  CurrentContext: 3,
  Custom: 4,
  OverFullScreen: 5,
  OverCurrentContext: 6,
  Popover: 7,
  None: -1,
  Automatic: -2,
};

declare const UICellAccessoryPlacement: {
  Leading: 0,
  Trailing: 1,
};

declare const UIViewAnimationCurve: {
  EaseInOut: 0,
  EaseIn: 1,
  EaseOut: 2,
  Linear: 3,
};

declare const UITextAutocapitalizationType: {
  None: 0,
  Words: 1,
  Sentences: 2,
  AllCharacters: 3,
};

declare const UIDatePickerMode: {
  Time: 0,
  Date: 1,
  DateAndTime: 2,
  CountDownTimer: 3,
  YearAndMonth: 4,
};

declare const UIPencilInteractionPhase: {
  Began: 0,
  Changed: 1,
  Ended: 2,
  Cancelled: 3,
};

declare const UIWebViewNavigationType: {
  LinkClicked: 0,
  FormSubmitted: 1,
  BackForward: 2,
  Reload: 3,
  FormResubmitted: 4,
  Other: 5,
};

declare const UITextGranularity: {
  Character: 0,
  Word: 1,
  Sentence: 2,
  Paragraph: 3,
  Line: 4,
  Document: 5,
};

declare const UIPrintInfoDuplex: {
  None: 0,
  LongEdge: 1,
  ShortEdge: 2,
};

declare const UIPrintInfoOrientation: {
  Portrait: 0,
  Landscape: 1,
};

declare const UIPrintInfoOutputType: {
  General: 0,
  Photo: 1,
  Grayscale: 2,
  PhotoGrayscale: 3,
};

declare const UIDocumentBrowserUserInterfaceStyle: {
  White: 0,
  Light: 1,
  Dark: 2,
};

declare const UIDocumentBrowserImportMode: {
  None: 0,
  Copy: 1,
  Move: 2,
};

declare const NSTextListOptions: {
  NSTextListPrependEnclosingMarker: 1,
};

declare const NSTextSelectionNavigationModifier: {
  Extend: 1,
  Visual: 2,
  Multiple: 4,
};

declare const NSTextLayoutFragmentState: {
  None: 0,
  EstimatedUsageBounds: 1,
  CalculatedUsageBounds: 2,
  LayoutAvailable: 3,
};

declare const UIAlertActionStyle: {
  Default: 0,
  Cancel: 1,
  Destructive: 2,
};

declare const NSTextLayoutFragmentEnumerationOptions: {
  None: 0,
  Reverse: 1,
  EstimatesSize: 2,
  EnsuresLayout: 4,
  EnsuresExtraLineFragment: 8,
};

declare const UIPrintErrorCode: {
  PrintingNotAvailable: 1,
  PrintNoContent: 2,
  PrintUnknownImageFormat: 3,
  PrintJobFailed: 4,
};

declare const NSTextSelectionGranularity: {
  Character: 0,
  Word: 1,
  Paragraph: 2,
  Line: 3,
  Sentence: 4,
};

declare const UIBarButtonItemStyle: {
  Plain: 0,
  Bordered: 1,
  Done: 2,
};

declare const UIPointerEffectTintMode: {
  None: 0,
  Overlay: 1,
  Underlay: 2,
};

declare const UINotificationFeedbackType: {
  Success: 0,
  Warning: 1,
  Error: 2,
};

declare const UIImpactFeedbackStyle: {
  Light: 0,
  Medium: 1,
  Heavy: 2,
  Soft: 3,
  Rigid: 4,
};

declare const UIPageViewControllerSpineLocation: {
  None: 0,
  Min: 1,
  Mid: 2,
  Max: 3,
};

declare const UIPushBehaviorMode: {
  Continuous: 0,
  Instantaneous: 1,
};

declare const UITextSmartDashesType: {
  Default: 0,
  No: 1,
  Yes: 2,
};

declare const NSGlyphProperty: {
  Null: 1,
  ControlCharacter: 2,
  Elastic: 4,
  NonBaseCharacter: 8,
};

declare const UIStackViewAlignment: {
  Fill: 0,
  Leading: 1,
  Top: 1,
  FirstBaseline: 2,
  Center: 3,
  Trailing: 4,
  Bottom: 4,
  LastBaseline: 5,
};

declare const NSTextLayoutOrientation: {
  Horizontal: 0,
  Vertical: 1,
};

declare const UIStackViewDistribution: {
  Fill: 0,
  FillEqually: 1,
  FillProportionally: 2,
  EqualSpacing: 3,
  EqualCentering: 4,
};

declare const UITabBarItemAppearanceStyle: {
  Stacked: 0,
  Inline: 1,
  CompactInline: 2,
};

declare const UIBarButtonSystemItem: {
  Done: 0,
  Cancel: 1,
  Edit: 2,
  Save: 3,
  Add: 4,
  FlexibleSpace: 5,
  FixedSpace: 6,
  Compose: 7,
  Reply: 8,
  Action: 9,
  Organize: 10,
  Bookmarks: 11,
  Search: 12,
  Refresh: 13,
  Stop: 14,
  Camera: 15,
  Trash: 16,
  Play: 17,
  Pause: 18,
  Rewind: 19,
  FastForward: 20,
  Undo: 21,
  Redo: 22,
  PageCurl: 23,
  Close: 24,
};

declare const UIWebPaginationBreakingMode: {
  Page: 0,
  Column: 1,
};

declare const UIWebPaginationMode: {
  Unpaginated: 0,
  LeftToRight: 1,
  TopToBottom: 2,
  BottomToTop: 3,
  RightToLeft: 4,
};

declare const UITextViewBorderStyle: {
  UITextViewBorderStyleNone: 0,
};

declare const UITextSearchFoundTextStyle: {
  Normal: 0,
  Found: 1,
  Highlighted: 2,
};

declare const UITabBarSystemItem: {
  More: 0,
  Favorites: 1,
  Featured: 2,
  TopRated: 3,
  Recents: 4,
  Contacts: 5,
  History: 6,
  Bookmarks: 7,
  Search: 8,
  Downloads: 9,
  MostRecent: 10,
  MostViewed: 11,
};

declare const UICollectionLayoutSectionOrthogonalScrollingBounce: {
  Automatic: 0,
  Always: 1,
  Never: 2,
};

declare const UITabBarItemPositioning: {
  Automatic: 0,
  Fill: 1,
  Centered: 2,
};

declare const UITextInteractionMode: {
  UITextInteractionModeEditable: 0,
  Non: 1,
};

declare const UISwitchStyle: {
  Automatic: 0,
  Checkbox: 1,
  Sliding: 2,
};

declare const UISplitViewControllerSplitBehavior: {
  Automatic: 0,
  Tile: 1,
  Overlay: 2,
  Displace: 3,
};

declare const UISplitViewControllerColumn: {
  Primary: 0,
  Supplementary: 1,
  Secondary: 2,
  Compact: 3,
};

declare const UICollisionBehaviorMode: {
  Items: 1,
  Boundaries: 2,
  Everything: -1,
};

declare const UISplitViewControllerStyle: {
  Unspecified: 0,
  DoubleColumn: 1,
  TripleColumn: 2,
};

declare const UISplitViewControllerBackgroundStyle: {
  None: 0,
  Sidebar: 1,
};

declare const UISegmentedControlStyle: {
  Plain: 0,
  Bordered: 1,
  Bar: 2,
  Bezeled: 3,
};

declare const UISearchControllerScopeBarActivation: {
  Automatic: 0,
  Manual: 1,
  OnTextEntry: 2,
  OnSearchActivation: 3,
};

declare const UITimingCurveType: {
  Builtin: 0,
  Cubic: 1,
  Spring: 2,
  Composed: 3,
};

declare const UISearchBarIcon: {
  Search: 0,
  Clear: 1,
  Bookmark: 2,
  ResultsList: 3,
};

declare const UIScreenReferenceDisplayModeStatus: {
  NotSupported: 0,
  NotEnabled: 1,
  Limited: 2,
  Enabled: 3,
};

declare const UITableViewRowActionStyle: {
  Default: 0,
  Destructive: 0,
  Normal: 1,
};

declare const UIScreenOverscanCompensation: {
  Scale: 0,
  InsetBounds: 1,
  None: 2,
  InsetApplicationFrame: 2,
};

declare const UIAttachmentBehaviorType: {
  Items: 0,
  Anchor: 1,
};

declare const UIProgressViewStyle: {
  Default: 0,
  Bar: 1,
};

declare const UIPressPhase: {
  Began: 0,
  Changed: 1,
  Stationary: 2,
  Ended: 3,
  Cancelled: 4,
};

declare const UIPageViewControllerTransitionStyle: {
  PageCurl: 0,
  Scroll: 1,
};

declare const UIPageViewControllerNavigationDirection: {
  Forward: 0,
  Reverse: 1,
};

declare const UIPageControlDirection: {
  Natural: 0,
  LeftToRight: 1,
  RightToLeft: 2,
  TopToBottom: 3,
  BottomToTop: 4,
};

declare const UIPageControlBackgroundStyle: {
  Automatic: 0,
  Prominent: 1,
  Minimal: 2,
};

declare const UINavigationBarNSToolbarSection: {
  None: 0,
  Sidebar: 1,
  Supplementary: 2,
  Content: 3,
};

declare const UICornerCurve: {
  Automatic: 0,
  Circular: 1,
  Continuous: 2,
};

declare const UIUserNotificationActionContext: {
  Default: 0,
  Minimal: 1,
};

declare const UIRectEdge: {
  None: 0,
  Top: 1,
  Left: 2,
  Bottom: 4,
  Right: 8,
  All: 15,
};

declare const UIUserNotificationActivationMode: {
  Foreground: 0,
  Background: 1,
};

declare const UIUserNotificationActionBehavior: {
  Default: 0,
  TextInput: 1,
};

declare const UIUserNotificationType: {
  None: 0,
  Badge: 1,
  Sound: 2,
  Alert: 4,
};

declare const UIImagePickerControllerCameraDevice: {
  Rear: 0,
  Front: 1,
};

declare const UIImagePickerControllerQualityType: {
  TypeHigh: 0,
  TypeMedium: 1,
  TypeLow: 2,
  Type640x480: 3,
  TypeIFrame1280x720: 4,
  TypeIFrame960x540: 5,
};

declare const UIBandSelectionInteractionState: {
  Possible: 0,
  Began: 1,
  Selecting: 2,
  Ended: 3,
};

declare const UINavigationControllerOperation: {
  None: 0,
  Push: 1,
  Pop: 2,
};

declare const UIScrollType: {
  Discrete: 0,
  Continuous: 1,
};

declare const NSUnderlineStyle: {
  None: 0,
  Single: 1,
  Thick: 2,
  Double: 9,
  PatternSolid: 0,
  PatternDot: 256,
  PatternDash: 512,
  PatternDashDot: 768,
  PatternDashDotDot: 1024,
  ByWord: 32768,
};

declare const UIGraphicsImageRendererFormatRange: {
  Unspecified: -1,
  Automatic: 0,
  Extended: 1,
  Standard: 2,
};

declare const UITextBorderStyle: {
  None: 0,
  Line: 1,
  Bezel: 2,
  RoundedRect: 3,
};

declare const UITextItemContentType: {
  Link: 0,
  TextAttachment: 1,
  Tag: 2,
};

declare const UIBlurEffectStyle: {
  ExtraLight: 0,
  Light: 1,
  Dark: 2,
  Regular: 4,
  Prominent: 5,
  SystemUltraThinMaterial: 6,
  SystemThinMaterial: 7,
  SystemMaterial: 8,
  SystemThickMaterial: 9,
  SystemChromeMaterial: 10,
  SystemUltraThinMaterialLight: 11,
  SystemThinMaterialLight: 12,
  SystemMaterialLight: 13,
  SystemThickMaterialLight: 14,
  SystemChromeMaterialLight: 15,
  SystemUltraThinMaterialDark: 16,
  SystemThinMaterialDark: 17,
  SystemMaterialDark: 18,
  SystemThickMaterialDark: 19,
  SystemChromeMaterialDark: 20,
};

declare const UIDocumentMenuOrder: {
  First: 0,
  Last: 1,
};

declare const UIDocumentPickerMode: {
  Import: 0,
  Open: 1,
  ExportToService: 2,
  MoveToService: 3,
};

declare const UIDocumentState: {
  Normal: 0,
  Closed: 1,
  InConflict: 2,
  SavingError: 4,
  EditingDisabled: 8,
  ProgressAvailable: 16,
};

declare const UIDocumentSaveOperation: {
  Creating: 0,
  Overwriting: 1,
};

declare const UINavigationItemStyle: {
  Navigator: 0,
  Browser: 1,
  Editor: 2,
};

declare const UINavigationItemSearchBarPlacement: {
  Automatic: 0,
  Inline: 1,
  Stacked: 2,
};

declare const UIDatePickerStyle: {
  Automatic: 0,
  Wheels: 1,
  Compact: 2,
  Inline: 3,
};

declare const UIDataDetectorTypes: {
  PhoneNumber: 1,
  Link: 2,
  Address: 4,
  CalendarEvent: 8,
  ShipmentTrackingNumber: 16,
  FlightNumber: 32,
  LookupSuggestion: 64,
  Money: 128,
  PhysicalValue: 256,
  None: 0,
  All: -1,
};

declare const UIKeyboardHIDUsage: {
  KeyboardErrorRollOver: 1,
  KeyboardPOSTFail: 2,
  KeyboardErrorUndefined: 3,
  KeyboardA: 4,
  KeyboardB: 5,
  KeyboardC: 6,
  KeyboardD: 7,
  KeyboardE: 8,
  KeyboardF: 9,
  KeyboardG: 10,
  KeyboardH: 11,
  KeyboardI: 12,
  KeyboardJ: 13,
  KeyboardK: 14,
  KeyboardL: 15,
  KeyboardM: 16,
  KeyboardN: 17,
  KeyboardO: 18,
  KeyboardP: 19,
  KeyboardQ: 20,
  KeyboardR: 21,
  KeyboardS: 22,
  KeyboardT: 23,
  KeyboardU: 24,
  KeyboardV: 25,
  KeyboardW: 26,
  KeyboardX: 27,
  KeyboardY: 28,
  KeyboardZ: 29,
  Keyboard1: 30,
  Keyboard2: 31,
  Keyboard3: 32,
  Keyboard4: 33,
  Keyboard5: 34,
  Keyboard6: 35,
  Keyboard7: 36,
  Keyboard8: 37,
  Keyboard9: 38,
  Keyboard0: 39,
  KeyboardReturnOrEnter: 40,
  KeyboardEscape: 41,
  KeyboardDeleteOrBackspace: 42,
  KeyboardTab: 43,
  KeyboardSpacebar: 44,
  KeyboardHyphen: 45,
  KeyboardEqualSign: 46,
  KeyboardOpenBracket: 47,
  KeyboardCloseBracket: 48,
  KeyboardBackslash: 49,
  KeyboardNonUSPound: 50,
  KeyboardSemicolon: 51,
  KeyboardQuote: 52,
  KeyboardGraveAccentAndTilde: 53,
  KeyboardComma: 54,
  KeyboardPeriod: 55,
  KeyboardSlash: 56,
  KeyboardCapsLock: 57,
  KeyboardF1: 58,
  KeyboardF2: 59,
  KeyboardF3: 60,
  KeyboardF4: 61,
  KeyboardF5: 62,
  KeyboardF6: 63,
  KeyboardF7: 64,
  KeyboardF8: 65,
  KeyboardF9: 66,
  KeyboardF10: 67,
  KeyboardF11: 68,
  KeyboardF12: 69,
  KeyboardPrintScreen: 70,
  KeyboardScrollLock: 71,
  KeyboardPause: 72,
  KeyboardInsert: 73,
  KeyboardHome: 74,
  KeyboardPageUp: 75,
  KeyboardDeleteForward: 76,
  KeyboardEnd: 77,
  KeyboardPageDown: 78,
  KeyboardRightArrow: 79,
  KeyboardLeftArrow: 80,
  KeyboardDownArrow: 81,
  KeyboardUpArrow: 82,
  KeypadNumLock: 83,
  KeypadSlash: 84,
  KeypadAsterisk: 85,
  KeypadHyphen: 86,
  KeypadPlus: 87,
  KeypadEnter: 88,
  Keypad1: 89,
  Keypad2: 90,
  Keypad3: 91,
  Keypad4: 92,
  Keypad5: 93,
  Keypad6: 94,
  Keypad7: 95,
  Keypad8: 96,
  Keypad9: 97,
  Keypad0: 98,
  KeypadPeriod: 99,
  KeyboardNonUSBackslash: 100,
  KeyboardApplication: 101,
  KeyboardPower: 102,
  KeypadEqualSign: 103,
  KeyboardF13: 104,
  KeyboardF14: 105,
  KeyboardF15: 106,
  KeyboardF16: 107,
  KeyboardF17: 108,
  KeyboardF18: 109,
  KeyboardF19: 110,
  KeyboardF20: 111,
  KeyboardF21: 112,
  KeyboardF22: 113,
  KeyboardF23: 114,
  KeyboardF24: 115,
  KeyboardExecute: 116,
  KeyboardHelp: 117,
  KeyboardMenu: 118,
  KeyboardSelect: 119,
  KeyboardStop: 120,
  KeyboardAgain: 121,
  KeyboardUndo: 122,
  KeyboardCut: 123,
  KeyboardCopy: 124,
  KeyboardPaste: 125,
  KeyboardFind: 126,
  KeyboardMute: 127,
  KeyboardVolumeUp: 128,
  KeyboardVolumeDown: 129,
  KeyboardLockingCapsLock: 130,
  KeyboardLockingNumLock: 131,
  KeyboardLockingScrollLock: 132,
  KeypadComma: 133,
  KeypadEqualSignAS400: 134,
  KeyboardInternational1: 135,
  KeyboardInternational2: 136,
  KeyboardInternational3: 137,
  KeyboardInternational4: 138,
  KeyboardInternational5: 139,
  KeyboardInternational6: 140,
  KeyboardInternational7: 141,
  KeyboardInternational8: 142,
  KeyboardInternational9: 143,
  KeyboardLANG1: 144,
  KeyboardLANG2: 145,
  KeyboardLANG3: 146,
  KeyboardLANG4: 147,
  KeyboardLANG5: 148,
  KeyboardLANG6: 149,
  KeyboardLANG7: 150,
  KeyboardLANG8: 151,
  KeyboardLANG9: 152,
  KeyboardAlternateErase: 153,
  KeyboardSysReqOrAttention: 154,
  KeyboardCancel: 155,
  KeyboardClear: 156,
  KeyboardPrior: 157,
  KeyboardReturn: 158,
  KeyboardSeparator: 159,
  KeyboardOut: 160,
  KeyboardOper: 161,
  KeyboardClearOrAgain: 162,
  KeyboardCrSelOrProps: 163,
  KeyboardExSel: 164,
  KeyboardLeftControl: 224,
  KeyboardLeftShift: 225,
  KeyboardLeftAlt: 226,
  KeyboardLeftGUI: 227,
  KeyboardRightControl: 228,
  KeyboardRightShift: 229,
  KeyboardRightAlt: 230,
  KeyboardRightGUI: 231,
  Keyboard_Reserved: 65535,
  KeyboardHangul: 144,
  KeyboardHanja: 145,
  KeyboardKanaSwitch: 144,
  KeyboardAlphanumericSwitch: 145,
  KeyboardKatakana: 146,
  KeyboardHiragana: 147,
  KeyboardZenkakuHankakuKanji: 148,
};

declare const UIListContentTextTransform: {
  None: 0,
  Uppercase: 1,
  Lowercase: 2,
  Capitalized: 3,
};

declare const UIListSeparatorVisibility: {
  Automatic: 0,
  Visible: 1,
  Hidden: 2,
};

declare const UICollectionLayoutListFooterMode: {
  None: 0,
  Supplementary: 1,
};

declare const UICollectionLayoutListHeaderMode: {
  None: 0,
  Supplementary: 1,
  FirstItemInSection: 2,
};

declare const UICollectionLayoutListAppearance: {
  Plain: 0,
  Grouped: 1,
  InsetGrouped: 2,
  Sidebar: 3,
  SidebarPlain: 4,
};

declare const UITableViewSelfSizingInvalidation: {
  Disabled: 0,
  Enabled: 1,
  EnabledIncludingConstraints: 2,
};

declare const UITableViewRowAnimation: {
  Fade: 0,
  Right: 1,
  Left: 2,
  Top: 3,
  Bottom: 4,
  None: 5,
  Middle: 6,
  Automatic: 100,
};

declare const UITableViewStyle: {
  Plain: 0,
  Grouped: 1,
  InsetGrouped: 2,
};

declare const UITableViewCellStateMask: {
  Default: 0,
  ShowingEditControl: 1,
  ShowingDeleteConfirmation: 2,
};

declare const UITableViewCellAccessoryType: {
  None: 0,
  DisclosureIndicator: 1,
  DetailDisclosureButton: 2,
  Checkmark: 3,
  DetailButton: 4,
};

declare const UITableViewCellEditingStyle: {
  None: 0,
  Delete: 1,
  Insert: 2,
};

declare const UITableViewCellFocusStyle: {
  Default: 0,
  Custom: 1,
};

declare const UITableViewCellSelectionStyle: {
  None: 0,
  Blue: 1,
  Gray: 2,
  Default: 3,
};

declare const UIAccessibilityScrollDirection: {
  Right: 1,
  Left: 2,
  Up: 3,
  Down: 4,
  Next: 5,
  Previous: 6,
};

declare const UITableViewCellStyle: {
  Default: 0,
  Value1: 1,
  Value2: 2,
  Subtitle: 3,
};

declare const UICellAccessoryDisplayedState: {
  Always: 0,
  WhenEditing: 1,
  WhenNotEditing: 2,
};

declare const UICollectionLayoutSectionOrthogonalScrollingBehavior: {
  None: 0,
  Continuous: 1,
  ContinuousGroupLeadingBoundary: 2,
  Paging: 3,
  GroupPaging: 4,
  GroupPagingCentered: 5,
};

declare const UISwipeGestureRecognizerDirection: {
  Right: 1,
  Left: 2,
  Up: 4,
  Down: 8,
};

declare const UIAccessibilityHearingDeviceEar: {
  None: 0,
  Left: 2,
  Right: 4,
  Both: 6,
};

declare const UICollectionViewCellDragState: {
  None: 0,
  Lifting: 1,
  Dragging: 2,
};

declare const UINavigationItemLargeTitleDisplayMode: {
  Automatic: 0,
  Always: 1,
  Never: 2,
  Inline: 3,
};

declare const UIContextualActionStyle: {
  Normal: 0,
  Destructive: 1,
};

declare const UICollectionViewDropIntent: {
  Unspecified: 0,
  InsertAtDestinationIndexPath: 1,
  InsertIntoDestinationIndexPath: 2,
};

declare const UISplitViewControllerPrimaryEdge: {
  Leading: 0,
  Trailing: 1,
};

declare const UICollectionViewReorderingCadence: {
  Immediate: 0,
  Fast: 1,
  Slow: 2,
};

declare const UIActivityIndicatorViewStyle: {
  Medium: 100,
  Large: 101,
  WhiteLarge: 0,
  White: 1,
  Gray: 2,
};

declare const UILayoutConstraintAxis: {
  Horizontal: 0,
  Vertical: 1,
};

declare const UIButtonType: {
  Custom: 0,
  System: 1,
  DetailDisclosure: 2,
  InfoLight: 3,
  InfoDark: 4,
  ContactAdd: 5,
  Close: 7,
  RoundedRect: 1,
};

declare const UIButtonConfigurationIndicator: {
  Automatic: 0,
  None: 1,
  Popup: 2,
};

declare const UISearchBarStyle: {
  Default: 0,
  Prominent: 1,
  Minimal: 2,
};

declare const UIButtonConfigurationMacIdiomStyle: {
  Automatic: 0,
  Bordered: 1,
  Borderless: 2,
  BorderlessTinted: 3,
};

declare const UIButtonConfigurationCornerStyle: {
  Fixed: -1,
  Dynamic: 0,
  Small: 1,
  Medium: 2,
  Large: 3,
  Capsule: 4,
};

declare const UIGuidedAccessRestrictionState: {
  Allow: 0,
  Deny: 1,
};

declare const UIGuidedAccessErrorCode: {
  PermissionDenied: 0,
  Failed: 9223372036854775807,
};

declare const NSTextAlignment: {
  Left: 0,
  Center: 1,
  Right: 2,
  Justified: 3,
  Natural: 4,
};

declare const UIAlertControllerSeverity: {
  Default: 0,
  Critical: 1,
};

declare const UIRemoteNotificationType: {
  None: 0,
  Badge: 1,
  Sound: 2,
  Alert: 4,
  NewsstandContentAvailability: 8,
};

declare const UIAlertControllerStyle: {
  ActionSheet: 0,
  Alert: 1,
};

declare const UIDocumentBrowserActionAvailability: {
  Menu: 1,
  NavigationBar: 2,
};

declare const UIPageViewControllerNavigationOrientation: {
  Horizontal: 0,
  Vertical: 1,
};

declare const UIUserInterfaceActiveAppearance: {
  Unspecified: -1,
  Inactive: 0,
  Active: 1,
};

declare const UIBackgroundFetchResult: {
  NewData: 0,
  NoData: 1,
  Failed: 2,
};

declare const UIAlertViewStyle: {
  Default: 0,
  SecureTextInput: 1,
  PlainTextInput: 2,
  LoginAndPasswordInput: 3,
};

declare const UICellConfigurationDropState: {
  None: 0,
  NotTargeted: 1,
  Targeted: 2,
};

declare const UITextDropProgressMode: {
  System: 0,
  Custom: 1,
};

declare const UIActionSheetStyle: {
  Automatic: -1,
  Default: 0,
  BlackTranslucent: 2,
  BlackOpaque: 1,
};

declare const UITextFieldViewMode: {
  Never: 0,
  WhileEditing: 1,
  UnlessEditing: 2,
  Always: 3,
};

declare const UILetterformAwareSizingRule: {
  Typographic: 0,
  Oversize: 1,
};

declare const UITextDropEditability: {
  No: 0,
  Temporary: 1,
  Yes: 2,
};

declare const UITextLayoutDirection: {
  Right: 2,
  Left: 3,
  Up: 4,
  Down: 5,
};

declare const UITextAutocorrectionType: {
  Default: 0,
  No: 1,
  Yes: 2,
};

declare const UITextDragOptions: {
  OptionsNone: 0,
  OptionStripTextColorFromPreviews: 1,
};

declare const UIViewAnimatingPosition: {
  End: 0,
  Start: 1,
  Current: 2,
};

declare const UIDropOperation: {
  Cancel: 0,
  Forbidden: 1,
  Copy: 2,
  Move: 3,
};

declare const UITextAlignment: {
  Left: 0,
  Center: 1,
  Right: 2,
};

declare const UIUserInterfaceSizeClass: {
  Unspecified: 0,
  Compact: 1,
  Regular: 2,
};

declare const UILineBreakMode: {
  WordWrap: 0,
  CharacterWrap: 1,
  Clip: 2,
  HeadTruncation: 3,
  TailTruncation: 4,
  MiddleTruncation: 5,
};

declare const UIScrollViewIndicatorStyle: {
  Default: 0,
  Black: 1,
  White: 2,
};

declare const UIViewTintAdjustmentMode: {
  Automatic: 0,
  Normal: 1,
  Dimmed: 2,
};

declare const UIPressType: {
  UpArrow: 0,
  DownArrow: 1,
  LeftArrow: 2,
  RightArrow: 3,
  Select: 4,
  Menu: 5,
  PlayPause: 6,
};

declare const UIAccessibilityCustomRotorDirection: {
  Previous: 0,
  Next: 1,
};

declare const NSTextStorageEditActions: {
  Attributes: 1,
  Characters: 2,
};

declare const UIViewAnimatingState: {
  Inactive: 0,
  Active: 1,
  Stopped: 2,
};

declare const UIReturnKeyType: {
  Default: 0,
  Go: 1,
  Google: 2,
  Join: 3,
  Next: 4,
  Route: 5,
  Search: 6,
  Send: 7,
  Yahoo: 8,
  Done: 9,
  EmergencyCall: 10,
  Continue: 11,
};

declare const UIBehavioralStyle: {
  Automatic: 0,
  Pad: 1,
  Mac: 2,
};

declare const UIPrinterCutterBehavior: {
  NoCut: 0,
  PrinterDefault: 1,
  CutAfterEachPage: 2,
  CutAfterEachCopy: 3,
  CutAfterEachJob: 4,
};

declare const UIKeyboardAppearance: {
  Default: 0,
  Dark: 1,
  Light: 2,
  Alert: 1,
};

declare const UIAccessibilityZoomType: {
  UIAccessibilityZoomTypeInsertionPoint: 0,
};

declare const UITextSmartInsertDeleteType: {
  Default: 0,
  No: 1,
  Yes: 2,
};

declare const NSRectAlignment: {
  None: 0,
  Top: 1,
  TopLeading: 2,
  Leading: 3,
  BottomLeading: 4,
  Bottom: 5,
  BottomTrailing: 6,
  Trailing: 7,
  TopTrailing: 8,
};

declare const UIScrollViewIndexDisplayMode: {
  Automatic: 0,
  AlwaysHidden: 1,
};

declare const UIBarStyle: {
  Default: 0,
  Black: 1,
  BlackOpaque: 1,
  BlackTranslucent: 2,
};

declare const NSLayoutFormatOptions: {
  AlignAllLeft: 2,
  AlignAllRight: 4,
  AlignAllTop: 8,
  AlignAllBottom: 16,
  AlignAllLeading: 32,
  AlignAllTrailing: 64,
  AlignAllCenterX: 512,
  AlignAllCenterY: 1024,
  AlignAllLastBaseline: 2048,
  AlignAllFirstBaseline: 4096,
  AlignAllBaseline: 2048,
  AlignmentMask: 65535,
  DirectionLeadingToTrailing: 0,
  DirectionLeftToRight: 65536,
  DirectionRightToLeft: 131072,
  DirectionMask: 196608,
  SpacingEdgeToEdge: 0,
  SpacingBaselineToBaseline: 524288,
  SpacingMask: 524288,
};

declare const UITextSmartQuotesType: {
  Default: 0,
  No: 1,
  Yes: 2,
};

declare const UIGuidedAccessAccessibilityFeature: {
  VoiceOver: 1,
  Zoom: 2,
  AssistiveTouch: 4,
  InvertColors: 8,
  GrayscaleDisplay: 16,
};

declare const UIActivityCategory: {
  Action: 0,
  Share: 1,
};

declare const UIControlState: {
  Normal: 0,
  Highlighted: 1,
  Disabled: 2,
  Selected: 4,
  Focused: 8,
  Application: 16711680,
  Reserved: 4278190080,
};

declare const UIControlEvents: {
  TouchDown: 1,
  TouchDownRepeat: 2,
  TouchDragInside: 4,
  TouchDragOutside: 8,
  TouchDragEnter: 16,
  TouchDragExit: 32,
  TouchUpInside: 64,
  TouchUpOutside: 128,
  TouchCancel: 256,
  ValueChanged: 4096,
  PrimaryActionTriggered: 8192,
  MenuActionTriggered: 16384,
  EditingDidBegin: 65536,
  EditingChanged: 131072,
  EditingDidEnd: 262144,
  EditingDidEndOnExit: 524288,
  AllTouchEvents: 4095,
  AllEditingEvents: 983040,
  ApplicationReserved: 251658240,
  SystemReserved: 4026531840,
  AllEvents: 4294967295,
};

declare const UIContextMenuConfigurationElementOrder: {
  Automatic: 0,
  Priority: 1,
  Fixed: 2,
};

declare const UIViewKeyframeAnimationOptions: {
  LayoutSubviews: 1,
  AllowUserInteraction: 2,
  BeginFromCurrentState: 4,
  Repeat: 8,
  Autoreverse: 16,
  OverrideInheritedDuration: 32,
  OverrideInheritedOptions: 512,
  CalculationModeLinear: 0,
  CalculationModeDiscrete: 1024,
  CalculationModePaced: 2048,
  CalculationModeCubic: 3072,
  CalculationModeCubicPaced: 4096,
};

declare const UIEventSubtype: {
  None: 0,
  MotionShake: 1,
  RemoteControlPlay: 100,
  RemoteControlPause: 101,
  RemoteControlStop: 102,
  RemoteControlTogglePlayPause: 103,
  RemoteControlNextTrack: 104,
  RemoteControlPreviousTrack: 105,
  RemoteControlBeginSeekingBackward: 106,
  RemoteControlEndSeekingBackward: 107,
  RemoteControlBeginSeekingForward: 108,
  RemoteControlEndSeekingForward: 109,
};

declare const UITableViewCellDragState: {
  None: 0,
  Lifting: 1,
  Dragging: 2,
};

declare const UITextFieldDidEndEditingReason: {
  UITextFieldDidEndEditingReasonCommitted: 0,
};

declare const UIEditingInteractionConfiguration: {
  None: 0,
  Default: 1,
};

declare const UIViewContentMode: {
  ScaleToFill: 0,
  ScaleAspectFit: 1,
  ScaleAspectFill: 2,
  Redraw: 3,
  Center: 4,
  Top: 5,
  Bottom: 6,
  Left: 7,
  Right: 8,
  TopLeft: 9,
  TopRight: 10,
  BottomLeft: 11,
  BottomRight: 12,
};

declare const UIPageControlInteractionState: {
  None: 0,
  Discrete: 1,
  Continuous: 2,
};

declare const UISceneActivationState: {
  Unattached: -1,
  ForegroundActive: 0,
  ForegroundInactive: 1,
  Background: 2,
};

declare const UITouchType: {
  Direct: 0,
  Indirect: 1,
  Pencil: 2,
  Stylus: 2,
  IndirectPointer: 3,
};

declare const UITouchPhase: {
  Began: 0,
  Moved: 1,
  Stationary: 2,
  Ended: 3,
  Cancelled: 4,
  RegionEntered: 5,
  RegionMoved: 6,
  RegionExited: 7,
};

declare const UIInterfaceOrientation: {
  Unknown: 0,
  Portrait: 1,
  PortraitUpsideDown: 2,
  LandscapeLeft: 4,
  LandscapeRight: 3,
};

declare const UICellAccessoryOutlineDisclosureStyle: {
  Automatic: 0,
  Header: 1,
  Cell: 2,
};

declare const NSStringDrawingOptions: {
  UsesLineFragmentOrigin: 1,
  UsesFontLeading: 2,
  UsesDeviceMetrics: 8,
  TruncatesLastVisibleLine: 32,
};

declare const UIDeviceOrientation: {
  Unknown: 0,
  Portrait: 1,
  PortraitUpsideDown: 2,
  LandscapeLeft: 3,
  LandscapeRight: 4,
  FaceUp: 5,
  FaceDown: 6,
};

declare const NSLayoutRelation: {
  LessThanOr: -1,
  NSLayoutRelationEqual: 0,
  GreaterThanOr: 1,
};

declare const UIControlContentHorizontalAlignment: {
  Center: 0,
  Left: 1,
  Right: 2,
  Fill: 3,
  Leading: 4,
  Trailing: 5,
};

declare const UIImageDynamicRange: {
  Unspecified: -1,
  Standard: 0,
  ConstrainedHigh: 1,
  High: 2,
};

declare const UIUserInterfaceLevel: {
  Unspecified: -1,
  Base: 0,
  Elevated: 1,
};

declare const UIImagePickerControllerCameraFlashMode: {
  Off: -1,
  Auto: 0,
  On: 1,
};

declare const UIViewAnimationTransition: {
  None: 0,
  FlipFromLeft: 1,
  FlipFromRight: 2,
  CurlUp: 3,
  CurlDown: 4,
};

declare const NSTextSelectionNavigationDirection: {
  Forward: 0,
  Backward: 1,
  Right: 2,
  Left: 3,
  Up: 4,
  Down: 5,
};

declare const UILegibilityWeight: {
  Unspecified: -1,
  Regular: 0,
  Bold: 1,
};

declare const UIImagePickerControllerCameraCaptureMode: {
  Photo: 0,
  Video: 1,
};

declare const UIDisplayGamut: {
  Unspecified: -1,
  SRGB: 0,
  P3: 1,
};

declare const UIUserInterfaceLayoutDirection: {
  LeftToRight: 0,
  RightToLeft: 1,
};

declare const UIUserInterfaceStyle: {
  Unspecified: 0,
  Light: 1,
  Dark: 2,
};

declare const UIEditMenuArrowDirection: {
  Automatic: 0,
  Up: 1,
  Down: 2,
  Left: 3,
  Right: 4,
};

declare const UIEventType: {
  Touches: 0,
  Motion: 1,
  RemoteControl: 2,
  Presses: 3,
  Scroll: 10,
  Hover: 11,
  Transform: 14,
};

declare const UICollectionElementCategory: {
  Cell: 0,
  SupplementaryView: 1,
  DecorationView: 2,
};

declare const NSTextSelectionAffinity: {
  Upstream: 0,
  Downstream: 1,
};

declare const UIMenuOptions: {
  DisplayInline: 1,
  Destructive: 2,
  SingleSelection: 32,
  DisplayAsPalette: 128,
};

declare const NSLineBreakMode: {
  WordWrapping: 0,
  CharWrapping: 1,
  Clipping: 2,
  TruncatingHead: 3,
  TruncatingTail: 4,
  TruncatingMiddle: 5,
};

declare const UIImageSymbolWeight: {
  Unspecified: 0,
  UltraLight: 1,
  Thin: 2,
  Light: 3,
  Regular: 4,
  Medium: 5,
  Semibold: 6,
  Bold: 7,
  Heavy: 8,
  Black: 9,
};

declare const UITraitEnvironmentLayoutDirection: {
  Unspecified: -1,
  LeftToRight: 0,
  RightToLeft: 1,
};

declare const UIImageOrientation: {
  Up: 0,
  Down: 1,
  Left: 2,
  Right: 3,
  UpMirrored: 4,
  DownMirrored: 5,
  LeftMirrored: 6,
  RightMirrored: 7,
};

declare const UIImageRenderingMode: {
  Automatic: 0,
  AlwaysOriginal: 1,
  AlwaysTemplate: 2,
};

declare const NSTextLayoutManagerSegmentOptions: {
  None: 0,
  RangeNotRequired: 1,
  MiddleFragmentsExcluded: 2,
  HeadSegmentExtended: 4,
  TailSegmentExtended: 8,
  UpstreamAffinity: 16,
};

declare const NSLayoutAttribute: {
  Left: 1,
  Right: 2,
  Top: 3,
  Bottom: 4,
  Leading: 5,
  Trailing: 6,
  Width: 7,
  Height: 8,
  CenterX: 9,
  CenterY: 10,
  LastBaseline: 11,
  Baseline: 11,
  FirstBaseline: 12,
  LeftMargin: 13,
  RightMargin: 14,
  TopMargin: 15,
  BottomMargin: 16,
  LeadingMargin: 17,
  TrailingMargin: 18,
  CenterXWithinMargins: 19,
  CenterYWithinMargins: 20,
  NotAnAttribute: 0,
};

declare const NSDirectionalRectEdge: {
  None: 0,
  Top: 1,
  Leading: 2,
  Bottom: 4,
  Trailing: 8,
  All: 15,
};

declare const UIRectCorner: {
  TopLeft: 1,
  TopRight: 2,
  BottomLeft: 4,
  BottomRight: 8,
  AllCorners: -1,
};

declare const UIMenuElementAttributes: {
  Disabled: 1,
  Destructive: 2,
  Hidden: 4,
  KeepsMenuPresented: 8,
};

declare const UIAccessibilityDirectTouchOptions: {
  None: 0,
  SilentOnTouch: 1,
  RequiresActivation: 2,
};

declare const UIAccessibilityNavigationStyle: {
  Automatic: 0,
  Separate: 1,
  Combined: 2,
};

declare const UITextSearchMatchMethod: {
  Contains: 0,
  StartsWith: 1,
  FullWord: 2,
};

declare const NSControlCharacterAction: {
  ZeroAdvancement: 1,
  Whitespace: 2,
  HorizontalTab: 4,
  LineBreak: 8,
  ParagraphBreak: 16,
  ContainerBreak: 32,
};

declare const UIModalTransitionStyle: {
  CoverVertical: 0,
  FlipHorizontal: 1,
  CrossDissolve: 2,
  PartialCurl: 3,
};

declare const NSTextScalingType: {
  ScalingStandard: 0,
  ScalingiOS: 1,
};

declare const NSTextWritingDirection: {
  Embedding: 0,
  Override: 2,
};

declare const UICollectionViewSelfSizingInvalidation: {
  Disabled: 0,
  Enabled: 1,
  EnabledIncludingConstraints: 2,
};

declare const NSWritingDirectionFormatType: {
  Embedding: 0,
  Override: 2,
};

declare const UITextDropPerformer: {
  View: 0,
  Delegate: 1,
};

declare const UINavigationItemBackButtonDisplayMode: {
  Default: 0,
  Generic: 1,
  Minimal: 2,
};

declare const UITouchProperties: {
  Force: 1,
  Azimuth: 2,
  Altitude: 4,
  Location: 8,
  Roll: 16,
};

declare const UITextStorageDirection: {
  Forward: 0,
  Backward: 1,
};

declare const UITableViewSeparatorInsetReference: {
  CellEdges: 0,
  AutomaticInsets: 1,
};

declare const UIInputViewStyle: {
  Default: 0,
  Keyboard: 1,
};

declare const UITableViewCellSeparatorStyle: {
  None: 0,
  SingleLine: 1,
  SingleLineEtched: 2,
};

declare const UIPreviewActionStyle: {
  Default: 0,
  Selected: 1,
  Destructive: 2,
};

declare const UIAccessibilityCustomSystemRotorType: {
  None: 0,
  Link: 1,
  VisitedLink: 2,
  Heading: 3,
  HeadingLevel1: 4,
  HeadingLevel2: 5,
  HeadingLevel3: 6,
  HeadingLevel4: 7,
  HeadingLevel5: 8,
  HeadingLevel6: 9,
  BoldText: 10,
  ItalicText: 11,
  UnderlineText: 12,
  MisspelledWord: 13,
  Image: 14,
  TextField: 15,
  Table: 16,
  List: 17,
  Landmark: 18,
};

declare const UITextItemInteraction: {
  InvokeDefaultAction: 0,
  PresentActions: 1,
  Preview: 2,
};

declare const NSLineBreakStrategy: {
  None: 0,
  PushOut: 1,
  HangulWordPriority: 2,
  Standard: 65535,
};

declare const UIPopoverArrowDirection: {
  Up: 1,
  Down: 2,
  Left: 4,
  Right: 8,
  Any: 15,
  Unknown: -1,
};

declare const UIFocusHeading: {
  None: 0,
  Up: 1,
  Down: 2,
  Left: 4,
  Right: 8,
  Next: 16,
  Previous: 32,
  First: 256,
  Last: 512,
};

declare const UIKeyModifierFlags: {
  AlphaShift: 65536,
  Shift: 131072,
  Control: 262144,
  Alternate: 524288,
  Command: 1048576,
  NumericPad: 2097152,
};

declare const UIPrintRenderingQuality: {
  Best: 0,
  Responsive: 1,
};

declare const UIMenuElementState: {
  Off: 0,
  On: 1,
  Mixed: 2,
};

declare const UIApplicationState: {
  Active: 0,
  Inactive: 1,
  Background: 2,
};

declare const UIButtonRole: {
  Normal: 0,
  Primary: 1,
  Cancel: 2,
  Destructive: 3,
};

declare const UIKeyboardType: {
  Default: 0,
  ASCIICapable: 1,
  NumbersAndPunctuation: 2,
  URL: 3,
  NumberPad: 4,
  PhonePad: 5,
  NamePhonePad: 6,
  EmailAddress: 7,
  DecimalPad: 8,
  Twitter: 9,
  WebSearch: 10,
  ASCIICapableNumberPad: 11,
  Alphabet: 1,
};

declare const UIAxis: {
  Neither: 0,
  Horizontal: 1,
  Vertical: 2,
  Both: 3,
};

declare const UIWindowSceneDismissalAnimation: {
  Standard: 1,
  Commit: 2,
  Decline: 3,
};

declare const UIDocumentBrowserErrorCode: {
  Generic: 1,
  NoLocationAvailable: 2,
};

declare const UIAccessibilityContrast: {
  Unspecified: -1,
  Normal: 0,
  High: 1,
};

declare const UISystemAnimation: {
  UISystemAnimationDelete: 0,
};

declare const UIMenuControllerArrowDirection: {
  Default: 0,
  Up: 1,
  Down: 2,
  Left: 3,
  Right: 4,
};

declare const UIGestureRecognizerState: {
  Possible: 0,
  Began: 1,
  Changed: 2,
  Ended: 3,
  Cancelled: 4,
  Failed: 5,
  Recognized: 3,
};

declare const UISemanticContentAttribute: {
  Unspecified: 0,
  Playback: 1,
  Spatial: 2,
  ForceLeftToRight: 3,
  ForceRightToLeft: 4,
};

declare const UIBarPosition: {
  Any: 0,
  Bottom: 1,
  Top: 2,
  TopAttached: 3,
};

declare const UISplitViewControllerDisplayModeButtonVisibility: {
  Automatic: 0,
  Never: 1,
  Always: 2,
};

declare const UIDeviceBatteryState: {
  Unknown: 0,
  Unplugged: 1,
  Charging: 2,
  Full: 3,
};

declare const UIInterpolatingMotionEffectType: {
  Horizontal: 0,
  Vertical: 1,
};

declare const UIForceTouchCapability: {
  Unknown: 0,
  Unavailable: 1,
  Available: 2,
};

declare const UIAccessibilityContainerType: {
  None: 0,
  DataTable: 1,
  List: 2,
  Landmark: 3,
  SemanticGroup: 4,
};

declare const UICollectionViewScrollDirection: {
  Vertical: 0,
  Horizontal: 1,
};

declare const UITextSpellCheckingType: {
  Default: 0,
  No: 1,
  Yes: 2,
};

declare const UICloudSharingPermissionOptions: {
  Standard: 0,
  AllowPublic: 1,
  AllowPrivate: 2,
  AllowReadOnly: 4,
  AllowReadWrite: 8,
};

declare const UITextAlternativeStyle: {
  None: 0,
  LowConfidence: 1,
};

declare const UIFocusHaloEffectPosition: {
  Automatic: 0,
  Outside: 1,
  Inside: 2,
};

declare const UIDynamicItemCollisionBoundsType: {
  Rectangle: 0,
  Ellipse: 1,
  Path: 2,
};

declare const UIMenuElementSize: {
  Small: 0,
  Medium: 1,
  Large: 2,
  Automatic: -1,
};

declare const UIImageSymbolScale: {
  Default: -1,
  Unspecified: 0,
  Small: 1,
  Medium: 2,
  Large: 3,
};

declare const UIBaselineAdjustment: {
  AlignBaselines: 0,
  AlignCenters: 1,
  None: 2,
};

declare const UIListContentTextAlignment: {
  Natural: 0,
  Center: 1,
  Justified: 2,
};

declare const UINSToolbarItemPresentationSize: {
  Unspecified: -1,
  Regular: 0,
  Small: 1,
  Large: 3,
};

declare const NSTextLayoutManagerSegmentType: {
  Standard: 0,
  Selection: 1,
  Highlight: 2,
};

declare const UIPencilPreferredAction: {
  Ignore: 0,
  SwitchEraser: 1,
  SwitchPrevious: 2,
  ShowColorPalette: 3,
  ShowInkAttributes: 4,
  ShowContextualPalette: 5,
  RunSystemShortcut: 6,
};

declare const NSTextContentManagerEnumerationOptions: {
  None: 0,
  Reverse: 1,
};

declare const UIViewAnimationOptions: {
  LayoutSubviews: 1,
  AllowUserInteraction: 2,
  BeginFromCurrentState: 4,
  Repeat: 8,
  Autoreverse: 16,
  OverrideInheritedDuration: 32,
  OverrideInheritedCurve: 64,
  AllowAnimatedContent: 128,
  ShowHideTransitionViews: 256,
  OverrideInheritedOptions: 512,
  CurveEaseInOut: 0,
  CurveEaseIn: 65536,
  CurveEaseOut: 131072,
  CurveLinear: 196608,
  TransitionNone: 0,
  TransitionFlipFromLeft: 1048576,
  TransitionFlipFromRight: 2097152,
  TransitionCurlUp: 3145728,
  TransitionCurlDown: 4194304,
  TransitionCrossDissolve: 5242880,
  TransitionFlipFromTop: 6291456,
  TransitionFlipFromBottom: 7340032,
  PreferredFramesPerSecondDefault: 0,
  PreferredFramesPerSecond60: 50331648,
  PreferredFramesPerSecond30: 117440512,
};

declare const UIControlContentVerticalAlignment: {
  Center: 0,
  Top: 1,
  Bottom: 2,
  Fill: 3,
};

declare const NSTextSelectionNavigationDestination: {
  Character: 0,
  Word: 1,
  Line: 2,
  Sentence: 3,
  Paragraph: 4,
  Container: 5,
  Document: 6,
};

declare const UIBackgroundRefreshStatus: {
  Restricted: 0,
  Denied: 1,
  Available: 2,
};

declare const UIPreferredPresentationStyle: {
  Unspecified: 0,
  Inline: 1,
  Attachment: 2,
};

declare const UICollectionViewScrollPosition: {
  None: 0,
  Top: 1,
  CenteredVertically: 2,
  Bottom: 4,
  Left: 8,
  CenteredHorizontally: 16,
  Right: 32,
};

declare const UIUserInterfaceIdiom: {
  Unspecified: -1,
  Phone: 0,
  Pad: 1,
  TV: 2,
  CarPlay: 3,
  Mac: 5,
  Vision: 6,
};

declare const UICellConfigurationDragState: {
  None: 0,
  Lifting: 1,
  Dragging: 2,
};

declare const UIContextMenuInteractionAppearance: {
  Unknown: 0,
  Rich: 1,
  Compact: 2,
};

declare const UIPrinterJobTypes: {
  Unknown: 0,
  Document: 1,
  Envelope: 2,
  Label: 4,
  Photo: 8,
  Receipt: 16,
  Roll: 32,
  LargeFormat: 64,
  Postcard: 128,
};

declare const UIStatusBarAnimation: {
  None: 0,
  Fade: 1,
  Slide: 2,
};

declare const UITableViewDropIntent: {
  Unspecified: 0,
  InsertAtDestinationIndexPath: 1,
  InsertIntoDestinationIndexPath: 2,
  Automatic: 3,
};

declare const UIScrollViewKeyboardDismissMode: {
  None: 0,
  OnDrag: 1,
  Interactive: 2,
  OnDragWithAccessory: 3,
  InteractiveWithAccessory: 4,
};

declare const UIContentUnavailableAlignment: {
  Center: 0,
  Natural: 1,
};

declare const UICalendarViewDecorationSize: {
  Small: 0,
  Medium: 1,
  Large: 2,
};

declare const UISplitViewControllerDisplayMode: {
  Automatic: 0,
  SecondaryOnly: 1,
  OneBesideSecondary: 2,
  OneOverSecondary: 3,
  TwoBesideSecondary: 4,
  TwoOverSecondary: 5,
  TwoDisplaceSecondary: 6,
  PrimaryHidden: 1,
  AllVisible: 2,
  PrimaryOverlay: 3,
};

declare const UITextInlinePredictionType: {
  Default: 0,
  No: 1,
  Yes: 2,
};

declare const UILabelVibrancy: {
  None: 0,
  Automatic: 1,
};

declare const UIFontDescriptorSymbolicTraits: {
  TraitItalic: 1,
  TraitBold: 2,
  TraitExpanded: 32,
  TraitCondensed: 64,
  TraitMonoSpace: 1024,
  TraitVertical: 2048,
  TraitUIOptimized: 4096,
  TraitTightLeading: 32768,
  TraitLooseLeading: 65536,
  ClassMask: -268435456,
  ClassUnknown: 0,
  ClassOldStyleSerifs: 268435456,
  ClassTransitionalSerifs: 536870912,
  ClassModernSerifs: 805306368,
  ClassClarendonSerifs: 1073741824,
  ClassSlabSerifs: 1342177280,
  ClassFreeformSerifs: 1879048192,
  ClassSansSerif: -2147483648,
  ClassOrnamentals: -1879048192,
  ClassScripts: -1610612736,
  ClassSymbolic: -1073741824,
};

declare const UIImagePickerControllerSourceType: {
  PhotoLibrary: 0,
  Camera: 1,
  SavedPhotosAlbum: 2,
};

declare const UIScrollViewContentInsetAdjustmentBehavior: {
  Automatic: 0,
  ScrollableAxes: 1,
  Never: 2,
  Always: 3,
};

declare const UIStatusBarStyle: {
  Default: 0,
  LightContent: 1,
  DarkContent: 3,
  BlackTranslucent: 1,
  BlackOpaque: 2,
};

declare const UISceneErrorCode: {
  MultipleScenesNotSupported: 0,
  RequestDenied: 1,
  GeometryRequestUnsupported: 100,
  GeometryRequestDenied: 101,
};

declare const UIFindSessionSearchResultDisplayStyle: {
  CurrentAndTotal: 0,
  Total: 1,
  None: 2,
};

declare const UIDropSessionProgressIndicatorStyle: {
  None: 0,
  Default: 1,
};

declare const UIImageResizingMode: {
  Tile: 0,
  Stretch: 1,
};

declare const UIApplicationShortcutIconType: {
  Compose: 0,
  Play: 1,
  Pause: 2,
  Add: 3,
  Location: 4,
  Search: 5,
  Share: 6,
  Prohibit: 7,
  Contact: 8,
  Home: 9,
  MarkLocation: 10,
  Favorite: 11,
  Love: 12,
  Cloud: 13,
  Invitation: 14,
  Confirmation: 15,
  Mail: 16,
  Message: 17,
  Date: 18,
  Time: 19,
  CapturePhoto: 20,
  CaptureVideo: 21,
  Task: 22,
  TaskCompleted: 23,
  Alarm: 24,
  Bookmark: 25,
  Shuffle: 26,
  Audio: 27,
  Update: 28,
};

declare const NSTextSelectionNavigationWritingDirection: {
  LeftToRight: 0,
  RightToLeft: 1,
};

declare const NSTextSelectionNavigationLayoutOrientation: {
  Horizontal: 0,
  Vertical: 1,
};

declare const UIWindowScenePresentationStyle: {
  Automatic: 0,
  Standard: 1,
  Prominent: 2,
};

declare const UIButtonConfigurationSize: {
  Medium: 0,
  Small: 1,
  Mini: 2,
  Large: 3,
};

declare const UIEventButtonMask: {
  Primary: 1,
  Secondary: 2,
};

declare const UISegmentedControlSegment: {
  Any: 0,
  Left: 1,
  Center: 2,
  Right: 3,
  Alone: 4,
};

declare const UIDirectionalRectEdge: {
  None: 0,
  Top: 1,
  Leading: 2,
  Bottom: 4,
  Trailing: 8,
  All: 15,
};

declare const UIScrollTypeMask: {
  Discrete: 1,
  Continuous: 2,
  All: 3,
};

declare const UITableViewScrollPosition: {
  None: 0,
  Top: 1,
  Middle: 2,
  Bottom: 3,
};

declare const NSWritingDirection: {
  Natural: -1,
  LeftToRight: 0,
  RightToLeft: 1,
};

declare const UIButtonConfigurationTitleAlignment: {
  Automatic: 0,
  Leading: 1,
  Center: 2,
  Trailing: 3,
};

declare const UIVibrancyEffectStyle: {
  Label: 0,
  SecondaryLabel: 1,
  TertiaryLabel: 2,
  QuaternaryLabel: 3,
  Fill: 4,
  SecondaryFill: 5,
  TertiaryFill: 6,
  Separator: 7,
};

declare const UISpringLoadedInteractionEffectState: {
  Inactive: 0,
  Possible: 1,
  Activating: 2,
  Activated: 3,
};

declare class UIFloatRange {
  constructor(init?: UIFloatRange);
  minimum: number;
  maximum: number;
}

declare class UIEdgeInsets {
  constructor(init?: UIEdgeInsets);
  top: number;
  left: number;
  bottom: number;
  right: number;
}

declare class UIPointerAccessoryPosition {
  constructor(init?: UIPointerAccessoryPosition);
  offset: number;
  angle: number;
}

declare class UIOffset {
  constructor(init?: UIOffset);
  horizontal: number;
  vertical: number;
}

declare class NSDirectionalEdgeInsets {
  constructor(init?: NSDirectionalEdgeInsets);
  top: number;
  leading: number;
  bottom: number;
  trailing: number;
}

declare function NSStringFromCGPoint(point: CGPoint): string;

declare function NSStringFromCGVector(vector: CGVector): string;

declare function NSStringFromCGSize(size: CGSize): string;

declare function NSStringFromCGRect(rect: CGRect): string;

declare function NSStringFromCGAffineTransform(transform: CGAffineTransform): string;

declare function NSStringFromUIEdgeInsets(insets: UIEdgeInsets): string;

declare function NSStringFromDirectionalEdgeInsets(insets: NSDirectionalEdgeInsets): string;

declare function NSStringFromUIOffset(offset: UIOffset): string;

declare function CGPointFromString(string: string): CGPoint;

declare function CGVectorFromString(string: string): CGVector;

declare function CGSizeFromString(string: string): CGSize;

declare function CGRectFromString(string: string): CGRect;

declare function CGAffineTransformFromString(string: string): CGAffineTransform;

declare function UIEdgeInsetsFromString(string: string): UIEdgeInsets;

declare function NSDirectionalEdgeInsetsFromString(string: string): NSDirectionalEdgeInsets;

declare function UIOffsetFromString(string: string): UIOffset;

declare function UIGraphicsGetCurrentContext(): interop.Pointer;

declare function UIGraphicsPushContext(context: interop.PointerConvertible): void;

declare function UIGraphicsPopContext(): void;

declare function UIRectFillUsingBlendMode(rect: CGRect, blendMode: interop.Enum<typeof CGBlendMode>): void;

declare function UIRectFill(rect: CGRect): void;

declare function UIRectFrameUsingBlendMode(rect: CGRect, blendMode: interop.Enum<typeof CGBlendMode>): void;

declare function UIRectFrame(rect: CGRect): void;

declare function UIRectClip(rect: CGRect): void;

declare function UIGraphicsBeginImageContext(size: CGSize): void;

declare function UIGraphicsBeginImageContextWithOptions(size: CGSize, opaque: boolean, scale: number): void;

declare function UIGraphicsGetImageFromCurrentImageContext(): UIImage;

declare function UIGraphicsEndImageContext(): void;

declare function UIGraphicsBeginPDFContextToFile(path: string, bounds: CGRect, documentInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): boolean;

declare function UIGraphicsBeginPDFContextToData(data: NSMutableData, bounds: CGRect, documentInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

declare function UIGraphicsEndPDFContext(): void;

declare function UIGraphicsBeginPDFPage(): void;

declare function UIGraphicsBeginPDFPageWithInfo(bounds: CGRect, pageInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

declare function UIGraphicsGetPDFContextBounds(): CGRect;

declare function UIGraphicsSetPDFContextURLForRect(url: NSURL, rect: CGRect): void;

declare function UIGraphicsAddPDFContextDestinationAtPoint(name: string, point: CGPoint): void;

declare function UIGraphicsSetPDFContextDestinationForRect(name: string, rect: CGRect): void;

declare function UIImagePNGRepresentation(image: UIImage): NSData;

declare function UIImageJPEGRepresentation(image: UIImage, compressionQuality: number): NSData;

declare function UIImageHEICRepresentation(image: UIImage): NSData;

declare function UIFontWeightForImageSymbolWeight(symbolWeight: interop.Enum<typeof UIImageSymbolWeight>): number;

declare function UIImageSymbolWeightForFontWeight(fontWeight: number): interop.Enum<typeof UIImageSymbolWeight>;

declare function NSTextAlignmentToCTTextAlignment(nsTextAlignment: interop.Enum<typeof NSTextAlignment>): interop.Enum<typeof CTTextAlignment>;

declare function NSTextAlignmentFromCTTextAlignment(ctTextAlignment: interop.Enum<typeof CTTextAlignment>): interop.Enum<typeof NSTextAlignment>;

declare function UIEventButtonMaskForButtonNumber(buttonNumber: number): interop.Enum<typeof UIEventButtonMask>;

declare function _NSDictionaryOfVariableBindings(commaSeparatedKeysString: string, firstValue: interop.Object): NSDictionary;

declare function UIContentSizeCategoryIsAccessibilityCategory(category: string): boolean;

declare function UIContentSizeCategoryCompareToCategory(lhs: string, rhs: string): interop.Enum<typeof NSComparisonResult>;

declare function UIApplicationMain(argc: number, argv: interop.PointerConvertible, principalClassName: string, delegateClassName: string): number;

declare function UIAccessibilityZoomFocusChanged(type: interop.Enum<typeof UIAccessibilityZoomType>, frame: CGRect, view: UIView): void;

declare function UIAccessibilityRegisterGestureConflictWithZoom(): void;

declare function UIGuidedAccessRestrictionStateForIdentifier(restrictionIdentifier: string): interop.Enum<typeof UIGuidedAccessRestrictionState>;

declare function UIGuidedAccessConfigureAccessibilityFeatures(features: interop.Enum<typeof UIGuidedAccessAccessibilityFeature>, enabled: boolean, completion: (p1: boolean, p2: NSError) => void): void;

declare function UIAccessibilityConvertFrameToScreenCoordinates(rect: CGRect, view: UIView): CGRect;

declare function UIAccessibilityConvertPathToScreenCoordinates(path: UIBezierPath, view: UIView): UIBezierPath;

declare function UIAccessibilityFocusedElement(assistiveTechnologyIdentifier: string): interop.Object;

declare function UIAccessibilityPostNotification(notification: number, argument: interop.Object): void;

declare function UIAccessibilityIsVoiceOverRunning(): boolean;

declare function UIAccessibilityIsMonoAudioEnabled(): boolean;

declare function UIAccessibilityIsClosedCaptioningEnabled(): boolean;

declare function UIAccessibilityIsInvertColorsEnabled(): boolean;

declare function UIAccessibilityIsGuidedAccessEnabled(): boolean;

declare function UIAccessibilityIsBoldTextEnabled(): boolean;

declare function UIAccessibilityButtonShapesEnabled(): boolean;

declare function UIAccessibilityIsGrayscaleEnabled(): boolean;

declare function UIAccessibilityIsReduceTransparencyEnabled(): boolean;

declare function UIAccessibilityIsReduceMotionEnabled(): boolean;

declare function UIAccessibilityPrefersCrossFadeTransitions(): boolean;

declare function UIAccessibilityIsVideoAutoplayEnabled(): boolean;

declare function UIAccessibilityDarkerSystemColorsEnabled(): boolean;

declare function UIAccessibilityIsSwitchControlRunning(): boolean;

declare function UIAccessibilityIsSpeakSelectionEnabled(): boolean;

declare function UIAccessibilityIsSpeakScreenEnabled(): boolean;

declare function UIAccessibilityIsShakeToUndoEnabled(): boolean;

declare function UIAccessibilityIsAssistiveTouchRunning(): boolean;

declare function UIAccessibilityShouldDifferentiateWithoutColor(): boolean;

declare function UIAccessibilityIsOnOffSwitchLabelsEnabled(): boolean;

declare function UIAccessibilityRequestGuidedAccessSession(enable: boolean, completionHandler: (p1: boolean) => void): void;

declare function UIAccessibilityHearingDevicePairedEar(): interop.Enum<typeof UIAccessibilityHearingDeviceEar>;

declare function UICellAccessoryPositionBeforeAccessoryOfClass(accessoryClass: interop.Object): (p1: NSArray<interop.Object> | Array<interop.Object>) => number;

declare function UICellAccessoryPositionAfterAccessoryOfClass(accessoryClass: interop.Object): (p1: NSArray<interop.Object> | Array<interop.Object>) => number;

declare function UIImageWriteToSavedPhotosAlbum(image: UIImage, completionTarget: interop.Object, completionSelector: string, contextInfo: interop.PointerConvertible): void;

declare function UIVideoAtPathIsCompatibleWithSavedPhotosAlbum(videoPath: string): boolean;

declare function UISaveVideoAtPathToSavedPhotosAlbum(videoPath: string, completionTarget: interop.Object, completionSelector: string, contextInfo: interop.PointerConvertible): void;

declare function UIFloatRangeIsInfinite(range: UIFloatRange): boolean;

declare interface UITextPasteItem extends NSObjectProtocol {
  readonly itemProvider: NSItemProvider;

  readonly localObject: interop.Object;

  readonly defaultAttributes: NSDictionary;

  setStringResult(string: string): void;

  setAttributedStringResult(string: NSAttributedString): void;

  setAttachmentResult(textAttachment: NSTextAttachment): void;

  setNoResult(): void;

  setDefaultResult(): void;
}

declare class UITextPasteItem extends NativeObject implements UITextPasteItem {
}

declare interface UIDragDropSession extends NSObjectProtocol {
  readonly items: NSArray;

  locationInView(view: UIView): CGPoint;

  readonly allowsMoveOperation: boolean;

  readonly isRestrictedToDraggingApplication: boolean;

  hasItemsConformingToTypeIdentifiers(typeIdentifiers: NSArray<interop.Object> | Array<interop.Object>): boolean;

  canLoadObjectsOfClass(aClass: NSItemProviderReading): boolean;
}

declare class UIDragDropSession extends NativeObject implements UIDragDropSession {
}

declare interface UIEditMenuInteractionAnimating extends NSObjectProtocol {
  addAnimations(animations: () => void): void;

  addCompletion(completion: () => void): void;
}

declare class UIEditMenuInteractionAnimating extends NativeObject implements UIEditMenuInteractionAnimating {
}

declare interface UIAppearanceContainer extends NSObjectProtocol {
}

declare class UIAppearanceContainer extends NativeObject implements UIAppearanceContainer {
}

declare interface UITextPasteConfigurationSupporting extends UIPasteConfigurationSupporting {
  pasteDelegate: UITextPasteDelegate;
}

declare class UITextPasteConfigurationSupporting extends NativeObject implements UITextPasteConfigurationSupporting {
}

declare interface UISpringLoadedInteractionEffect extends NSObjectProtocol {
  interactionDidChangeWithContext(interaction: UISpringLoadedInteraction, context: UISpringLoadedInteractionContext): void;
}

declare class UISpringLoadedInteractionEffect extends NativeObject implements UISpringLoadedInteractionEffect {
}

declare interface UIInputViewAudioFeedback extends NSObjectProtocol {
  readonly enableInputClicksWhenVisible?: boolean;
}

declare class UIInputViewAudioFeedback extends NativeObject implements UIInputViewAudioFeedback {
}

declare interface UIContextMenuInteractionDelegate extends NSObjectProtocol {
  contextMenuInteractionConfigurationForMenuAtLocation(interaction: UIContextMenuInteraction, location: CGPoint): UIContextMenuConfiguration;

  contextMenuInteractionConfigurationHighlightPreviewForItemWithIdentifier?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, identifier: NSCopying): UITargetedPreview;

  contextMenuInteractionConfigurationDismissalPreviewForItemWithIdentifier?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, identifier: NSCopying): UITargetedPreview;

  contextMenuInteractionWillPerformPreviewActionForMenuWithConfigurationAnimator?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating): void;

  contextMenuInteractionWillDisplayMenuForConfigurationAnimator?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  contextMenuInteractionWillEndForConfigurationAnimator?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  contextMenuInteractionPreviewForHighlightingMenuWithConfiguration?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration): UITargetedPreview;

  contextMenuInteractionPreviewForDismissingMenuWithConfiguration?(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration): UITargetedPreview;
}

declare class UIContextMenuInteractionDelegate extends NativeObject implements UIContextMenuInteractionDelegate {
}

declare interface UICollectionViewDropItem extends NSObjectProtocol {
  readonly dragItem: UIDragItem;

  readonly sourceIndexPath: NSIndexPath;

  readonly previewSize: CGSize;
}

declare class UICollectionViewDropItem extends NativeObject implements UICollectionViewDropItem {
}

declare interface UILayoutGuideAspectFitting extends NSObjectProtocol {
  aspectRatio: number;
}

declare class UILayoutGuideAspectFitting extends NativeObject implements UILayoutGuideAspectFitting {
}

declare interface UIPrinterPickerControllerDelegate extends NSObjectProtocol {
  printerPickerControllerParentViewController?(printerPickerController: UIPrinterPickerController): UIViewController;

  printerPickerControllerShouldShowPrinter?(printerPickerController: UIPrinterPickerController, printer: UIPrinter): boolean;

  printerPickerControllerWillPresent?(printerPickerController: UIPrinterPickerController): void;

  printerPickerControllerDidPresent?(printerPickerController: UIPrinterPickerController): void;

  printerPickerControllerWillDismiss?(printerPickerController: UIPrinterPickerController): void;

  printerPickerControllerDidDismiss?(printerPickerController: UIPrinterPickerController): void;

  printerPickerControllerDidSelectPrinter?(printerPickerController: UIPrinterPickerController): void;
}

declare class UIPrinterPickerControllerDelegate extends NativeObject implements UIPrinterPickerControllerDelegate {
}

declare interface UIMutableTraits extends NSObjectProtocol {
  setCGFloatValueForTrait(value: number, trait: UICGFloatTraitDefinition): void;

  valueForCGFloatTrait(trait: UICGFloatTraitDefinition): number;

  setNSIntegerValueForTrait(value: number, trait: UINSIntegerTraitDefinition): void;

  valueForNSIntegerTrait(trait: UINSIntegerTraitDefinition): number;

  setObjectForTrait(object: NSObject | null, trait: UIObjectTraitDefinition): void;

  objectForTrait(trait: UIObjectTraitDefinition): NSObject;

  userInterfaceIdiom: interop.Enum<typeof UIUserInterfaceIdiom>;

  userInterfaceStyle: interop.Enum<typeof UIUserInterfaceStyle>;

  layoutDirection: interop.Enum<typeof UITraitEnvironmentLayoutDirection>;

  displayScale: number;

  horizontalSizeClass: interop.Enum<typeof UIUserInterfaceSizeClass>;

  verticalSizeClass: interop.Enum<typeof UIUserInterfaceSizeClass>;

  forceTouchCapability: interop.Enum<typeof UIForceTouchCapability>;

  preferredContentSizeCategory: string;

  displayGamut: interop.Enum<typeof UIDisplayGamut>;

  accessibilityContrast: interop.Enum<typeof UIAccessibilityContrast>;

  userInterfaceLevel: interop.Enum<typeof UIUserInterfaceLevel>;

  legibilityWeight: interop.Enum<typeof UILegibilityWeight>;

  activeAppearance: interop.Enum<typeof UIUserInterfaceActiveAppearance>;

  toolbarItemPresentationSize: interop.Enum<typeof UINSToolbarItemPresentationSize>;

  imageDynamicRange: interop.Enum<typeof UIImageDynamicRange>;

  sceneCaptureState: interop.Enum<typeof UISceneCaptureState>;

  typesettingLanguage: string;
}

declare class UIMutableTraits extends NativeObject implements UIMutableTraits {
}

declare interface UITraitChangeObservable {
  registerForTraitChangesWithHandler(traits: NSArray<interop.Object> | Array<interop.Object>, handler: (p1: UITraitEnvironment, p2: UITraitCollection) => void): UITraitChangeRegistration;

  registerForTraitChangesWithTargetAction(traits: NSArray<interop.Object> | Array<interop.Object>, target: interop.Object, action: string): UITraitChangeRegistration;

  registerForTraitChangesWithAction(traits: NSArray<interop.Object> | Array<interop.Object>, action: string): UITraitChangeRegistration;

  unregisterForTraitChanges(registration: UITraitChangeRegistration): void;
}

declare class UITraitChangeObservable extends NativeObject implements UITraitChangeObservable {
}

declare interface UIActivityItemsConfigurationProviding extends NSObjectProtocol {
  readonly activityItemsConfiguration: UIActivityItemsConfigurationReading;
}

declare class UIActivityItemsConfigurationProviding extends NativeObject implements UIActivityItemsConfigurationProviding {
}

declare interface UITextSelectionHandleView extends UICoordinateSpace {
  direction: interop.Enum<typeof NSDirectionalRectEdge>;

  readonly isVertical: boolean;

  customShape: UIBezierPath;

  preferredFrameForRect(rect: CGRect): CGRect;
}

declare class UITextSelectionHandleView extends NativeObject implements UITextSelectionHandleView {
}

declare interface UIAppearance extends NSObjectProtocol {
}

declare class UIAppearance extends NativeObject implements UIAppearance {
  static appearance<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static appearanceWhenContainedIn<This extends abstract new (...args: any) => any>(this: This, ContainerClass: UIAppearanceContainer | null): InstanceType<This>;

  static appearanceWhenContainedInInstancesOfClasses<This extends abstract new (...args: any) => any>(this: This, containerTypes: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static appearanceForTraitCollection<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection): InstanceType<This>;

  static appearanceForTraitCollectionWhenContainedIn<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection, ContainerClass: UIAppearanceContainer | null): InstanceType<This>;

  static appearanceForTraitCollectionWhenContainedInInstancesOfClasses<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection, containerTypes: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;
}

declare interface UISheetPresentationControllerDelegate extends UIAdaptivePresentationControllerDelegate {
  sheetPresentationControllerDidChangeSelectedDetentIdentifier?(sheetPresentationController: UISheetPresentationController): void;
}

declare class UISheetPresentationControllerDelegate extends NativeObject implements UISheetPresentationControllerDelegate {
}

declare interface UIKeyInput extends UITextInputTraits {
  readonly hasText: boolean;

  insertText(text: string): void;

  deleteBackward(): void;
}

declare class UIKeyInput extends NativeObject implements UIKeyInput {
}

declare interface UIPrintInteractionControllerDelegate extends NSObjectProtocol {
  printInteractionControllerParentViewController?(printInteractionController: UIPrintInteractionController): UIViewController | null;

  printInteractionControllerChoosePaper?(printInteractionController: UIPrintInteractionController, paperList: NSArray<interop.Object> | Array<interop.Object>): UIPrintPaper;

  printInteractionControllerWillPresentPrinterOptions?(printInteractionController: UIPrintInteractionController): void;

  printInteractionControllerDidPresentPrinterOptions?(printInteractionController: UIPrintInteractionController): void;

  printInteractionControllerWillDismissPrinterOptions?(printInteractionController: UIPrintInteractionController): void;

  printInteractionControllerDidDismissPrinterOptions?(printInteractionController: UIPrintInteractionController): void;

  printInteractionControllerWillStartJob?(printInteractionController: UIPrintInteractionController): void;

  printInteractionControllerDidFinishJob?(printInteractionController: UIPrintInteractionController): void;

  printInteractionControllerCutLengthForPaper?(printInteractionController: UIPrintInteractionController, paper: UIPrintPaper): number;

  printInteractionControllerChooseCutterBehavior?(printInteractionController: UIPrintInteractionController, availableBehaviors: NSArray<interop.Object> | Array<interop.Object>): interop.Enum<typeof UIPrinterCutterBehavior>;
}

declare class UIPrintInteractionControllerDelegate extends NativeObject implements UIPrintInteractionControllerDelegate {
}

declare interface NSTextContentStorageDelegate extends NSTextContentManagerDelegate {
  textContentStorageTextParagraphWithRange?(textContentStorage: NSTextContentStorage, range: _NSRange): NSTextParagraph;
}

declare class NSTextContentStorageDelegate extends NativeObject implements NSTextContentStorageDelegate {
}

declare interface NSTextLocation extends NSObjectProtocol {
  compare(location: NSTextLocation): interop.Enum<typeof NSComparisonResult>;
}

declare class NSTextLocation extends NativeObject implements NSTextLocation {
}

declare interface UIPageControlTimerProgressDelegate extends UIPageControlProgressDelegate {
  pageControlTimerProgressDidChange?(progress: UIPageControlTimerProgress): void;

  pageControlTimerProgressShouldAdvanceToPage?(progress: UIPageControlTimerProgress, page: number): boolean;
}

declare class UIPageControlTimerProgressDelegate extends NativeObject implements UIPageControlTimerProgressDelegate {
}

declare interface UICalendarSelectionMultiDateDelegate extends NSObjectProtocol {
  multiDateSelectionDidSelectDate(selection: UICalendarSelectionMultiDate, dateComponents: NSDateComponents): void;

  multiDateSelectionDidDeselectDate(selection: UICalendarSelectionMultiDate, dateComponents: NSDateComponents): void;

  multiDateSelectionCanSelectDate?(selection: UICalendarSelectionMultiDate, dateComponents: NSDateComponents): boolean;

  multiDateSelectionCanDeselectDate?(selection: UICalendarSelectionMultiDate, dateComponents: NSDateComponents): boolean;
}

declare class UICalendarSelectionMultiDateDelegate extends NativeObject implements UICalendarSelectionMultiDateDelegate {
}

declare interface UICalendarSelectionSingleDateDelegate extends NSObjectProtocol {
  dateSelectionDidSelectDate(selection: UICalendarSelectionSingleDate, dateComponents: NSDateComponents | null): void;

  dateSelectionCanSelectDate?(selection: UICalendarSelectionSingleDate, dateComponents: NSDateComponents | null): boolean;
}

declare class UICalendarSelectionSingleDateDelegate extends NativeObject implements UICalendarSelectionSingleDateDelegate {
}

declare interface UITextDraggable extends UITextInput {
  textDragDelegate: UITextDragDelegate;

  readonly textDragInteraction: UIDragInteraction;

  readonly isTextDragActive: boolean;

  textDragOptions: interop.Enum<typeof UITextDragOptions>;
}

declare class UITextDraggable extends NativeObject implements UITextDraggable {
}

declare interface UICalendarViewDelegate extends NSObjectProtocol {
  calendarViewDecorationForDateComponents?(calendarView: UICalendarView, dateComponents: NSDateComponents): UICalendarViewDecoration;

  calendarViewDidChangeVisibleDateComponentsFrom?(calendarView: UICalendarView, previousDateComponents: NSDateComponents): void;
}

declare class UICalendarViewDelegate extends NativeObject implements UICalendarViewDelegate {
}

declare interface UIColorPickerViewControllerDelegate extends NSObjectProtocol {
  colorPickerViewControllerDidSelectColor?(viewController: UIColorPickerViewController): void;

  colorPickerViewControllerDidSelectColorContinuously?(viewController: UIColorPickerViewController, color: UIColor, continuously: boolean): void;

  colorPickerViewControllerDidFinish?(viewController: UIColorPickerViewController): void;
}

declare class UIColorPickerViewControllerDelegate extends NativeObject implements UIColorPickerViewControllerDelegate {
}

declare interface UIPointerInteractionDelegate extends NSObjectProtocol {
  pointerInteractionRegionForRequestDefaultRegion?(interaction: UIPointerInteraction, request: UIPointerRegionRequest, defaultRegion: UIPointerRegion): UIPointerRegion;

  pointerInteractionStyleForRegion?(interaction: UIPointerInteraction, region: UIPointerRegion): UIPointerStyle;

  pointerInteractionWillEnterRegionAnimator?(interaction: UIPointerInteraction, region: UIPointerRegion, animator: UIPointerInteractionAnimating): void;

  pointerInteractionWillExitRegionAnimator?(interaction: UIPointerInteraction, region: UIPointerRegion, animator: UIPointerInteractionAnimating): void;
}

declare class UIPointerInteractionDelegate extends NativeObject implements UIPointerInteractionDelegate {
}

declare interface UITextFormattingCoordinatorDelegate extends NSObjectProtocol {
  updateTextAttributesWithConversionHandler(conversionHandler: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => NSDictionary): void;
}

declare class UITextFormattingCoordinatorDelegate extends NativeObject implements UITextFormattingCoordinatorDelegate {
}

declare interface UIPencilInteractionDelegate extends NSObjectProtocol {
  pencilInteractionDidTap?(interaction: UIPencilInteraction): void;

  pencilInteractionDidReceiveTap?(interaction: UIPencilInteraction, tap: UIPencilInteractionTap): void;

  pencilInteractionDidReceiveSqueeze?(interaction: UIPencilInteraction, squeeze: UIPencilInteractionSqueeze): void;
}

declare class UIPencilInteractionDelegate extends NativeObject implements UIPencilInteractionDelegate {
}

declare interface UIFocusAnimationContext extends NSObjectProtocol {
  readonly duration: number;
}

declare class UIFocusAnimationContext extends NativeObject implements UIFocusAnimationContext {
}

declare interface UITextInteractionDelegate extends NSObjectProtocol {
  interactionShouldBeginAtPoint?(interaction: UITextInteraction, point: CGPoint): boolean;

  interactionWillBegin?(interaction: UITextInteraction): void;

  interactionDidEnd?(interaction: UITextInteraction): void;
}

declare class UITextInteractionDelegate extends NativeObject implements UITextInteractionDelegate {
}

declare interface UITimingCurveProvider extends NSCoding, NSCopying {
  readonly timingCurveType: interop.Enum<typeof UITimingCurveType>;

  readonly cubicTimingParameters: UICubicTimingParameters;

  readonly springTimingParameters: UISpringTimingParameters;
}

declare class UITimingCurveProvider extends NativeObject implements UITimingCurveProvider {
}

declare interface UIDynamicAnimatorDelegate extends NSObjectProtocol {
  dynamicAnimatorWillResume?(animator: UIDynamicAnimator): void;

  dynamicAnimatorDidPause?(animator: UIDynamicAnimator): void;
}

declare class UIDynamicAnimatorDelegate extends NativeObject implements UIDynamicAnimatorDelegate {
}

declare interface UIPasteConfigurationSupporting extends NSObjectProtocol {
  pasteConfiguration: UIPasteConfiguration;

  pasteItemProviders?(itemProviders: NSArray<interop.Object> | Array<interop.Object>): void;

  canPasteItemProviders?(itemProviders: NSArray<interop.Object> | Array<interop.Object>): boolean;
}

declare class UIPasteConfigurationSupporting extends NativeObject implements UIPasteConfigurationSupporting {
}

declare interface UIPopoverPresentationControllerDelegate extends UIAdaptivePresentationControllerDelegate {
  prepareForPopoverPresentation?(popoverPresentationController: UIPopoverPresentationController): void;

  popoverPresentationControllerShouldDismissPopover?(popoverPresentationController: UIPopoverPresentationController): boolean;

  popoverPresentationControllerDidDismissPopover?(popoverPresentationController: UIPopoverPresentationController): void;

  popoverPresentationControllerWillRepositionPopoverToRectInView?(popoverPresentationController: UIPopoverPresentationController, rect: interop.PointerConvertible, view: interop.PointerConvertible): void;
}

declare class UIPopoverPresentationControllerDelegate extends NativeObject implements UIPopoverPresentationControllerDelegate {
}

declare interface UIPopoverPresentationControllerSourceItem extends NSObjectProtocol {
  frameInView(referenceView: UIView): CGRect;
}

declare class UIPopoverPresentationControllerSourceItem extends NativeObject implements UIPopoverPresentationControllerSourceItem {
}

declare interface NSTextAttachmentContainer extends NSObjectProtocol {
  imageForBoundsTextContainerCharacterIndex(imageBounds: CGRect, textContainer: NSTextContainer | null, charIndex: number): UIImage;

  attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(textContainer: NSTextContainer | null, lineFrag: CGRect, position: CGPoint, charIndex: number): CGRect;
}

declare class NSTextAttachmentContainer extends NativeObject implements NSTextAttachmentContainer {
}

declare interface UIPointerInteractionAnimating extends NSObjectProtocol {
  addAnimations(animations: () => void): void;

  addCompletion(completion: (p1: boolean) => void): void;
}

declare class UIPointerInteractionAnimating extends NativeObject implements UIPointerInteractionAnimating {
}

declare interface UIDocumentMenuDelegate extends NSObjectProtocol {
  documentMenuDidPickDocumentPicker(documentMenu: UIDocumentMenuViewController, documentPicker: UIDocumentPickerViewController): void;

  documentMenuWasCancelled?(documentMenu: UIDocumentMenuViewController): void;
}

declare class UIDocumentMenuDelegate extends NativeObject implements UIDocumentMenuDelegate {
}

declare interface UISheetPresentationControllerDetentResolutionContext extends NSObjectProtocol {
  readonly containerTraitCollection: UITraitCollection;

  readonly maximumDetentValue: number;
}

declare class UISheetPresentationControllerDetentResolutionContext extends NativeObject implements UISheetPresentationControllerDetentResolutionContext {
}

declare interface UIPreviewInteractionDelegate extends NSObjectProtocol {
  previewInteractionDidUpdatePreviewTransitionEnded(previewInteraction: UIPreviewInteraction, transitionProgress: number, ended: boolean): void;

  previewInteractionDidCancel(previewInteraction: UIPreviewInteraction): void;

  previewInteractionShouldBegin?(previewInteraction: UIPreviewInteraction): boolean;

  previewInteractionDidUpdateCommitTransitionEnded?(previewInteraction: UIPreviewInteraction, transitionProgress: number, ended: boolean): void;
}

declare class UIPreviewInteractionDelegate extends NativeObject implements UIPreviewInteractionDelegate {
}

declare interface NSLayoutManagerDelegate extends NSObjectProtocol {
  layoutManagerShouldGenerateGlyphsPropertiesCharacterIndexesFontForGlyphRange?(layoutManager: NSLayoutManager, glyphs: interop.PointerConvertible, props: interop.PointerConvertible, charIndexes: interop.PointerConvertible, aFont: UIFont, glyphRange: _NSRange): number;

  layoutManagerLineSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(layoutManager: NSLayoutManager, glyphIndex: number, rect: CGRect): number;

  layoutManagerParagraphSpacingBeforeGlyphAtIndexWithProposedLineFragmentRect?(layoutManager: NSLayoutManager, glyphIndex: number, rect: CGRect): number;

  layoutManagerParagraphSpacingAfterGlyphAtIndexWithProposedLineFragmentRect?(layoutManager: NSLayoutManager, glyphIndex: number, rect: CGRect): number;

  layoutManagerShouldUseActionForControlCharacterAtIndex?(layoutManager: NSLayoutManager, action: interop.Enum<typeof NSControlCharacterAction>, charIndex: number): interop.Enum<typeof NSControlCharacterAction>;

  layoutManagerShouldBreakLineByWordBeforeCharacterAtIndex?(layoutManager: NSLayoutManager, charIndex: number): boolean;

  layoutManagerShouldBreakLineByHyphenatingBeforeCharacterAtIndex?(layoutManager: NSLayoutManager, charIndex: number): boolean;

  layoutManagerBoundingBoxForControlGlyphAtIndexForTextContainerProposedLineFragmentGlyphPositionCharacterIndex?(layoutManager: NSLayoutManager, glyphIndex: number, textContainer: NSTextContainer, proposedRect: CGRect, glyphPosition: CGPoint, charIndex: number): CGRect;

  layoutManagerShouldSetLineFragmentRectLineFragmentUsedRectBaselineOffsetInTextContainerForGlyphRange?(layoutManager: NSLayoutManager, lineFragmentRect: interop.PointerConvertible, lineFragmentUsedRect: interop.PointerConvertible, baselineOffset: interop.PointerConvertible, textContainer: NSTextContainer, glyphRange: _NSRange): boolean;

  layoutManagerDidInvalidateLayout?(sender: NSLayoutManager): void;

  layoutManagerDidCompleteLayoutForTextContainerAtEnd?(layoutManager: NSLayoutManager, textContainer: NSTextContainer | null, layoutFinishedFlag: boolean): void;

  layoutManagerTextContainerDidChangeGeometryFromSize?(layoutManager: NSLayoutManager, textContainer: NSTextContainer, oldSize: CGSize): void;
}

declare class NSLayoutManagerDelegate extends NativeObject implements NSLayoutManagerDelegate {
}

declare interface UIViewAnimating extends NSObjectProtocol {
  readonly state: interop.Enum<typeof UIViewAnimatingState>;

  readonly isRunning: boolean;

  isReversed: boolean;

  fractionComplete: number;

  startAnimation(): void;

  startAnimationAfterDelay(delay: number): void;

  pauseAnimation(): void;

  stopAnimation(withoutFinishing: boolean): void;

  finishAnimationAtPosition(finalPosition: interop.Enum<typeof UIViewAnimatingPosition>): void;
}

declare class UIViewAnimating extends NativeObject implements UIViewAnimating {
}

declare interface UILargeContentViewerItem extends NSObjectProtocol {
  readonly showsLargeContentViewer: boolean;

  readonly largeContentTitle: string;

  readonly largeContentImage: UIImage;

  readonly scalesLargeContentImage: boolean;

  readonly largeContentImageInsets: UIEdgeInsets;
}

declare class UILargeContentViewerItem extends NativeObject implements UILargeContentViewerItem {
}

declare interface UIViewControllerInteractiveTransitioning extends NSObjectProtocol {
  startInteractiveTransition(transitionContext: UIViewControllerContextTransitioning): void;

  readonly completionSpeed?: number;

  readonly completionCurve?: interop.Enum<typeof UIViewAnimationCurve>;

  readonly wantsInteractiveStart?: boolean;
}

declare class UIViewControllerInteractiveTransitioning extends NativeObject implements UIViewControllerInteractiveTransitioning {
}

declare interface NSTextStorageObserving extends NSObjectProtocol {
  textStorage: NSTextStorage;

  processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(textStorage: NSTextStorage, editMask: interop.Enum<typeof NSTextStorageEditActions>, newCharRange: _NSRange, delta: number, invalidatedCharRange: _NSRange): void;

  performEditingTransactionForTextStorageUsingBlock(textStorage: NSTextStorage, transaction: () => void): void;
}

declare class NSTextStorageObserving extends NativeObject implements NSTextStorageObserving {
}

declare interface UIScribbleInteractionDelegate extends NSObjectProtocol {
  scribbleInteractionShouldBeginAtLocation?(interaction: UIScribbleInteraction, location: CGPoint): boolean;

  scribbleInteractionShouldDelayFocus?(interaction: UIScribbleInteraction): boolean;

  scribbleInteractionWillBeginWriting?(interaction: UIScribbleInteraction): void;

  scribbleInteractionDidFinishWriting?(interaction: UIScribbleInteraction): void;
}

declare class UIScribbleInteractionDelegate extends NativeObject implements UIScribbleInteractionDelegate {
}

declare interface UISearchTextFieldPasteItem extends UITextPasteItem {
  setSearchTokenResult(token: UISearchToken): void;
}

declare class UISearchTextFieldPasteItem extends NativeObject implements UISearchTextFieldPasteItem {
}

declare interface UISearchSuggestion extends NSObjectProtocol {
  readonly localizedSuggestion: string;

  readonly localizedDescription?: string;

  readonly iconImage?: UIImage;

  readonly localizedAttributedSuggestion: NSAttributedString;

  representedObject: interop.Object;
}

declare class UISearchSuggestion extends NativeObject implements UISearchSuggestion {
}

declare interface UIAccessibilityContentSizeCategoryImageAdjusting extends NSObjectProtocol {
  adjustsImageSizeForAccessibilityContentSizeCategory: boolean;
}

declare class UIAccessibilityContentSizeCategoryImageAdjusting extends NativeObject implements UIAccessibilityContentSizeCategoryImageAdjusting {
}

declare interface UISpringLoadedInteractionBehavior extends NSObjectProtocol {
  shouldAllowInteractionWithContext(interaction: UISpringLoadedInteraction, context: UISpringLoadedInteractionContext): boolean;

  interactionDidFinish?(interaction: UISpringLoadedInteraction): void;
}

declare class UISpringLoadedInteractionBehavior extends NativeObject implements UISpringLoadedInteractionBehavior {
}

declare interface UIDragSession extends UIDragDropSession {
  localContext: interop.Object;
}

declare class UIDragSession extends NativeObject implements UIDragSession {
}

declare interface UITextSearching extends NSObjectProtocol {
  readonly selectedTextRange: UITextRange;

  compareFoundRangeToRangeInDocument(foundRange: UITextRange, toRange: UITextRange, document: NSCopying | null): interop.Enum<typeof NSComparisonResult>;

  performTextSearchWithQueryStringUsingOptionsResultAggregator(string: string, options: UITextSearchOptions, aggregator: UITextSearchAggregator): void;

  decorateFoundTextRangeInDocumentUsingStyle(range: UITextRange, document: NSCopying | null, style: interop.Enum<typeof UITextSearchFoundTextStyle>): void;

  clearAllDecoratedFoundText(): void;

  readonly supportsTextReplacement?: boolean;

  shouldReplaceFoundTextInRangeInDocumentWithText?(range: UITextRange, document: NSCopying | null, replacementText: string): boolean;

  replaceFoundTextInRangeInDocumentWithText?(range: UITextRange, document: NSCopying | null, replacementText: string): void;

  replaceAllOccurrencesOfQueryStringUsingOptionsWithText?(queryString: string, options: UITextSearchOptions, replacementText: string): void;

  willHighlightFoundTextRangeInDocument?(range: UITextRange, document: NSCopying | null): void;

  scrollRangeToVisibleInDocument?(range: UITextRange, document: NSCopying | null): void;

  readonly selectedTextSearchDocument?: NSCopying;

  compareOrderFromDocumentToDocument?(fromDocument: NSCopying, toDocument: NSCopying): interop.Enum<typeof NSComparisonResult>;
}

declare class UITextSearching extends NativeObject implements UITextSearching {
}

declare interface UIMenuBuilder {
  readonly system: UIMenuSystem;

  menuForIdentifier(identifier: string): UIMenu;

  actionForIdentifier(identifier: string): UIAction;

  commandForActionPropertyList(action: string, propertyList: interop.Object | null): UICommand;

  replaceMenuForIdentifierWithMenu(replacedIdentifier: string, replacementMenu: UIMenu): void;

  replaceChildrenOfMenuForIdentifierFromChildrenBlock(parentIdentifier: string, childrenBlock: (p1: NSArray<interop.Object> | Array<interop.Object>) => NSArray): void;

  insertSiblingMenuBeforeMenuForIdentifier(siblingMenu: UIMenu, siblingIdentifier: string): void;

  insertSiblingMenuAfterMenuForIdentifier(siblingMenu: UIMenu, siblingIdentifier: string): void;

  insertChildMenuAtStartOfMenuForIdentifier(childMenu: UIMenu, parentIdentifier: string): void;

  insertChildMenuAtEndOfMenuForIdentifier(childMenu: UIMenu, parentIdentifier: string): void;

  removeMenuForIdentifier(removedIdentifier: string): void;
}

declare class UIMenuBuilder extends NativeObject implements UIMenuBuilder {
}

declare interface NSTextSelectionDataSource extends NSObjectProtocol {
  readonly documentRange: NSTextRange;

  enumerateSubstringsFromLocationOptionsUsingBlock(location: NSTextLocation, options: interop.Enum<typeof NSStringEnumerationOptions>, block: (p1: string, p2: NSTextRange, p3: NSTextRange, p4: interop.PointerConvertible) => void | null): void;

  textRangeForSelectionGranularityEnclosingLocation(selectionGranularity: interop.Enum<typeof NSTextSelectionGranularity>, location: NSTextLocation): NSTextRange;

  locationFromLocationWithOffset(location: NSTextLocation, offset: number): NSTextLocation;

  offsetFromLocationToLocation(from: NSTextLocation, to: NSTextLocation): number;

  baseWritingDirectionAtLocation(location: NSTextLocation): interop.Enum<typeof NSTextSelectionNavigationWritingDirection>;

  enumerateCaretOffsetsInLineFragmentAtLocationUsingBlock(location: NSTextLocation, block: (p1: number, p2: NSTextLocation, p3: boolean, p4: interop.PointerConvertible) => void): void;

  lineFragmentRangeForPointInContainerAtLocation(point: CGPoint, location: NSTextLocation): NSTextRange;

  enumerateContainerBoundariesFromLocationReverseUsingBlock?(location: NSTextLocation, reverse: boolean, block: (p1: NSTextLocation, p2: interop.PointerConvertible) => void): void;

  textLayoutOrientationAtLocation?(location: NSTextLocation): interop.Enum<typeof NSTextSelectionNavigationLayoutOrientation>;
}

declare class NSTextSelectionDataSource extends NativeObject implements NSTextSelectionDataSource {
}

declare interface UIVideoEditorControllerDelegate extends NSObjectProtocol {
  videoEditorControllerDidSaveEditedVideoToPath?(editor: UIVideoEditorController, editedVideoPath: string): void;

  videoEditorControllerDidFailWithError?(editor: UIVideoEditorController, error: NSError): void;

  videoEditorControllerDidCancel?(editor: UIVideoEditorController): void;
}

declare class UIVideoEditorControllerDelegate extends NativeObject implements UIVideoEditorControllerDelegate {
}

declare interface UIStateRestoring extends NSObjectProtocol {
  readonly restorationParent?: UIStateRestoring;

  readonly objectRestorationClass?: UIObjectRestoration;

  encodeRestorableStateWithCoder?(coder: NSCoder): void;

  decodeRestorableStateWithCoder?(coder: NSCoder): void;

  applicationFinishedRestoringState?(): void;
}

declare class UIStateRestoring extends NativeObject implements UIStateRestoring {
}

declare interface UIToolbarDelegate extends UIBarPositioningDelegate {
}

declare class UIToolbarDelegate extends NativeObject implements UIToolbarDelegate {
}

declare interface UITextViewDelegate extends NSObjectProtocol, UIScrollViewDelegate {
  textViewShouldBeginEditing?(textView: UITextView): boolean;

  textViewShouldEndEditing?(textView: UITextView): boolean;

  textViewDidBeginEditing?(textView: UITextView): void;

  textViewDidEndEditing?(textView: UITextView): void;

  textViewShouldChangeTextInRangeReplacementText?(textView: UITextView, range: _NSRange, text: string): boolean;

  textViewDidChange?(textView: UITextView): void;

  textViewDidChangeSelection?(textView: UITextView): void;

  textViewEditMenuForTextInRangeSuggestedActions?(textView: UITextView, range: _NSRange, suggestedActions: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  textViewWillPresentEditMenuWithAnimator?(textView: UITextView, animator: UIEditMenuInteractionAnimating): void;

  textViewWillDismissEditMenuWithAnimator?(textView: UITextView, animator: UIEditMenuInteractionAnimating): void;

  textViewPrimaryActionForTextItemDefaultAction?(textView: UITextView, textItem: UITextItem, defaultAction: UIAction): UIAction;

  textViewMenuConfigurationForTextItemDefaultMenu?(textView: UITextView, textItem: UITextItem, defaultMenu: UIMenu): UITextItemMenuConfiguration;

  textViewTextItemMenuWillDisplayForTextItemAnimator?(textView: UITextView, textItem: UITextItem, animator: UIContextMenuInteractionAnimating): void;

  textViewTextItemMenuWillEndForTextItemAnimator?(textView: UITextView, textItem: UITextItem, animator: UIContextMenuInteractionAnimating): void;

  textViewShouldInteractWithURLInRangeInteraction?(textView: UITextView, URL: NSURL, characterRange: _NSRange, interaction: interop.Enum<typeof UITextItemInteraction>): boolean;

  textViewShouldInteractWithTextAttachmentInRangeInteraction?(textView: UITextView, textAttachment: NSTextAttachment, characterRange: _NSRange, interaction: interop.Enum<typeof UITextItemInteraction>): boolean;

  textViewShouldInteractWithURLInRange?(textView: UITextView, URL: NSURL, characterRange: _NSRange): boolean;

  textViewShouldInteractWithTextAttachmentInRange?(textView: UITextView, textAttachment: NSTextAttachment, characterRange: _NSRange): boolean;
}

declare class UITextViewDelegate extends NativeObject implements UITextViewDelegate {
}

declare interface UITextSelectionDisplayInteractionDelegate extends NSObjectProtocol {
  selectionContainerViewBelowTextForSelectionDisplayInteraction?(interaction: UITextSelectionDisplayInteraction): UIView;
}

declare class UITextSelectionDisplayInteractionDelegate extends NativeObject implements UITextSelectionDisplayInteractionDelegate {
}

declare interface UITextSearchAggregator extends NSObjectProtocol {
  readonly allFoundRanges: NSOrderedSet;

  foundRangeForSearchStringInDocument(range: UITextRange, string: string, document: NSCopying | null): void;

  invalidateFoundRangeInDocument(range: UITextRange, document: NSCopying | null): void;

  invalidate(): void;

  finishedSearching(): void;
}

declare class UITextSearchAggregator extends NativeObject implements UITextSearchAggregator {
}

declare interface UIActivityItemSource extends NSObjectProtocol {
  activityViewControllerPlaceholderItem(activityViewController: UIActivityViewController): interop.Object;

  activityViewControllerItemForActivityType(activityViewController: UIActivityViewController, activityType: string | null): interop.Object;

  activityViewControllerSubjectForActivityType?(activityViewController: UIActivityViewController, activityType: string | null): string;

  activityViewControllerDataTypeIdentifierForActivityType?(activityViewController: UIActivityViewController, activityType: string | null): string;

  activityViewControllerThumbnailImageForActivityTypeSuggestedSize?(activityViewController: UIActivityViewController, activityType: string | null, size: CGSize): UIImage;

  activityViewControllerLinkMetadata?(activityViewController: UIActivityViewController): interop.Object;
}

declare class UIActivityItemSource extends NativeObject implements UIActivityItemSource {
}

declare interface UITabBarControllerDelegate extends NSObjectProtocol {
  tabBarControllerShouldSelectViewController?(tabBarController: UITabBarController, viewController: UIViewController): boolean;

  tabBarControllerDidSelectViewController?(tabBarController: UITabBarController, viewController: UIViewController): void;

  tabBarControllerWillBeginCustomizingViewControllers?(tabBarController: UITabBarController, viewControllers: NSArray<interop.Object> | Array<interop.Object>): void;

  tabBarControllerWillEndCustomizingViewControllersChanged?(tabBarController: UITabBarController, viewControllers: NSArray<interop.Object> | Array<interop.Object>, changed: boolean): void;

  tabBarControllerDidEndCustomizingViewControllersChanged?(tabBarController: UITabBarController, viewControllers: NSArray<interop.Object> | Array<interop.Object>, changed: boolean): void;

  tabBarControllerSupportedInterfaceOrientations?(tabBarController: UITabBarController): interop.Enum<typeof UIInterfaceOrientationMask>;

  tabBarControllerPreferredInterfaceOrientationForPresentation?(tabBarController: UITabBarController): interop.Enum<typeof UIInterfaceOrientation>;

  tabBarControllerInteractionControllerForAnimationController?(tabBarController: UITabBarController, animationController: UIViewControllerAnimatedTransitioning): UIViewControllerInteractiveTransitioning;

  tabBarControllerAnimationControllerForTransitionFromViewControllerToViewController?(tabBarController: UITabBarController, fromVC: UIViewController, toVC: UIViewController): UIViewControllerAnimatedTransitioning;
}

declare class UITabBarControllerDelegate extends NativeObject implements UITabBarControllerDelegate {
}

declare interface UISearchControllerDelegate extends NSObjectProtocol {
  willPresentSearchController?(searchController: UISearchController): void;

  didPresentSearchController?(searchController: UISearchController): void;

  willDismissSearchController?(searchController: UISearchController): void;

  didDismissSearchController?(searchController: UISearchController): void;

  presentSearchController?(searchController: UISearchController): void;

  searchControllerWillChangeToSearchBarPlacement?(searchController: UISearchController, newPlacement: interop.Enum<typeof UINavigationItemSearchBarPlacement>): void;

  searchControllerDidChangeFromSearchBarPlacement?(searchController: UISearchController, previousPlacement: interop.Enum<typeof UINavigationItemSearchBarPlacement>): void;
}

declare class UISearchControllerDelegate extends NativeObject implements UISearchControllerDelegate {
}

declare interface UILookToDictateCapable extends NSObjectProtocol {
  isLookToDictateEnabled: boolean;
}

declare class UILookToDictateCapable extends NativeObject implements UILookToDictateCapable {
}

declare interface UIApplicationDelegate extends NSObjectProtocol {
  applicationDidFinishLaunching?(application: UIApplication): void;

  applicationWillFinishLaunchingWithOptions?(application: UIApplication, launchOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): boolean;

  applicationDidFinishLaunchingWithOptions?(application: UIApplication, launchOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): boolean;

  applicationDidBecomeActive?(application: UIApplication): void;

  applicationWillResignActive?(application: UIApplication): void;

  applicationHandleOpenURL?(application: UIApplication, url: NSURL): boolean;

  applicationOpenURLSourceApplicationAnnotation?(application: UIApplication, url: NSURL, sourceApplication: string | null, annotation: interop.Object): boolean;

  applicationOpenURLOptions?(app: UIApplication, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): boolean;

  applicationDidReceiveMemoryWarning?(application: UIApplication): void;

  applicationWillTerminate?(application: UIApplication): void;

  applicationSignificantTimeChange?(application: UIApplication): void;

  applicationWillChangeStatusBarOrientationDuration?(application: UIApplication, newStatusBarOrientation: interop.Enum<typeof UIInterfaceOrientation>, duration: number): void;

  applicationDidChangeStatusBarOrientation?(application: UIApplication, oldStatusBarOrientation: interop.Enum<typeof UIInterfaceOrientation>): void;

  applicationWillChangeStatusBarFrame?(application: UIApplication, newStatusBarFrame: CGRect): void;

  applicationDidChangeStatusBarFrame?(application: UIApplication, oldStatusBarFrame: CGRect): void;

  applicationDidRegisterUserNotificationSettings?(application: UIApplication, notificationSettings: UIUserNotificationSettings): void;

  applicationDidRegisterForRemoteNotificationsWithDeviceToken?(application: UIApplication, deviceToken: NSData): void;

  applicationDidFailToRegisterForRemoteNotificationsWithError?(application: UIApplication, error: NSError): void;

  applicationDidReceiveRemoteNotification?(application: UIApplication, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  applicationDidReceiveLocalNotification?(application: UIApplication, notification: UILocalNotification): void;

  applicationHandleActionWithIdentifierForLocalNotificationCompletionHandler?(application: UIApplication, identifier: string | null, notification: UILocalNotification, completionHandler: () => void): void;

  applicationHandleActionWithIdentifierForRemoteNotificationWithResponseInfoCompletionHandler?(application: UIApplication, identifier: string | null, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, responseInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: () => void): void;

  applicationHandleActionWithIdentifierForRemoteNotificationCompletionHandler?(application: UIApplication, identifier: string | null, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: () => void): void;

  applicationHandleActionWithIdentifierForLocalNotificationWithResponseInfoCompletionHandler?(application: UIApplication, identifier: string | null, notification: UILocalNotification, responseInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: () => void): void;

  applicationDidReceiveRemoteNotificationFetchCompletionHandler?(application: UIApplication, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completionHandler: (p1: interop.Enum<typeof UIBackgroundFetchResult>) => void): void;

  applicationPerformFetchWithCompletionHandler?(application: UIApplication, completionHandler: (p1: interop.Enum<typeof UIBackgroundFetchResult>) => void): void;

  applicationPerformActionForShortcutItemCompletionHandler?(application: UIApplication, shortcutItem: UIApplicationShortcutItem, completionHandler: (p1: boolean) => void): void;

  applicationHandleEventsForBackgroundURLSessionCompletionHandler?(application: UIApplication, identifier: string, completionHandler: () => void): void;

  applicationHandleWatchKitExtensionRequestReply?(application: UIApplication, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, reply: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => void | null): void;

  applicationShouldRequestHealthAuthorization?(application: UIApplication): void;

  applicationHandlerForIntent?(application: UIApplication, intent: INIntent): interop.Object;

  applicationHandleIntentCompletionHandler?(application: UIApplication, intent: INIntent, completionHandler: (p1: INIntentResponse) => void): void;

  applicationDidEnterBackground?(application: UIApplication): void;

  applicationWillEnterForeground?(application: UIApplication): void;

  applicationProtectedDataWillBecomeUnavailable?(application: UIApplication): void;

  applicationProtectedDataDidBecomeAvailable?(application: UIApplication): void;

  window?: UIWindow;

  applicationSupportedInterfaceOrientationsForWindow?(application: UIApplication, window: UIWindow | null): interop.Enum<typeof UIInterfaceOrientationMask>;

  applicationShouldAllowExtensionPointIdentifier?(application: UIApplication, extensionPointIdentifier: string): boolean;

  applicationViewControllerWithRestorationIdentifierPathCoder?(application: UIApplication, identifierComponents: NSArray<interop.Object> | Array<interop.Object>, coder: NSCoder): UIViewController;

  applicationShouldSaveSecureApplicationState?(application: UIApplication, coder: NSCoder): boolean;

  applicationShouldRestoreSecureApplicationState?(application: UIApplication, coder: NSCoder): boolean;

  applicationWillEncodeRestorableStateWithCoder?(application: UIApplication, coder: NSCoder): void;

  applicationDidDecodeRestorableStateWithCoder?(application: UIApplication, coder: NSCoder): void;

  applicationShouldSaveApplicationState?(application: UIApplication, coder: NSCoder): boolean;

  applicationShouldRestoreApplicationState?(application: UIApplication, coder: NSCoder): boolean;

  applicationWillContinueUserActivityWithType?(application: UIApplication, userActivityType: string): boolean;

  applicationContinueUserActivityRestorationHandler?(application: UIApplication, userActivity: NSUserActivity, restorationHandler: (p1: NSArray<interop.Object> | Array<interop.Object>) => void | null): boolean;

  applicationDidFailToContinueUserActivityWithTypeError?(application: UIApplication, userActivityType: string, error: NSError): void;

  applicationDidUpdateUserActivity?(application: UIApplication, userActivity: NSUserActivity): void;

  applicationUserDidAcceptCloudKitShareWithMetadata?(application: UIApplication, cloudKitShareMetadata: CKShareMetadata): void;

  applicationConfigurationForConnectingSceneSessionOptions?(application: UIApplication, connectingSceneSession: UISceneSession, options: UISceneConnectionOptions): UISceneConfiguration;

  applicationDidDiscardSceneSessions?(application: UIApplication, sceneSessions: NSSet): void;

  applicationShouldAutomaticallyLocalizeKeyCommands?(application: UIApplication): boolean;
}

declare class UIApplicationDelegate extends NativeObject implements UIApplicationDelegate {
}

declare interface UIPopoverControllerDelegate extends NSObjectProtocol {
  popoverControllerShouldDismissPopover?(popoverController: UIPopoverController): boolean;

  popoverControllerDidDismissPopover?(popoverController: UIPopoverController): void;

  popoverControllerWillRepositionPopoverToRectInView?(popoverController: UIPopoverController, rect: interop.PointerConvertible, view: interop.PointerConvertible): void;
}

declare class UIPopoverControllerDelegate extends NativeObject implements UIPopoverControllerDelegate {
}

declare interface UIPickerViewDataSource extends NSObjectProtocol {
  numberOfComponentsInPickerView(pickerView: UIPickerView): number;

  pickerViewNumberOfRowsInComponent(pickerView: UIPickerView, component: number): number;
}

declare class UIPickerViewDataSource extends NativeObject implements UIPickerViewDataSource {
}

declare interface UIPageViewControllerDataSource extends NSObjectProtocol {
  pageViewControllerViewControllerBeforeViewController(pageViewController: UIPageViewController, viewController: UIViewController): UIViewController;

  pageViewControllerViewControllerAfterViewController(pageViewController: UIPageViewController, viewController: UIViewController): UIViewController;

  presentationCountForPageViewController?(pageViewController: UIPageViewController): number;

  presentationIndexForPageViewController?(pageViewController: UIPageViewController): number;
}

declare class UIPageViewControllerDataSource extends NativeObject implements UIPageViewControllerDataSource {
}

declare interface UITableViewDataSource extends NSObjectProtocol {
  tableViewNumberOfRowsInSection(tableView: UITableView, section: number): number;

  tableViewCellForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UITableViewCell;

  numberOfSectionsInTableView?(tableView: UITableView): number;

  tableViewTitleForHeaderInSection?(tableView: UITableView, section: number): string;

  tableViewTitleForFooterInSection?(tableView: UITableView, section: number): string;

  tableViewCanEditRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewCanMoveRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  sectionIndexTitlesForTableView?(tableView: UITableView): NSArray;

  tableViewSectionForSectionIndexTitleAtIndex?(tableView: UITableView, title: string, index: number): number;

  tableViewCommitEditingStyleForRowAtIndexPath?(tableView: UITableView, editingStyle: interop.Enum<typeof UITableViewCellEditingStyle>, indexPath: NSIndexPath): void;

  tableViewMoveRowAtIndexPathToIndexPath?(tableView: UITableView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;
}

declare class UITableViewDataSource extends NativeObject implements UITableViewDataSource {
}

declare interface UIPageViewControllerDelegate extends NSObjectProtocol {
  pageViewControllerWillTransitionToViewControllers?(pageViewController: UIPageViewController, pendingViewControllers: NSArray<interop.Object> | Array<interop.Object>): void;

  pageViewControllerDidFinishAnimatingPreviousViewControllersTransitionCompleted?(pageViewController: UIPageViewController, finished: boolean, previousViewControllers: NSArray<interop.Object> | Array<interop.Object>, completed: boolean): void;

  pageViewControllerSpineLocationForInterfaceOrientation?(pageViewController: UIPageViewController, orientation: interop.Enum<typeof UIInterfaceOrientation>): interop.Enum<typeof UIPageViewControllerSpineLocation>;

  pageViewControllerSupportedInterfaceOrientations?(pageViewController: UIPageViewController): interop.Enum<typeof UIInterfaceOrientationMask>;

  pageViewControllerPreferredInterfaceOrientationForPresentation?(pageViewController: UIPageViewController): interop.Enum<typeof UIInterfaceOrientation>;
}

declare class UIPageViewControllerDelegate extends NativeObject implements UIPageViewControllerDelegate {
}

declare interface UIShapeProvider extends NSObjectProtocol {
  resolvedShapeInContext(context: UIShapeResolutionContext): UIResolvedShape;
}

declare class UIShapeProvider extends NativeObject implements UIShapeProvider {
}

declare interface UIHoverEffect extends NSObjectProtocol, NSCopying {
}

declare class UIHoverEffect extends NativeObject implements UIHoverEffect {
}

declare interface UIImagePickerControllerDelegate extends NSObjectProtocol {
  imagePickerControllerDidFinishPickingImageEditingInfo?(picker: UIImagePickerController, image: UIImage, editingInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  imagePickerControllerDidFinishPickingMediaWithInfo?(picker: UIImagePickerController, info: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  imagePickerControllerDidCancel?(picker: UIImagePickerController): void;
}

declare class UIImagePickerControllerDelegate extends NativeObject implements UIImagePickerControllerDelegate {
}

declare interface UINavigationControllerDelegate extends NSObjectProtocol {
  navigationControllerWillShowViewControllerAnimated?(navigationController: UINavigationController, viewController: UIViewController, animated: boolean): void;

  navigationControllerDidShowViewControllerAnimated?(navigationController: UINavigationController, viewController: UIViewController, animated: boolean): void;

  navigationControllerSupportedInterfaceOrientations?(navigationController: UINavigationController): interop.Enum<typeof UIInterfaceOrientationMask>;

  navigationControllerPreferredInterfaceOrientationForPresentation?(navigationController: UINavigationController): interop.Enum<typeof UIInterfaceOrientation>;

  navigationControllerInteractionControllerForAnimationController?(navigationController: UINavigationController, animationController: UIViewControllerAnimatedTransitioning): UIViewControllerInteractiveTransitioning;

  navigationControllerAnimationControllerForOperationFromViewControllerToViewController?(navigationController: UINavigationController, operation: interop.Enum<typeof UINavigationControllerOperation>, fromVC: UIViewController, toVC: UIViewController): UIViewControllerAnimatedTransitioning;
}

declare class UINavigationControllerDelegate extends NativeObject implements UINavigationControllerDelegate {
}

declare interface UIScrollViewDelegate extends NSObjectProtocol {
  scrollViewDidScroll?(scrollView: UIScrollView): void;

  scrollViewDidZoom?(scrollView: UIScrollView): void;

  scrollViewWillBeginDragging?(scrollView: UIScrollView): void;

  scrollViewWillEndDraggingWithVelocityTargetContentOffset?(scrollView: UIScrollView, velocity: CGPoint, targetContentOffset: interop.PointerConvertible): void;

  scrollViewDidEndDraggingWillDecelerate?(scrollView: UIScrollView, decelerate: boolean): void;

  scrollViewWillBeginDecelerating?(scrollView: UIScrollView): void;

  scrollViewDidEndDecelerating?(scrollView: UIScrollView): void;

  scrollViewDidEndScrollingAnimation?(scrollView: UIScrollView): void;

  viewForZoomingInScrollView?(scrollView: UIScrollView): UIView;

  scrollViewWillBeginZoomingWithView?(scrollView: UIScrollView, view: UIView | null): void;

  scrollViewDidEndZoomingWithViewAtScale?(scrollView: UIScrollView, view: UIView | null, scale: number): void;

  scrollViewShouldScrollToTop?(scrollView: UIScrollView): boolean;

  scrollViewDidScrollToTop?(scrollView: UIScrollView): void;

  scrollViewDidChangeAdjustedContentInset?(scrollView: UIScrollView): void;
}

declare class UIScrollViewDelegate extends NativeObject implements UIScrollViewDelegate {
}

declare interface UITextDroppable extends UITextInput, UITextPasteConfigurationSupporting {
  textDropDelegate: UITextDropDelegate;

  readonly textDropInteraction: UIDropInteraction;

  readonly isTextDropActive: boolean;
}

declare class UITextDroppable extends NativeObject implements UITextDroppable {
}

declare interface UITableViewDropPlaceholderContext extends UIDragAnimating {
  readonly dragItem: UIDragItem;

  commitInsertionWithDataSourceUpdates(dataSourceUpdates: (p1: NSIndexPath) => void): boolean;

  deletePlaceholder(): boolean;
}

declare class UITableViewDropPlaceholderContext extends NativeObject implements UITableViewDropPlaceholderContext {
}

declare interface NSTextViewportLayoutControllerDelegate extends NSObjectProtocol {
  viewportBoundsForTextViewportLayoutController(textViewportLayoutController: NSTextViewportLayoutController): CGRect;

  textViewportLayoutControllerConfigureRenderingSurfaceForTextLayoutFragment(textViewportLayoutController: NSTextViewportLayoutController, textLayoutFragment: NSTextLayoutFragment): void;

  textViewportLayoutControllerWillLayout?(textViewportLayoutController: NSTextViewportLayoutController): void;

  textViewportLayoutControllerDidLayout?(textViewportLayoutController: NSTextViewportLayoutController): void;
}

declare class NSTextViewportLayoutControllerDelegate extends NativeObject implements NSTextViewportLayoutControllerDelegate {
}

declare interface UIFocusDebuggerOutput extends NSObjectProtocol {
}

declare class UIFocusDebuggerOutput extends NativeObject implements UIFocusDebuggerOutput {
}

declare interface UIContentConfiguration extends NSObjectProtocol, NSCopying {
  makeContentView(): UIView;

  updatedConfigurationForState(state: UIConfigurationState): this;
}

declare class UIContentConfiguration extends NativeObject implements UIContentConfiguration {
}

declare interface UITableViewDropItem extends NSObjectProtocol {
  readonly dragItem: UIDragItem;

  readonly sourceIndexPath: NSIndexPath;

  readonly previewSize: CGSize;
}

declare class UITableViewDropItem extends NativeObject implements UITableViewDropItem {
}

declare interface UITextFieldDelegate extends NSObjectProtocol {
  textFieldShouldBeginEditing?(textField: UITextField): boolean;

  textFieldDidBeginEditing?(textField: UITextField): void;

  textFieldShouldEndEditing?(textField: UITextField): boolean;

  textFieldDidEndEditing?(textField: UITextField): void;

  textFieldDidEndEditingReason?(textField: UITextField, reason: interop.Enum<typeof UITextFieldDidEndEditingReason>): void;

  textFieldShouldChangeCharactersInRangeReplacementString?(textField: UITextField, range: _NSRange, string: string): boolean;

  textFieldDidChangeSelection?(textField: UITextField): void;

  textFieldShouldClear?(textField: UITextField): boolean;

  textFieldShouldReturn?(textField: UITextField): boolean;

  textFieldEditMenuForCharactersInRangeSuggestedActions?(textField: UITextField, range: _NSRange, suggestedActions: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  textFieldWillPresentEditMenuWithAnimator?(textField: UITextField, animator: UIEditMenuInteractionAnimating): void;

  textFieldWillDismissEditMenuWithAnimator?(textField: UITextField, animator: UIEditMenuInteractionAnimating): void;
}

declare class UITextFieldDelegate extends NativeObject implements UITextFieldDelegate {
}

declare interface UIContextMenuInteractionAnimating extends NSObjectProtocol {
  readonly previewViewController: UIViewController;

  addAnimations(animations: () => void): void;

  addCompletion(completion: () => void): void;
}

declare class UIContextMenuInteractionAnimating extends NativeObject implements UIContextMenuInteractionAnimating {
}

declare interface UIIndirectScribbleInteractionDelegate extends NSObjectProtocol {
  indirectScribbleInteractionRequestElementsInRectCompletion(interaction: UIIndirectScribbleInteraction, rect: CGRect, completion: (p1: NSArray<interop.Object> | Array<interop.Object>) => void): void;

  indirectScribbleInteractionIsElementFocused(interaction: UIIndirectScribbleInteraction, elementIdentifier: NSCopying): boolean;

  indirectScribbleInteractionFrameForElement(interaction: UIIndirectScribbleInteraction, elementIdentifier: NSCopying): CGRect;

  indirectScribbleInteractionFocusElementIfNeededReferencePointCompletion(interaction: UIIndirectScribbleInteraction, elementIdentifier: NSCopying, focusReferencePoint: CGPoint, completion: (p1: UIResponder) => void | null): void;

  indirectScribbleInteractionShouldDelayFocusForElement?(interaction: UIIndirectScribbleInteraction, elementIdentifier: NSCopying): boolean;

  indirectScribbleInteractionWillBeginWritingInElement?(interaction: UIIndirectScribbleInteraction, elementIdentifier: NSCopying): void;

  indirectScribbleInteractionDidFinishWritingInElement?(interaction: UIIndirectScribbleInteraction, elementIdentifier: NSCopying): void;
}

declare class UIIndirectScribbleInteractionDelegate extends NativeObject implements UIIndirectScribbleInteractionDelegate {
}

declare interface UITableViewDropDelegate extends NSObjectProtocol {
  tableViewPerformDropWithCoordinator(tableView: UITableView, coordinator: UITableViewDropCoordinator): void;

  tableViewCanHandleDropSession?(tableView: UITableView, session: UIDropSession): boolean;

  tableViewDropSessionDidEnter?(tableView: UITableView, session: UIDropSession): void;

  tableViewDropSessionDidUpdateWithDestinationIndexPath?(tableView: UITableView, session: UIDropSession, destinationIndexPath: NSIndexPath | null): UITableViewDropProposal;

  tableViewDropSessionDidExit?(tableView: UITableView, session: UIDropSession): void;

  tableViewDropSessionDidEnd?(tableView: UITableView, session: UIDropSession): void;

  tableViewDropPreviewParametersForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): UIDragPreviewParameters;
}

declare class UITableViewDropDelegate extends NativeObject implements UITableViewDropDelegate {
}

declare interface UIFontPickerViewControllerDelegate extends NSObjectProtocol {
  fontPickerViewControllerDidCancel?(viewController: UIFontPickerViewController): void;

  fontPickerViewControllerDidPickFont?(viewController: UIFontPickerViewController): void;
}

declare class UIFontPickerViewControllerDelegate extends NativeObject implements UIFontPickerViewControllerDelegate {
}

declare interface UITableViewDragDelegate extends NSObjectProtocol {
  tableViewItemsForBeginningDragSessionAtIndexPath(tableView: UITableView, session: UIDragSession, indexPath: NSIndexPath): NSArray;

  tableViewItemsForAddingToDragSessionAtIndexPathPoint?(tableView: UITableView, session: UIDragSession, indexPath: NSIndexPath, point: CGPoint): NSArray;

  tableViewDragPreviewParametersForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): UIDragPreviewParameters;

  tableViewDragSessionWillBegin?(tableView: UITableView, session: UIDragSession): void;

  tableViewDragSessionDidEnd?(tableView: UITableView, session: UIDragSession): void;

  tableViewDragSessionAllowsMoveOperation?(tableView: UITableView, session: UIDragSession): boolean;

  tableViewDragSessionIsRestrictedToDraggingApplication?(tableView: UITableView, session: UIDragSession): boolean;
}

declare class UITableViewDragDelegate extends NativeObject implements UITableViewDragDelegate {
}

declare interface UILargeContentViewerInteractionDelegate extends NSObjectProtocol {
  largeContentViewerInteractionDidEndOnItemAtPoint?(interaction: UILargeContentViewerInteraction, item: UILargeContentViewerItem | null, point: CGPoint): void;

  largeContentViewerInteractionItemAtPoint?(interaction: UILargeContentViewerInteraction, point: CGPoint): UILargeContentViewerItem;

  viewControllerForLargeContentViewerInteraction?(interaction: UILargeContentViewerInteraction): UIViewController;
}

declare class UILargeContentViewerInteractionDelegate extends NativeObject implements UILargeContentViewerInteractionDelegate {
}

declare interface UITextPasteDelegate extends NSObjectProtocol {
  textPasteConfigurationSupportingTransformPasteItem?(textPasteConfigurationSupporting: UITextPasteConfigurationSupporting, item: UITextPasteItem): void;

  textPasteConfigurationSupportingCombineItemAttributedStringsForRange?(textPasteConfigurationSupporting: UITextPasteConfigurationSupporting, itemStrings: NSArray<interop.Object> | Array<interop.Object>, textRange: UITextRange): NSAttributedString;

  textPasteConfigurationSupportingPerformPasteOfAttributedStringToRange?(textPasteConfigurationSupporting: UITextPasteConfigurationSupporting, attributedString: NSAttributedString, textRange: UITextRange): UITextRange;

  textPasteConfigurationSupportingShouldAnimatePasteOfAttributedStringToRange?(textPasteConfigurationSupporting: UITextPasteConfigurationSupporting, attributedString: NSAttributedString, textRange: UITextRange): boolean;
}

declare class UITextPasteDelegate extends NativeObject implements UITextPasteDelegate {
}

declare interface UIConfigurationState extends NSObjectProtocol, NSCopying, NSSecureCoding {
  initWithTraitCollection(traitCollection: UITraitCollection): this;

  traitCollection: UITraitCollection;

  customStateForKey(key: string): interop.Object;

  setCustomStateForKey(customState: interop.Object | null, key: string): void;

  objectForKeyedSubscript(key: string): interop.Object;

  setObjectForKeyedSubscript(obj: interop.Object | null, key: string): void;
}

declare class UIConfigurationState extends NativeObject implements UIConfigurationState {
}

declare interface UITableViewDelegate extends NSObjectProtocol, UIScrollViewDelegate {
  tableViewWillDisplayCellForRowAtIndexPath?(tableView: UITableView, cell: UITableViewCell, indexPath: NSIndexPath): void;

  tableViewWillDisplayHeaderViewForSection?(tableView: UITableView, view: UIView, section: number): void;

  tableViewWillDisplayFooterViewForSection?(tableView: UITableView, view: UIView, section: number): void;

  tableViewDidEndDisplayingCellForRowAtIndexPath?(tableView: UITableView, cell: UITableViewCell, indexPath: NSIndexPath): void;

  tableViewDidEndDisplayingHeaderViewForSection?(tableView: UITableView, view: UIView, section: number): void;

  tableViewDidEndDisplayingFooterViewForSection?(tableView: UITableView, view: UIView, section: number): void;

  tableViewHeightForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;

  tableViewHeightForHeaderInSection?(tableView: UITableView, section: number): number;

  tableViewHeightForFooterInSection?(tableView: UITableView, section: number): number;

  tableViewEstimatedHeightForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;

  tableViewEstimatedHeightForHeaderInSection?(tableView: UITableView, section: number): number;

  tableViewEstimatedHeightForFooterInSection?(tableView: UITableView, section: number): number;

  tableViewViewForHeaderInSection?(tableView: UITableView, section: number): UIView;

  tableViewViewForFooterInSection?(tableView: UITableView, section: number): UIView;

  tableViewAccessoryTypeForRowWithIndexPath?(tableView: UITableView, indexPath: NSIndexPath): interop.Enum<typeof UITableViewCellAccessoryType>;

  tableViewAccessoryButtonTappedForRowWithIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewShouldHighlightRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewDidHighlightRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidUnhighlightRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewWillSelectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): NSIndexPath;

  tableViewWillDeselectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): NSIndexPath;

  tableViewDidSelectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidDeselectRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewCanPerformPrimaryActionForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewPerformPrimaryActionForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewEditingStyleForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): interop.Enum<typeof UITableViewCellEditingStyle>;

  tableViewTitleForDeleteConfirmationButtonForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): string;

  tableViewEditActionsForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): NSArray;

  tableViewLeadingSwipeActionsConfigurationForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): UISwipeActionsConfiguration;

  tableViewTrailingSwipeActionsConfigurationForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): UISwipeActionsConfiguration;

  tableViewShouldIndentWhileEditingRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewWillBeginEditingRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidEndEditingRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath | null): void;

  tableViewTargetIndexPathForMoveFromRowAtIndexPathToProposedIndexPath?(tableView: UITableView, sourceIndexPath: NSIndexPath, proposedDestinationIndexPath: NSIndexPath): NSIndexPath;

  tableViewIndentationLevelForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): number;

  tableViewShouldShowMenuForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewCanPerformActionForRowAtIndexPathWithSender?(tableView: UITableView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): boolean;

  tableViewPerformActionForRowAtIndexPathWithSender?(tableView: UITableView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): void;

  tableViewCanFocusRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewShouldUpdateFocusInContext?(tableView: UITableView, context: UITableViewFocusUpdateContext): boolean;

  tableViewDidUpdateFocusInContextWithAnimationCoordinator?(tableView: UITableView, context: UITableViewFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  indexPathForPreferredFocusedViewInTableView?(tableView: UITableView): NSIndexPath;

  tableViewSelectionFollowsFocusForRowAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewShouldSpringLoadRowAtIndexPathWithContext?(tableView: UITableView, indexPath: NSIndexPath, context: UISpringLoadedInteractionContext): boolean;

  tableViewShouldBeginMultipleSelectionInteractionAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewDidBeginMultipleSelectionInteractionAtIndexPath?(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidEndMultipleSelectionInteraction?(tableView: UITableView): void;

  tableViewContextMenuConfigurationForRowAtIndexPathPoint?(tableView: UITableView, indexPath: NSIndexPath, point: CGPoint): UIContextMenuConfiguration;

  tableViewPreviewForHighlightingContextMenuWithConfiguration?(tableView: UITableView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  tableViewPreviewForDismissingContextMenuWithConfiguration?(tableView: UITableView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  tableViewWillPerformPreviewActionForMenuWithConfigurationAnimator?(tableView: UITableView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating): void;

  tableViewWillDisplayContextMenuWithConfigurationAnimator?(tableView: UITableView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  tableViewWillEndContextMenuInteractionWithConfigurationAnimator?(tableView: UITableView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;
}

declare class UITableViewDelegate extends NativeObject implements UITableViewDelegate {
}

declare interface UIViewControllerTransitionCoordinatorContext extends NSObjectProtocol {
  readonly isAnimated: boolean;

  readonly presentationStyle: interop.Enum<typeof UIModalPresentationStyle>;

  readonly initiallyInteractive: boolean;

  readonly isInterruptible: boolean;

  readonly isInteractive: boolean;

  readonly isCancelled: boolean;

  readonly transitionDuration: number;

  readonly percentComplete: number;

  readonly completionVelocity: number;

  readonly completionCurve: interop.Enum<typeof UIViewAnimationCurve>;

  viewControllerForKey(key: string): UIViewController;

  viewForKey(key: string): UIView;

  readonly containerView: UIView;

  readonly targetTransform: CGAffineTransform;
}

declare class UIViewControllerTransitionCoordinatorContext extends NativeObject implements UIViewControllerTransitionCoordinatorContext {
}

declare interface UICollisionBehaviorDelegate extends NSObjectProtocol {
  collisionBehaviorBeganContactForItemWithItemAtPoint?(behavior: UICollisionBehavior, item1: UIDynamicItem, item2: UIDynamicItem, p: CGPoint): void;

  collisionBehaviorEndedContactForItemWithItem?(behavior: UICollisionBehavior, item1: UIDynamicItem, item2: UIDynamicItem): void;

  collisionBehaviorBeganContactForItemWithBoundaryIdentifierAtPoint?(behavior: UICollisionBehavior, item: UIDynamicItem, identifier: NSCopying | null, p: CGPoint): void;

  collisionBehaviorEndedContactForItemWithBoundaryIdentifier?(behavior: UICollisionBehavior, item: UIDynamicItem, identifier: NSCopying | null): void;
}

declare class UICollisionBehaviorDelegate extends NativeObject implements UICollisionBehaviorDelegate {
}

declare interface UIDropSession extends UIDragDropSession, NSProgressReporting {
  readonly localDragSession: UIDragSession;

  progressIndicatorStyle: interop.Enum<typeof UIDropSessionProgressIndicatorStyle>;

  loadObjectsOfClassCompletion(aClass: NSItemProviderReading, completion: (p1: NSArray<interop.Object> | Array<interop.Object>) => void): NSProgress;
}

declare class UIDropSession extends NativeObject implements UIDropSession {
}

declare interface NSCollectionLayoutVisibleItem extends NSObjectProtocol, UIDynamicItem {
  alpha: number;

  zIndex: number;

  isHidden: boolean;

  center: CGPoint;

  transform: CGAffineTransform;

  transform3D: CATransform3D;

  readonly name: string;

  readonly indexPath: NSIndexPath;

  readonly frame: CGRect;

  readonly bounds: CGRect;

  readonly representedElementCategory: interop.Enum<typeof UICollectionElementCategory>;

  readonly representedElementKind: string;
}

declare class NSCollectionLayoutVisibleItem extends NativeObject implements NSCollectionLayoutVisibleItem {
}

declare interface UIActionSheetDelegate extends NSObjectProtocol {
  actionSheetClickedButtonAtIndex?(actionSheet: UIActionSheet, buttonIndex: number): void;

  actionSheetCancel?(actionSheet: UIActionSheet): void;

  willPresentActionSheet?(actionSheet: UIActionSheet): void;

  didPresentActionSheet?(actionSheet: UIActionSheet): void;

  actionSheetWillDismissWithButtonIndex?(actionSheet: UIActionSheet, buttonIndex: number): void;

  actionSheetDidDismissWithButtonIndex?(actionSheet: UIActionSheet, buttonIndex: number): void;
}

declare class UIActionSheetDelegate extends NativeObject implements UIActionSheetDelegate {
}

declare interface UIAccessibilityReadingContent {
  accessibilityLineNumberForPoint(point: CGPoint): number;

  accessibilityContentForLineNumber(lineNumber: number): string;

  accessibilityFrameForLineNumber(lineNumber: number): CGRect;

  accessibilityPageContent(): string;

  accessibilityAttributedContentForLineNumber?(lineNumber: number): NSAttributedString;

  accessibilityAttributedPageContent?(): NSAttributedString;
}

declare class UIAccessibilityReadingContent extends NativeObject implements UIAccessibilityReadingContent {
}

declare interface UITextCursorView extends UICoordinateSpace {
  isBlinking: boolean;

  resetBlinkAnimation(): void;
}

declare class UITextCursorView extends NativeObject implements UITextCursorView {
}

declare interface UICollectionViewDelegateFlowLayout extends UICollectionViewDelegate {
  collectionViewLayoutSizeForItemAtIndexPath?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, indexPath: NSIndexPath): CGSize;

  collectionViewLayoutInsetForSectionAtIndex?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): UIEdgeInsets;

  collectionViewLayoutMinimumLineSpacingForSectionAtIndex?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): number;

  collectionViewLayoutMinimumInteritemSpacingForSectionAtIndex?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): number;

  collectionViewLayoutReferenceSizeForHeaderInSection?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): CGSize;

  collectionViewLayoutReferenceSizeForFooterInSection?(collectionView: UICollectionView, collectionViewLayout: UICollectionViewLayout, section: number): CGSize;
}

declare class UICollectionViewDelegateFlowLayout extends NativeObject implements UICollectionViewDelegateFlowLayout {
}

declare interface UISearchBarDelegate extends UIBarPositioningDelegate {
  searchBarShouldBeginEditing?(searchBar: UISearchBar): boolean;

  searchBarTextDidBeginEditing?(searchBar: UISearchBar): void;

  searchBarShouldEndEditing?(searchBar: UISearchBar): boolean;

  searchBarTextDidEndEditing?(searchBar: UISearchBar): void;

  searchBarTextDidChange?(searchBar: UISearchBar, searchText: string): void;

  searchBarShouldChangeTextInRangeReplacementText?(searchBar: UISearchBar, range: _NSRange, text: string): boolean;

  searchBarSearchButtonClicked?(searchBar: UISearchBar): void;

  searchBarBookmarkButtonClicked?(searchBar: UISearchBar): void;

  searchBarCancelButtonClicked?(searchBar: UISearchBar): void;

  searchBarResultsListButtonClicked?(searchBar: UISearchBar): void;

  searchBarSelectedScopeButtonIndexDidChange?(searchBar: UISearchBar, selectedScope: number): void;
}

declare class UISearchBarDelegate extends NativeObject implements UISearchBarDelegate {
}

declare interface UICollectionViewDropDelegate extends NSObjectProtocol {
  collectionViewPerformDropWithCoordinator(collectionView: UICollectionView, coordinator: UICollectionViewDropCoordinator): void;

  collectionViewCanHandleDropSession?(collectionView: UICollectionView, session: UIDropSession): boolean;

  collectionViewDropSessionDidEnter?(collectionView: UICollectionView, session: UIDropSession): void;

  collectionViewDropSessionDidUpdateWithDestinationIndexPath?(collectionView: UICollectionView, session: UIDropSession, destinationIndexPath: NSIndexPath | null): UICollectionViewDropProposal;

  collectionViewDropSessionDidExit?(collectionView: UICollectionView, session: UIDropSession): void;

  collectionViewDropSessionDidEnd?(collectionView: UICollectionView, session: UIDropSession): void;

  collectionViewDropPreviewParametersForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): UIDragPreviewParameters;
}

declare class UICollectionViewDropDelegate extends NativeObject implements UICollectionViewDropDelegate {
}

declare interface UIToolTipInteractionDelegate extends NSObjectProtocol {
  toolTipInteractionConfigurationAtPoint?(interaction: UIToolTipInteraction, point: CGPoint): UIToolTipConfiguration;
}

declare class UIToolTipInteractionDelegate extends NativeObject implements UIToolTipInteractionDelegate {
}

declare interface UIViewControllerPreviewingDelegate extends NSObjectProtocol {
  previewingContextViewControllerForLocation(previewingContext: UIViewControllerPreviewing, location: CGPoint): UIViewController;

  previewingContextCommitViewController(previewingContext: UIViewControllerPreviewing, viewControllerToCommit: UIViewController): void;
}

declare class UIViewControllerPreviewingDelegate extends NativeObject implements UIViewControllerPreviewingDelegate {
}

declare interface UICollectionViewDragDelegate extends NSObjectProtocol {
  collectionViewItemsForBeginningDragSessionAtIndexPath(collectionView: UICollectionView, session: UIDragSession, indexPath: NSIndexPath): NSArray;

  collectionViewItemsForAddingToDragSessionAtIndexPathPoint?(collectionView: UICollectionView, session: UIDragSession, indexPath: NSIndexPath, point: CGPoint): NSArray;

  collectionViewDragPreviewParametersForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): UIDragPreviewParameters;

  collectionViewDragSessionWillBegin?(collectionView: UICollectionView, session: UIDragSession): void;

  collectionViewDragSessionDidEnd?(collectionView: UICollectionView, session: UIDragSession): void;

  collectionViewDragSessionAllowsMoveOperation?(collectionView: UICollectionView, session: UIDragSession): boolean;

  collectionViewDragSessionIsRestrictedToDraggingApplication?(collectionView: UICollectionView, session: UIDragSession): boolean;
}

declare class UICollectionViewDragDelegate extends NativeObject implements UICollectionViewDragDelegate {
}

declare interface UITextSelectionHighlightView extends UICoordinateSpace {
  get selectionRects(): NSArray;
  set selectionRects(value: NSArray<interop.Object> | Array<interop.Object>);
}

declare class UITextSelectionHighlightView extends NativeObject implements UITextSelectionHighlightView {
}

declare interface UIUserActivityRestoring extends NSObjectProtocol {
  restoreUserActivityState(userActivity: NSUserActivity): void;
}

declare class UIUserActivityRestoring extends NativeObject implements UIUserActivityRestoring {
}

declare interface UISpringLoadedInteractionContext extends NSObjectProtocol {
  readonly state: interop.Enum<typeof UISpringLoadedInteractionEffectState>;

  targetView: UIView;

  targetItem: interop.Object;

  locationInView(view: UIView | null): CGPoint;
}

declare class UISpringLoadedInteractionContext extends NativeObject implements UISpringLoadedInteractionContext {
}

declare interface UITraitChangeRegistration extends NSObjectProtocol, NSCopying {
}

declare class UITraitChangeRegistration extends NativeObject implements UITraitChangeRegistration {
}

declare interface UIPickerViewDelegate extends NSObjectProtocol {
  pickerViewWidthForComponent?(pickerView: UIPickerView, component: number): number;

  pickerViewRowHeightForComponent?(pickerView: UIPickerView, component: number): number;

  pickerViewTitleForRowForComponent?(pickerView: UIPickerView, row: number, component: number): string;

  pickerViewAttributedTitleForRowForComponent?(pickerView: UIPickerView, row: number, component: number): NSAttributedString;

  pickerViewViewForRowForComponentReusingView?(pickerView: UIPickerView, row: number, component: number, view: UIView | null): UIView;

  pickerViewDidSelectRowInComponent?(pickerView: UIPickerView, row: number, component: number): void;
}

declare class UIPickerViewDelegate extends NativeObject implements UIPickerViewDelegate {
}

declare interface UIDataSourceTranslating extends NSObjectProtocol {
  presentationSectionIndexForDataSourceSectionIndex(dataSourceSectionIndex: number): number;

  dataSourceSectionIndexForPresentationSectionIndex(presentationSectionIndex: number): number;

  presentationIndexPathForDataSourceIndexPath(dataSourceIndexPath: NSIndexPath | null): NSIndexPath;

  dataSourceIndexPathForPresentationIndexPath(presentationIndexPath: NSIndexPath | null): NSIndexPath;

  performUsingPresentationValues(actionsToTranslate: () => void): void;
}

declare class UIDataSourceTranslating extends NativeObject implements UIDataSourceTranslating {
}

declare interface UIActivityItemsConfigurationReading extends NSObjectProtocol {
  readonly itemProvidersForActivityItemsConfiguration: NSArray;

  activityItemsConfigurationSupportsInteraction?(interaction: string): boolean;

  activityItemsConfigurationMetadataForKey?(key: string): interop.Object;

  activityItemsConfigurationMetadataForItemAtIndexKey?(index: number, key: string): interop.Object;

  activityItemsConfigurationPreviewForItemAtIndexIntentSuggestedSize?(index: number, intent: string, suggestedSize: CGSize): NSItemProvider;

  readonly applicationActivitiesForActivityItemsConfiguration?: NSArray;
}

declare class UIActivityItemsConfigurationReading extends NativeObject implements UIActivityItemsConfigurationReading {
}

declare interface UIViewControllerTransitioningDelegate extends NSObjectProtocol {
  animationControllerForPresentedControllerPresentingControllerSourceController?(presented: UIViewController, presenting: UIViewController, source: UIViewController): UIViewControllerAnimatedTransitioning;

  animationControllerForDismissedController?(dismissed: UIViewController): UIViewControllerAnimatedTransitioning;

  interactionControllerForPresentation?(animator: UIViewControllerAnimatedTransitioning): UIViewControllerInteractiveTransitioning;

  interactionControllerForDismissal?(animator: UIViewControllerAnimatedTransitioning): UIViewControllerInteractiveTransitioning;

  presentationControllerForPresentedViewControllerPresentingViewControllerSourceViewController?(presented: UIViewController, presenting: UIViewController | null, source: UIViewController): UIPresentationController;
}

declare class UIViewControllerTransitioningDelegate extends NativeObject implements UIViewControllerTransitioningDelegate {
}

declare interface UITableViewDropCoordinator extends NSObjectProtocol {
  readonly items: NSArray;

  readonly destinationIndexPath: NSIndexPath;

  readonly proposal: UITableViewDropProposal;

  readonly session: UIDropSession;

  dropItemToPlaceholder(dragItem: UIDragItem, placeholder: UITableViewDropPlaceholder): UITableViewDropPlaceholderContext;

  dropItemToRowAtIndexPath(dragItem: UIDragItem, indexPath: NSIndexPath): UIDragAnimating;

  dropItemIntoRowAtIndexPathRect(dragItem: UIDragItem, indexPath: NSIndexPath, rect: CGRect): UIDragAnimating;

  dropItemToTarget(dragItem: UIDragItem, target: UIDragPreviewTarget): UIDragAnimating;
}

declare class UITableViewDropCoordinator extends NativeObject implements UITableViewDropCoordinator {
}

declare interface UIFocusItemContainer extends NSObjectProtocol {
  readonly coordinateSpace: UICoordinateSpace;

  focusItemsInRect(rect: CGRect): NSArray;
}

declare class UIFocusItemContainer extends NativeObject implements UIFocusItemContainer {
}

declare interface UIGuidedAccessRestrictionDelegate extends NSObjectProtocol {
  readonly guidedAccessRestrictionIdentifiers: NSArray;

  guidedAccessRestrictionWithIdentifierDidChangeState(restrictionIdentifier: string, newRestrictionState: interop.Enum<typeof UIGuidedAccessRestrictionState>): void;

  textForGuidedAccessRestrictionWithIdentifier(restrictionIdentifier: string): string;

  detailTextForGuidedAccessRestrictionWithIdentifier?(restrictionIdentifier: string): string;
}

declare class UIGuidedAccessRestrictionDelegate extends NativeObject implements UIGuidedAccessRestrictionDelegate {
}

declare interface UIEditMenuInteractionDelegate extends NSObjectProtocol {
  editMenuInteractionMenuForConfigurationSuggestedActions?(interaction: UIEditMenuInteraction, configuration: UIEditMenuConfiguration, suggestedActions: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  editMenuInteractionTargetRectForConfiguration?(interaction: UIEditMenuInteraction, configuration: UIEditMenuConfiguration): CGRect;

  editMenuInteractionWillPresentMenuForConfigurationAnimator?(interaction: UIEditMenuInteraction, configuration: UIEditMenuConfiguration, animator: UIEditMenuInteractionAnimating): void;

  editMenuInteractionWillDismissMenuForConfigurationAnimator?(interaction: UIEditMenuInteraction, configuration: UIEditMenuConfiguration, animator: UIEditMenuInteractionAnimating): void;
}

declare class UIEditMenuInteractionDelegate extends NativeObject implements UIEditMenuInteractionDelegate {
}

declare interface UIAccessibilityIdentification extends NSObjectProtocol {
  accessibilityIdentifier: string;
}

declare class UIAccessibilityIdentification extends NativeObject implements UIAccessibilityIdentification {
}

declare interface UICollectionViewDelegate extends UIScrollViewDelegate {
  collectionViewShouldHighlightItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewDidHighlightItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewDidUnhighlightItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewShouldSelectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewShouldDeselectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewDidSelectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewDidDeselectItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewCanPerformPrimaryActionForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewPerformPrimaryActionForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewWillDisplayCellForItemAtIndexPath?(collectionView: UICollectionView, cell: UICollectionViewCell, indexPath: NSIndexPath): void;

  collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath?(collectionView: UICollectionView, view: UICollectionReusableView, elementKind: string, indexPath: NSIndexPath): void;

  collectionViewDidEndDisplayingCellForItemAtIndexPath?(collectionView: UICollectionView, cell: UICollectionViewCell, indexPath: NSIndexPath): void;

  collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath?(collectionView: UICollectionView, view: UICollectionReusableView, elementKind: string, indexPath: NSIndexPath): void;

  collectionViewShouldShowMenuForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewCanPerformActionForItemAtIndexPathWithSender?(collectionView: UICollectionView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): boolean;

  collectionViewPerformActionForItemAtIndexPathWithSender?(collectionView: UICollectionView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): void;

  collectionViewTransitionLayoutForOldLayoutNewLayout?(collectionView: UICollectionView, fromLayout: UICollectionViewLayout, toLayout: UICollectionViewLayout): UICollectionViewTransitionLayout;

  collectionViewCanFocusItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewShouldUpdateFocusInContext?(collectionView: UICollectionView, context: UICollectionViewFocusUpdateContext): boolean;

  collectionViewDidUpdateFocusInContextWithAnimationCoordinator?(collectionView: UICollectionView, context: UICollectionViewFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  indexPathForPreferredFocusedViewInCollectionView?(collectionView: UICollectionView): NSIndexPath;

  collectionViewSelectionFollowsFocusForItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewTargetIndexPathForMoveOfItemFromOriginalIndexPathAtCurrentIndexPathToProposedIndexPath?(collectionView: UICollectionView, originalIndexPath: NSIndexPath, currentIndexPath: NSIndexPath, proposedIndexPath: NSIndexPath): NSIndexPath;

  collectionViewTargetIndexPathForMoveFromItemAtIndexPathToProposedIndexPath?(collectionView: UICollectionView, currentIndexPath: NSIndexPath, proposedIndexPath: NSIndexPath): NSIndexPath;

  collectionViewTargetContentOffsetForProposedContentOffset?(collectionView: UICollectionView, proposedContentOffset: CGPoint): CGPoint;

  collectionViewCanEditItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewShouldSpringLoadItemAtIndexPathWithContext?(collectionView: UICollectionView, indexPath: NSIndexPath, context: UISpringLoadedInteractionContext): boolean;

  collectionViewShouldBeginMultipleSelectionInteractionAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewDidBeginMultipleSelectionInteractionAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewDidEndMultipleSelectionInteraction?(collectionView: UICollectionView): void;

  collectionViewContextMenuConfigurationForItemsAtIndexPathsPoint?(collectionView: UICollectionView, indexPaths: NSArray<interop.Object> | Array<interop.Object>, point: CGPoint): UIContextMenuConfiguration;

  collectionViewContextMenuConfigurationHighlightPreviewForItemAtIndexPath?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, indexPath: NSIndexPath): UITargetedPreview;

  collectionViewContextMenuConfigurationDismissalPreviewForItemAtIndexPath?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, indexPath: NSIndexPath): UITargetedPreview;

  collectionViewWillPerformPreviewActionForMenuWithConfigurationAnimator?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating): void;

  collectionViewWillDisplayContextMenuWithConfigurationAnimator?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  collectionViewWillEndContextMenuInteractionWithConfigurationAnimator?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  collectionViewSceneActivationConfigurationForItemAtIndexPathPoint?(collectionView: UICollectionView, indexPath: NSIndexPath, point: CGPoint): UIWindowSceneActivationConfiguration;

  collectionViewContextMenuConfigurationForItemAtIndexPathPoint?(collectionView: UICollectionView, indexPath: NSIndexPath, point: CGPoint): UIContextMenuConfiguration;

  collectionViewPreviewForHighlightingContextMenuWithConfiguration?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  collectionViewPreviewForDismissingContextMenuWithConfiguration?(collectionView: UICollectionView, configuration: UIContextMenuConfiguration): UITargetedPreview;
}

declare class UICollectionViewDelegate extends NativeObject implements UICollectionViewDelegate {
}

declare interface UISceneDelegate extends NSObjectProtocol {
  sceneWillConnectToSessionOptions?(scene: UIScene, session: UISceneSession, connectionOptions: UISceneConnectionOptions): void;

  sceneDidDisconnect?(scene: UIScene): void;

  sceneDidBecomeActive?(scene: UIScene): void;

  sceneWillResignActive?(scene: UIScene): void;

  sceneWillEnterForeground?(scene: UIScene): void;

  sceneDidEnterBackground?(scene: UIScene): void;

  sceneOpenURLContexts?(scene: UIScene, URLContexts: NSSet): void;

  stateRestorationActivityForScene?(scene: UIScene): NSUserActivity;

  sceneRestoreInteractionStateWithUserActivity?(scene: UIScene, stateRestorationActivity: NSUserActivity): void;

  sceneWillContinueUserActivityWithType?(scene: UIScene, userActivityType: string): void;

  sceneContinueUserActivity?(scene: UIScene, userActivity: NSUserActivity): void;

  sceneDidFailToContinueUserActivityWithTypeError?(scene: UIScene, userActivityType: string, error: NSError): void;

  sceneDidUpdateUserActivity?(scene: UIScene, userActivity: NSUserActivity): void;
}

declare class UISceneDelegate extends NativeObject implements UISceneDelegate {
}

declare interface UISearchDisplayDelegate extends NSObjectProtocol {
  searchDisplayControllerWillBeginSearch?(controller: UISearchDisplayController): void;

  searchDisplayControllerDidBeginSearch?(controller: UISearchDisplayController): void;

  searchDisplayControllerWillEndSearch?(controller: UISearchDisplayController): void;

  searchDisplayControllerDidEndSearch?(controller: UISearchDisplayController): void;

  searchDisplayControllerDidLoadSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;

  searchDisplayControllerWillUnloadSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;

  searchDisplayControllerWillShowSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;

  searchDisplayControllerDidShowSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;

  searchDisplayControllerWillHideSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;

  searchDisplayControllerDidHideSearchResultsTableView?(controller: UISearchDisplayController, tableView: UITableView): void;

  searchDisplayControllerShouldReloadTableForSearchString?(controller: UISearchDisplayController, searchString: string | null): boolean;

  searchDisplayControllerShouldReloadTableForSearchScope?(controller: UISearchDisplayController, searchOption: number): boolean;
}

declare class UISearchDisplayDelegate extends NativeObject implements UISearchDisplayDelegate {
}

declare interface UICollectionViewDataSource extends NSObjectProtocol {
  collectionViewNumberOfItemsInSection(collectionView: UICollectionView, section: number): number;

  collectionViewCellForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): UICollectionViewCell;

  numberOfSectionsInCollectionView?(collectionView: UICollectionView): number;

  collectionViewViewForSupplementaryElementOfKindAtIndexPath?(collectionView: UICollectionView, kind: string, indexPath: NSIndexPath): UICollectionReusableView;

  collectionViewCanMoveItemAtIndexPath?(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewMoveItemAtIndexPathToIndexPath?(collectionView: UICollectionView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;

  indexTitlesForCollectionView?(collectionView: UICollectionView): NSArray;

  collectionViewIndexPathForIndexTitleAtIndex?(collectionView: UICollectionView, title: string, index: number): NSIndexPath;
}

declare class UICollectionViewDataSource extends NativeObject implements UICollectionViewDataSource {
}

declare interface UIObjectRestoration {
}

declare class UIObjectRestoration extends NativeObject implements UIObjectRestoration {
  static objectWithRestorationIdentifierPathCoder(identifierComponents: NSArray<interop.Object> | Array<interop.Object>, coder: NSCoder): UIStateRestoring;
}

declare interface UIViewControllerRestoration {
}

declare class UIViewControllerRestoration extends NativeObject implements UIViewControllerRestoration {
  static viewControllerWithRestorationIdentifierPathCoder(identifierComponents: NSArray<interop.Object> | Array<interop.Object>, coder: NSCoder): UIViewController;
}

declare interface UISpringLoadedInteractionSupporting extends NSObjectProtocol {
  isSpringLoaded: boolean;
}

declare class UISpringLoadedInteractionSupporting extends NativeObject implements UISpringLoadedInteractionSupporting {
}

declare interface UIDataSourceModelAssociation {
  modelIdentifierForElementAtIndexPathInView(idx: NSIndexPath, view: UIView): string;

  indexPathForElementWithModelIdentifierInView(identifier: string, view: UIView): NSIndexPath;
}

declare class UIDataSourceModelAssociation extends NativeObject implements UIDataSourceModelAssociation {
}

declare interface UIContentView extends NSObjectProtocol {
  configuration: UIContentConfiguration;

  supportsConfiguration?(configuration: UIContentConfiguration): boolean;
}

declare class UIContentView extends NativeObject implements UIContentView {
}

declare interface UIAlertViewDelegate extends NSObjectProtocol {
  alertViewClickedButtonAtIndex?(alertView: UIAlertView, buttonIndex: number): void;

  alertViewCancel?(alertView: UIAlertView): void;

  willPresentAlertView?(alertView: UIAlertView): void;

  didPresentAlertView?(alertView: UIAlertView): void;

  alertViewWillDismissWithButtonIndex?(alertView: UIAlertView, buttonIndex: number): void;

  alertViewDidDismissWithButtonIndex?(alertView: UIAlertView, buttonIndex: number): void;

  alertViewShouldEnableFirstOtherButton?(alertView: UIAlertView): boolean;
}

declare class UIAlertViewDelegate extends NativeObject implements UIAlertViewDelegate {
}

declare interface UITableViewDataSourcePrefetching extends NSObjectProtocol {
  tableViewPrefetchRowsAtIndexPaths(tableView: UITableView, indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  tableViewCancelPrefetchingForRowsAtIndexPaths?(tableView: UITableView, indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;
}

declare class UITableViewDataSourcePrefetching extends NativeObject implements UITableViewDataSourcePrefetching {
}

declare interface UITextDropRequest extends NSObjectProtocol {
  readonly dropPosition: UITextPosition;

  readonly suggestedProposal: UITextDropProposal;

  readonly isSameView: boolean;

  readonly dropSession: UIDropSession;
}

declare class UITextDropRequest extends NativeObject implements UITextDropRequest {
}

declare interface UITextDropDelegate extends NSObjectProtocol {
  textDroppableViewWillBecomeEditableForDrop?(textDroppableView: UIView, drop: UITextDropRequest): interop.Enum<typeof UITextDropEditability>;

  textDroppableViewProposalForDrop?(textDroppableView: UIView, drop: UITextDropRequest): UITextDropProposal;

  textDroppableViewWillPerformDrop?(textDroppableView: UIView, drop: UITextDropRequest): void;

  textDroppableViewPreviewForDroppingAllItemsWithDefault?(textDroppableView: UIView, defaultPreview: UITargetedDragPreview): UITargetedDragPreview;

  textDroppableViewDropSessionDidEnter?(textDroppableView: UIView, session: UIDropSession): void;

  textDroppableViewDropSessionDidUpdate?(textDroppableView: UIView, session: UIDropSession): void;

  textDroppableViewDropSessionDidExit?(textDroppableView: UIView, session: UIDropSession): void;

  textDroppableViewDropSessionDidEnd?(textDroppableView: UIView, session: UIDropSession): void;
}

declare class UITextDropDelegate extends NativeObject implements UITextDropDelegate {
}

declare interface UIBarPositioningDelegate extends NSObjectProtocol {
  positionForBar?(bar: UIBarPositioning): interop.Enum<typeof UIBarPosition>;
}

declare class UIBarPositioningDelegate extends NativeObject implements UIBarPositioningDelegate {
}

declare interface UISplitViewControllerDelegate {
  splitViewControllerWillChangeToDisplayMode?(svc: UISplitViewController, displayMode: interop.Enum<typeof UISplitViewControllerDisplayMode>): void;

  targetDisplayModeForActionInSplitViewController?(svc: UISplitViewController): interop.Enum<typeof UISplitViewControllerDisplayMode>;

  splitViewControllerShowViewControllerSender?(splitViewController: UISplitViewController, vc: UIViewController, sender: interop.Object | null): boolean;

  splitViewControllerShowDetailViewControllerSender?(splitViewController: UISplitViewController, vc: UIViewController, sender: interop.Object | null): boolean;

  primaryViewControllerForCollapsingSplitViewController?(splitViewController: UISplitViewController): UIViewController;

  primaryViewControllerForExpandingSplitViewController?(splitViewController: UISplitViewController): UIViewController;

  splitViewControllerCollapseSecondaryViewControllerOntoPrimaryViewController?(splitViewController: UISplitViewController, secondaryViewController: UIViewController, primaryViewController: UIViewController): boolean;

  splitViewControllerSeparateSecondaryViewControllerFromPrimaryViewController?(splitViewController: UISplitViewController, primaryViewController: UIViewController): UIViewController;

  splitViewControllerSupportedInterfaceOrientations?(splitViewController: UISplitViewController): interop.Enum<typeof UIInterfaceOrientationMask>;

  splitViewControllerPreferredInterfaceOrientationForPresentation?(splitViewController: UISplitViewController): interop.Enum<typeof UIInterfaceOrientation>;

  splitViewControllerWillHideViewControllerWithBarButtonItemForPopoverController?(svc: UISplitViewController, aViewController: UIViewController, barButtonItem: UIBarButtonItem, pc: UIPopoverController): void;

  splitViewControllerWillShowViewControllerInvalidatingBarButtonItem?(svc: UISplitViewController, aViewController: UIViewController, barButtonItem: UIBarButtonItem): void;

  splitViewControllerPopoverControllerWillPresentViewController?(svc: UISplitViewController, pc: UIPopoverController, aViewController: UIViewController): void;

  splitViewControllerShouldHideViewControllerInOrientation?(svc: UISplitViewController, vc: UIViewController, orientation: interop.Enum<typeof UIInterfaceOrientation>): boolean;

  splitViewControllerTopColumnForCollapsingToProposedTopColumn?(svc: UISplitViewController, proposedTopColumn: interop.Enum<typeof UISplitViewControllerColumn>): interop.Enum<typeof UISplitViewControllerColumn>;

  splitViewControllerDisplayModeForExpandingToProposedDisplayMode?(svc: UISplitViewController, proposedDisplayMode: interop.Enum<typeof UISplitViewControllerDisplayMode>): interop.Enum<typeof UISplitViewControllerDisplayMode>;

  splitViewControllerDidCollapse?(svc: UISplitViewController): void;

  splitViewControllerDidExpand?(svc: UISplitViewController): void;

  splitViewControllerWillShowColumn?(svc: UISplitViewController, column: interop.Enum<typeof UISplitViewControllerColumn>): void;

  splitViewControllerWillHideColumn?(svc: UISplitViewController, column: interop.Enum<typeof UISplitViewControllerColumn>): void;

  splitViewControllerInteractivePresentationGestureWillBegin?(svc: UISplitViewController): void;

  splitViewControllerInteractivePresentationGestureDidEnd?(svc: UISplitViewController): void;
}

declare class UISplitViewControllerDelegate extends NativeObject implements UISplitViewControllerDelegate {
}

declare interface NSTextContentManagerDelegate extends NSObjectProtocol {
  textContentManagerTextElementAtLocation?(textContentManager: NSTextContentManager, location: NSTextLocation): NSTextElement;

  textContentManagerShouldEnumerateTextElementOptions?(textContentManager: NSTextContentManager, textElement: NSTextElement, options: interop.Enum<typeof NSTextContentManagerEnumerationOptions>): boolean;
}

declare class NSTextContentManagerDelegate extends NativeObject implements NSTextContentManagerDelegate {
}

declare interface UITextDragDelegate extends NSObjectProtocol {
  textDraggableViewItemsForDrag?(textDraggableView: UIView, dragRequest: UITextDragRequest): NSArray;

  textDraggableViewDragPreviewForLiftingItemSession?(textDraggableView: UIView, item: UIDragItem, session: UIDragSession): UITargetedDragPreview;

  textDraggableViewWillAnimateLiftWithAnimatorSession?(textDraggableView: UIView, animator: UIDragAnimating, session: UIDragSession): void;

  textDraggableViewDragSessionWillBegin?(textDraggableView: UIView, session: UIDragSession): void;

  textDraggableViewDragSessionDidEndWithOperation?(textDraggableView: UIView, session: UIDragSession, operation: interop.Enum<typeof UIDropOperation>): void;
}

declare class UITextDragDelegate extends NativeObject implements UITextDragDelegate {
}

declare interface NSCollectionLayoutContainer extends NSObjectProtocol {
  readonly contentSize: CGSize;

  readonly effectiveContentSize: CGSize;

  readonly contentInsets: NSDirectionalEdgeInsets;

  readonly effectiveContentInsets: NSDirectionalEdgeInsets;
}

declare class NSCollectionLayoutContainer extends NativeObject implements NSCollectionLayoutContainer {
}

declare interface UIDragAnimating extends NSObjectProtocol {
  addAnimations(animations: () => void): void;

  addCompletion(completion: (p1: interop.Enum<typeof UIViewAnimatingPosition>) => void): void;
}

declare class UIDragAnimating extends NativeObject implements UIDragAnimating {
}

declare interface UIViewImplicitlyAnimating extends UIViewAnimating {
  addAnimationsDelayFactor?(animation: () => void, delayFactor: number): void;

  addAnimations?(animation: () => void): void;

  addCompletion?(completion: (p1: interop.Enum<typeof UIViewAnimatingPosition>) => void): void;

  continueAnimationWithTimingParametersDurationFactor?(parameters: UITimingCurveProvider | null, durationFactor: number): void;
}

declare class UIViewImplicitlyAnimating extends NativeObject implements UIViewImplicitlyAnimating {
}

declare interface UIDropInteractionDelegate extends NSObjectProtocol {
  dropInteractionCanHandleSession?(interaction: UIDropInteraction, session: UIDropSession): boolean;

  dropInteractionSessionDidEnter?(interaction: UIDropInteraction, session: UIDropSession): void;

  dropInteractionSessionDidUpdate?(interaction: UIDropInteraction, session: UIDropSession): UIDropProposal;

  dropInteractionSessionDidExit?(interaction: UIDropInteraction, session: UIDropSession): void;

  dropInteractionPerformDrop?(interaction: UIDropInteraction, session: UIDropSession): void;

  dropInteractionConcludeDrop?(interaction: UIDropInteraction, session: UIDropSession): void;

  dropInteractionSessionDidEnd?(interaction: UIDropInteraction, session: UIDropSession): void;

  dropInteractionPreviewForDroppingItemWithDefault?(interaction: UIDropInteraction, item: UIDragItem, defaultPreview: UITargetedDragPreview): UITargetedDragPreview;

  dropInteractionItemWillAnimateDropWithAnimator?(interaction: UIDropInteraction, item: UIDragItem, animator: UIDragAnimating): void;
}

declare class UIDropInteractionDelegate extends NativeObject implements UIDropInteractionDelegate {
}

declare interface UIContentSizeCategoryAdjusting extends NSObjectProtocol {
  adjustsFontForContentSizeCategory: boolean;
}

declare class UIContentSizeCategoryAdjusting extends NativeObject implements UIContentSizeCategoryAdjusting {
}

declare interface UITextInputTraits extends NSObjectProtocol {
  autocapitalizationType?: interop.Enum<typeof UITextAutocapitalizationType>;

  autocorrectionType?: interop.Enum<typeof UITextAutocorrectionType>;

  spellCheckingType?: interop.Enum<typeof UITextSpellCheckingType>;

  smartQuotesType?: interop.Enum<typeof UITextSmartQuotesType>;

  smartDashesType?: interop.Enum<typeof UITextSmartDashesType>;

  smartInsertDeleteType?: interop.Enum<typeof UITextSmartInsertDeleteType>;

  inlinePredictionType?: interop.Enum<typeof UITextInlinePredictionType>;

  keyboardType?: interop.Enum<typeof UIKeyboardType>;

  keyboardAppearance?: interop.Enum<typeof UIKeyboardAppearance>;

  returnKeyType?: interop.Enum<typeof UIReturnKeyType>;

  enablesReturnKeyAutomatically?: boolean;

  isSecureTextEntry?: boolean;

  textContentType?: string;

  passwordRules?: UITextInputPasswordRules;
}

declare class UITextInputTraits extends NativeObject implements UITextInputTraits {
}

declare interface UIAccessibilityContainerDataTable extends NSObjectProtocol {
  accessibilityDataTableCellElementForRowColumn(row: number, column: number): UIAccessibilityContainerDataTableCell;

  accessibilityRowCount(): number;

  accessibilityColumnCount(): number;

  accessibilityHeaderElementsForRow?(row: number): NSArray;

  accessibilityHeaderElementsForColumn?(column: number): NSArray;
}

declare class UIAccessibilityContainerDataTable extends NativeObject implements UIAccessibilityContainerDataTable {
}

declare interface UINavigationItemRenameDelegate extends NSObjectProtocol {
  navigationItemDidEndRenamingWithTitle(navigationItem: UINavigationItem, title: string): void;

  navigationItemShouldBeginRenaming?(navigationItem: UINavigationItem): boolean;

  navigationItemWillBeginRenamingWithSuggestedTitleSelectedRange?(navigationItem: UINavigationItem, title: string, selectedRange: interop.PointerConvertible): string;

  navigationItemShouldEndRenamingWithTitle?(navigationItem: UINavigationItem, title: string): boolean;
}

declare class UINavigationItemRenameDelegate extends NativeObject implements UINavigationItemRenameDelegate {
}

declare interface UIAccessibilityContainerDataTableCell extends NSObjectProtocol {
  accessibilityRowRange(): _NSRange;

  accessibilityColumnRange(): _NSRange;
}

declare class UIAccessibilityContainerDataTableCell extends NativeObject implements UIAccessibilityContainerDataTableCell {
}

declare interface UIPickerViewAccessibilityDelegate extends UIPickerViewDelegate {
  pickerViewAccessibilityLabelForComponent?(pickerView: UIPickerView, component: number): string;

  pickerViewAccessibilityHintForComponent?(pickerView: UIPickerView, component: number): string;

  pickerViewAccessibilityUserInputLabelsForComponent?(pickerView: UIPickerView, component: number): NSArray;

  pickerViewAccessibilityAttributedLabelForComponent?(pickerView: UIPickerView, component: number): NSAttributedString;

  pickerViewAccessibilityAttributedHintForComponent?(pickerView: UIPickerView, component: number): NSAttributedString;

  pickerViewAccessibilityAttributedUserInputLabelsForComponent?(pickerView: UIPickerView, component: number): NSArray;
}

declare class UIPickerViewAccessibilityDelegate extends NativeObject implements UIPickerViewAccessibilityDelegate {
}

declare interface UITabBarDelegate extends NSObjectProtocol {
  tabBarDidSelectItem?(tabBar: UITabBar, item: UITabBarItem): void;

  tabBarWillBeginCustomizingItems?(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>): void;

  tabBarDidBeginCustomizingItems?(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>): void;

  tabBarWillEndCustomizingItemsChanged?(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>, changed: boolean): void;

  tabBarDidEndCustomizingItemsChanged?(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>, changed: boolean): void;
}

declare class UITabBarDelegate extends NativeObject implements UITabBarDelegate {
}

declare interface UICGFloatTraitDefinition extends UITraitDefinition {
}

declare class UICGFloatTraitDefinition extends NativeObject implements UICGFloatTraitDefinition {
  static readonly defaultValue: number;
}

declare interface UIDocumentInteractionControllerDelegate extends NSObjectProtocol {
  documentInteractionControllerViewControllerForPreview?(controller: UIDocumentInteractionController): UIViewController;

  documentInteractionControllerRectForPreview?(controller: UIDocumentInteractionController): CGRect;

  documentInteractionControllerViewForPreview?(controller: UIDocumentInteractionController): UIView;

  documentInteractionControllerWillBeginPreview?(controller: UIDocumentInteractionController): void;

  documentInteractionControllerDidEndPreview?(controller: UIDocumentInteractionController): void;

  documentInteractionControllerWillPresentOptionsMenu?(controller: UIDocumentInteractionController): void;

  documentInteractionControllerDidDismissOptionsMenu?(controller: UIDocumentInteractionController): void;

  documentInteractionControllerWillPresentOpenInMenu?(controller: UIDocumentInteractionController): void;

  documentInteractionControllerDidDismissOpenInMenu?(controller: UIDocumentInteractionController): void;

  documentInteractionControllerWillBeginSendingToApplication?(controller: UIDocumentInteractionController, application: string | null): void;

  documentInteractionControllerDidEndSendingToApplication?(controller: UIDocumentInteractionController, application: string | null): void;

  documentInteractionControllerCanPerformAction?(controller: UIDocumentInteractionController, action: string | null): boolean;

  documentInteractionControllerPerformAction?(controller: UIDocumentInteractionController, action: string | null): boolean;
}

declare class UIDocumentInteractionControllerDelegate extends NativeObject implements UIDocumentInteractionControllerDelegate {
}

declare interface UIContextMenuInteractionCommitAnimating extends UIContextMenuInteractionAnimating {
  preferredCommitStyle: interop.Enum<typeof UIContextMenuInteractionCommitStyle>;
}

declare class UIContextMenuInteractionCommitAnimating extends NativeObject implements UIContextMenuInteractionCommitAnimating {
}

declare interface UIViewControllerPreviewing extends NSObjectProtocol {
  readonly previewingGestureRecognizerForFailureRelationship: UIGestureRecognizer;

  readonly delegate: UIViewControllerPreviewingDelegate;

  readonly sourceView: UIView;

  sourceRect: CGRect;
}

declare class UIViewControllerPreviewing extends NativeObject implements UIViewControllerPreviewing {
}

declare interface UICloudSharingControllerDelegate extends NSObjectProtocol {
  cloudSharingControllerFailedToSaveShareWithError(csc: UICloudSharingController, error: NSError): void;

  itemTitleForCloudSharingController(csc: UICloudSharingController): string;

  itemThumbnailDataForCloudSharingController?(csc: UICloudSharingController): NSData;

  itemTypeForCloudSharingController?(csc: UICloudSharingController): string;

  cloudSharingControllerDidSaveShare?(csc: UICloudSharingController): void;

  cloudSharingControllerDidStopSharing?(csc: UICloudSharingController): void;
}

declare class UICloudSharingControllerDelegate extends NativeObject implements UICloudSharingControllerDelegate {
}

declare interface UINSIntegerTraitDefinition extends UITraitDefinition {
}

declare class UINSIntegerTraitDefinition extends NativeObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;
}

declare interface NSCollectionLayoutEnvironment extends NSObjectProtocol {
  readonly container: NSCollectionLayoutContainer;

  readonly traitCollection: UITraitCollection;
}

declare class NSCollectionLayoutEnvironment extends NativeObject implements NSCollectionLayoutEnvironment {
}

declare interface UITextInputDelegate extends NSObjectProtocol {
  selectionWillChange(textInput: UITextInput | null): void;

  selectionDidChange(textInput: UITextInput | null): void;

  textWillChange(textInput: UITextInput | null): void;

  textDidChange(textInput: UITextInput | null): void;
}

declare class UITextInputDelegate extends NativeObject implements UITextInputDelegate {
}

declare interface UITextDragRequest extends NSObjectProtocol {
  readonly dragRange: UITextRange;

  readonly suggestedItems: NSArray;

  readonly existingItems: NSArray;

  readonly isSelected: boolean;

  readonly dragSession: UIDragSession;
}

declare class UITextDragRequest extends NativeObject implements UITextDragRequest {
}

declare interface UILayoutSupport extends NSObjectProtocol {
  readonly length: number;

  readonly topAnchor: NSLayoutYAxisAnchor;

  readonly bottomAnchor: NSLayoutYAxisAnchor;

  readonly heightAnchor: NSLayoutDimension;
}

declare class UILayoutSupport extends NativeObject implements UILayoutSupport {
}

declare interface UIViewControllerAnimatedTransitioning extends NSObjectProtocol {
  transitionDuration(transitionContext: UIViewControllerContextTransitioning | null): number;

  animateTransition(transitionContext: UIViewControllerContextTransitioning): void;

  interruptibleAnimatorForTransition?(transitionContext: UIViewControllerContextTransitioning): UIViewImplicitlyAnimating;

  animationEnded?(transitionCompleted: boolean): void;
}

declare class UIViewControllerAnimatedTransitioning extends NativeObject implements UIViewControllerAnimatedTransitioning {
}

declare interface UIViewControllerTransitionCoordinator extends UIViewControllerTransitionCoordinatorContext {
  animateAlongsideTransitionCompletion(animation: (p1: UIViewControllerTransitionCoordinatorContext) => void | null, completion: (p1: UIViewControllerTransitionCoordinatorContext) => void | null): boolean;

  animateAlongsideTransitionInViewAnimationCompletion(view: UIView | null, animation: (p1: UIViewControllerTransitionCoordinatorContext) => void | null, completion: (p1: UIViewControllerTransitionCoordinatorContext) => void | null): boolean;

  notifyWhenInteractionEndsUsingBlock(handler: (p1: UIViewControllerTransitionCoordinatorContext) => void): void;

  notifyWhenInteractionChangesUsingBlock(handler: (p1: UIViewControllerTransitionCoordinatorContext) => void): void;
}

declare class UIViewControllerTransitionCoordinator extends NativeObject implements UIViewControllerTransitionCoordinator {
}

declare interface UIFocusItem extends UIFocusEnvironment {
  readonly canBecomeFocused: boolean;

  readonly frame: CGRect;

  readonly focusEffect?: UIFocusEffect;

  readonly focusGroupPriority?: number;

  readonly isTransparentFocusItem?: boolean;

  didHintFocusMovement?(hint: UIFocusMovementHint): void;
}

declare class UIFocusItem extends NativeObject implements UIFocusItem {
}

declare interface UIDocumentPickerDelegate extends NSObjectProtocol {
  documentPickerDidPickDocumentsAtURLs?(controller: UIDocumentPickerViewController, urls: NSArray<interop.Object> | Array<interop.Object>): void;

  documentPickerWasCancelled?(controller: UIDocumentPickerViewController): void;

  documentPickerDidPickDocumentAtURL?(controller: UIDocumentPickerViewController, url: NSURL): void;
}

declare class UIDocumentPickerDelegate extends NativeObject implements UIDocumentPickerDelegate {
}

declare interface UIItemProviderPresentationSizeProviding extends NSObjectProtocol {
  readonly preferredPresentationSizeForItemProvider: CGSize;
}

declare class UIItemProviderPresentationSizeProviding extends NativeObject implements UIItemProviderPresentationSizeProviding {
}

declare interface UIFocusEnvironment extends NSObjectProtocol {
  readonly preferredFocusEnvironments: NSArray;

  readonly parentFocusEnvironment: UIFocusEnvironment;

  readonly focusItemContainer: UIFocusItemContainer;

  setNeedsFocusUpdate(): void;

  updateFocusIfNeeded(): void;

  shouldUpdateFocusInContext(context: UIFocusUpdateContext): boolean;

  didUpdateFocusInContextWithAnimationCoordinator(context: UIFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  readonly preferredFocusedView?: UIView;

  readonly focusGroupIdentifier?: string;
}

declare class UIFocusEnvironment extends NativeObject implements UIFocusEnvironment {
}

declare interface UIScrollViewAccessibilityDelegate extends UIScrollViewDelegate {
  accessibilityScrollStatusForScrollView?(scrollView: UIScrollView): string;

  accessibilityAttributedScrollStatusForScrollView?(scrollView: UIScrollView): NSAttributedString;
}

declare class UIScrollViewAccessibilityDelegate extends NativeObject implements UIScrollViewAccessibilityDelegate {
}

declare interface UICollectionViewDropCoordinator extends NSObjectProtocol {
  readonly items: NSArray;

  readonly destinationIndexPath: NSIndexPath;

  readonly proposal: UICollectionViewDropProposal;

  readonly session: UIDropSession;

  dropItemToPlaceholder(dragItem: UIDragItem, placeholder: UICollectionViewDropPlaceholder): UICollectionViewDropPlaceholderContext;

  dropItemToItemAtIndexPath(dragItem: UIDragItem, indexPath: NSIndexPath): UIDragAnimating;

  dropItemIntoItemAtIndexPathRect(dragItem: UIDragItem, indexPath: NSIndexPath, rect: CGRect): UIDragAnimating;

  dropItemToTarget(dragItem: UIDragItem, target: UIDragPreviewTarget): UIDragAnimating;
}

declare class UICollectionViewDropCoordinator extends NativeObject implements UICollectionViewDropCoordinator {
}

declare interface UIGestureRecognizerDelegate extends NSObjectProtocol {
  gestureRecognizerShouldBegin?(gestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer?(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldRequireFailureOfGestureRecognizer?(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldBeRequiredToFailByGestureRecognizer?(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldReceiveTouch?(gestureRecognizer: UIGestureRecognizer, touch: UITouch): boolean;

  gestureRecognizerShouldReceivePress?(gestureRecognizer: UIGestureRecognizer, press: UIPress): boolean;

  gestureRecognizerShouldReceiveEvent?(gestureRecognizer: UIGestureRecognizer, event: UIEvent): boolean;
}

declare class UIGestureRecognizerDelegate extends NativeObject implements UIGestureRecognizerDelegate {
}

declare interface UITraitDefinition {
}

declare class UITraitDefinition extends NativeObject implements UITraitDefinition {
  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare interface UIResponderStandardEditActions extends NSObjectProtocol {
  cut?(sender: interop.Object | null): void;

  copy?(sender: interop.Object | null): void;

  paste?(sender: interop.Object | null): void;

  pasteAndMatchStyle?(sender: interop.Object | null): void;

  pasteAndGo?(sender: interop.Object | null): void;

  pasteAndSearch?(sender: interop.Object | null): void;

  select?(sender: interop.Object | null): void;

  selectAll?(sender: interop.Object | null): void;

  delete?(sender: interop.Object | null): void;

  makeTextWritingDirectionLeftToRight?(sender: interop.Object | null): void;

  makeTextWritingDirectionRightToLeft?(sender: interop.Object | null): void;

  toggleBoldface?(sender: interop.Object | null): void;

  toggleItalics?(sender: interop.Object | null): void;

  toggleUnderline?(sender: interop.Object | null): void;

  increaseSize?(sender: interop.Object | null): void;

  decreaseSize?(sender: interop.Object | null): void;

  find?(sender: interop.Object | null): void;

  findAndReplace?(sender: interop.Object | null): void;

  findNext?(sender: interop.Object | null): void;

  findPrevious?(sender: interop.Object | null): void;

  useSelectionForFind?(sender: interop.Object | null): void;

  updateTextAttributesWithConversionHandler?(conversionHandler: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => NSDictionary): void;

  print?(sender: interop.Object | null): void;

  rename?(sender: interop.Object | null): void;

  duplicate?(sender: interop.Object | null): void;

  move?(sender: interop.Object | null): void;

  export?(sender: interop.Object | null): void;
}

declare class UIResponderStandardEditActions extends NativeObject implements UIResponderStandardEditActions {
}

declare interface UICoordinateSpace extends NSObjectProtocol {
  convertPointToCoordinateSpace(point: CGPoint, coordinateSpace: UICoordinateSpace): CGPoint;

  convertPointFromCoordinateSpace(point: CGPoint, coordinateSpace: UICoordinateSpace): CGPoint;

  convertRectToCoordinateSpace(rect: CGRect, coordinateSpace: UICoordinateSpace): CGRect;

  convertRectFromCoordinateSpace(rect: CGRect, coordinateSpace: UICoordinateSpace): CGRect;

  readonly bounds: CGRect;
}

declare class UICoordinateSpace extends NativeObject implements UICoordinateSpace {
}

declare interface UISearchTextFieldDelegate extends UITextFieldDelegate {
  searchTextFieldItemProviderForCopyingToken?(searchTextField: UISearchTextField, token: UISearchToken): NSItemProvider;

  searchTextFieldDidSelectSuggestion?(searchTextField: UISearchTextField, suggestion: UISearchSuggestion): void;
}

declare class UISearchTextFieldDelegate extends NativeObject implements UISearchTextFieldDelegate {
}

declare interface UIDocumentBrowserViewControllerDelegate extends NSObjectProtocol {
  documentBrowserDidPickDocumentURLs?(controller: UIDocumentBrowserViewController, documentURLs: NSArray<interop.Object> | Array<interop.Object>): void;

  documentBrowserDidPickDocumentsAtURLs?(controller: UIDocumentBrowserViewController, documentURLs: NSArray<interop.Object> | Array<interop.Object>): void;

  documentBrowserDidRequestDocumentCreationWithHandler?(controller: UIDocumentBrowserViewController, importHandler: (p1: NSURL, p2: interop.Enum<typeof UIDocumentBrowserImportMode>) => void | null): void;

  documentBrowserDidImportDocumentAtURLToDestinationURL?(controller: UIDocumentBrowserViewController, sourceURL: NSURL, destinationURL: NSURL): void;

  documentBrowserFailedToImportDocumentAtURLError?(controller: UIDocumentBrowserViewController, documentURL: NSURL, error: NSError | null): void;

  documentBrowserApplicationActivitiesForDocumentURLs?(controller: UIDocumentBrowserViewController, documentURLs: NSArray<interop.Object> | Array<interop.Object>): NSArray;

  documentBrowserWillPresentActivityViewController?(controller: UIDocumentBrowserViewController, activityViewController: UIActivityViewController): void;
}

declare class UIDocumentBrowserViewControllerDelegate extends NativeObject implements UIDocumentBrowserViewControllerDelegate {
}

declare interface NSTextLayoutOrientationProvider {
  readonly layoutOrientation: interop.Enum<typeof NSTextLayoutOrientation>;
}

declare class NSTextLayoutOrientationProvider extends NativeObject implements NSTextLayoutOrientationProvider {
}

declare interface NSTextStorageDelegate extends NSObjectProtocol {
  textStorageWillProcessEditingRangeChangeInLength?(textStorage: NSTextStorage, editedMask: interop.Enum<typeof NSTextStorageEditActions>, editedRange: _NSRange, delta: number): void;

  textStorageDidProcessEditingRangeChangeInLength?(textStorage: NSTextStorage, editedMask: interop.Enum<typeof NSTextStorageEditActions>, editedRange: _NSRange, delta: number): void;
}

declare class NSTextStorageDelegate extends NativeObject implements NSTextStorageDelegate {
}

declare interface UIMenuLeaf extends NSObjectProtocol {
  title: string;

  image: UIImage;

  selectedImage: UIImage;

  discoverabilityTitle: string;

  attributes: interop.Enum<typeof UIMenuElementAttributes>;

  state: interop.Enum<typeof UIMenuElementState>;

  readonly sender: interop.Object;

  readonly presentationSourceItem: UIPopoverPresentationControllerSourceItem;

  performWithSenderTarget(sender: interop.Object | null, target: interop.Object | null): void;
}

declare class UIMenuLeaf extends NativeObject implements UIMenuLeaf {
}

declare interface UILetterformAwareAdjusting extends NSObjectProtocol {
  sizingRule: interop.Enum<typeof UILetterformAwareSizingRule>;
}

declare class UILetterformAwareAdjusting extends NativeObject implements UILetterformAwareAdjusting {
}

declare interface UITraitEnvironment extends NSObjectProtocol {
  readonly traitCollection: UITraitCollection;

  traitCollectionDidChange(previousTraitCollection: UITraitCollection | null): void;
}

declare class UITraitEnvironment extends NativeObject implements UITraitEnvironment {
}

declare interface UIFindInteractionDelegate extends NSObjectProtocol {
  findInteractionSessionForView(interaction: UIFindInteraction, view: UIView): UIFindSession;

  findInteractionDidBeginFindSession?(interaction: UIFindInteraction, session: UIFindSession): void;

  findInteractionDidEndFindSession?(interaction: UIFindInteraction, session: UIFindSession): void;
}

declare class UIFindInteractionDelegate extends NativeObject implements UIFindInteractionDelegate {
}

declare interface UIAccelerometerDelegate extends NSObjectProtocol {
  accelerometerDidAccelerate?(accelerometer: UIAccelerometer, acceleration: UIAcceleration): void;
}

declare class UIAccelerometerDelegate extends NativeObject implements UIAccelerometerDelegate {
}

declare interface UITextInput extends UIKeyInput {
  textInRange(range: UITextRange): string;

  replaceRangeWithText(range: UITextRange, text: string): void;

  selectedTextRange: UITextRange;

  readonly markedTextRange: UITextRange;

  get markedTextStyle(): NSDictionary;
  set markedTextStyle(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  setMarkedTextSelectedRange(markedText: string | null, selectedRange: _NSRange): void;

  unmarkText(): void;

  readonly beginningOfDocument: UITextPosition;

  readonly endOfDocument: UITextPosition;

  textRangeFromPositionToPosition(fromPosition: UITextPosition, toPosition: UITextPosition): UITextRange;

  positionFromPositionOffset(position: UITextPosition, offset: number): UITextPosition;

  positionFromPositionInDirectionOffset(position: UITextPosition, direction: interop.Enum<typeof UITextLayoutDirection>, offset: number): UITextPosition;

  comparePositionToPosition(position: UITextPosition, other: UITextPosition): interop.Enum<typeof NSComparisonResult>;

  offsetFromPositionToPosition(from: UITextPosition, toPosition: UITextPosition): number;

  inputDelegate: UITextInputDelegate;

  readonly tokenizer: UITextInputTokenizer;

  positionWithinRangeFarthestInDirection(range: UITextRange, direction: interop.Enum<typeof UITextLayoutDirection>): UITextPosition;

  characterRangeByExtendingPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextLayoutDirection>): UITextRange;

  baseWritingDirectionForPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextStorageDirection>): interop.Enum<typeof NSWritingDirection>;

  setBaseWritingDirectionForRange(writingDirection: interop.Enum<typeof NSWritingDirection>, range: UITextRange): void;

  firstRectForRange(range: UITextRange): CGRect;

  caretRectForPosition(position: UITextPosition): CGRect;

  selectionRectsForRange(range: UITextRange): NSArray;

  closestPositionToPoint(point: CGPoint): UITextPosition;

  closestPositionToPointWithinRange(point: CGPoint, range: UITextRange): UITextPosition;

  characterRangeAtPoint(point: CGPoint): UITextRange;

  shouldChangeTextInRangeReplacementText?(range: UITextRange, text: string): boolean;

  textStylingAtPositionInDirection?(position: UITextPosition, direction: interop.Enum<typeof UITextStorageDirection>): NSDictionary;

  positionWithinRangeAtCharacterOffset?(range: UITextRange, offset: number): UITextPosition;

  characterOffsetOfPositionWithinRange?(position: UITextPosition, range: UITextRange): number;

  readonly textInputView?: UIView;

  selectionAffinity?: interop.Enum<typeof UITextStorageDirection>;

  insertDictationResult?(dictationResult: NSArray<interop.Object> | Array<interop.Object>): void;

  dictationRecordingDidEnd?(): void;

  dictationRecognitionFailed?(): void;

  readonly insertDictationResultPlaceholder?: interop.Object;

  frameForDictationResultPlaceholder?(placeholder: interop.Object): CGRect;

  removeDictationResultPlaceholderWillInsertResult?(placeholder: interop.Object, willInsertResult: boolean): void;

  insertTextAlternativesStyle?(text: string, alternatives: NSArray<interop.Object> | Array<interop.Object>, style: interop.Enum<typeof UITextAlternativeStyle>): void;

  setAttributedMarkedTextSelectedRange?(markedText: NSAttributedString | null, selectedRange: _NSRange): void;

  insertTextPlaceholderWithSize?(size: CGSize): UITextPlaceholder;

  removeTextPlaceholder?(textPlaceholder: UITextPlaceholder): void;

  beginFloatingCursorAtPoint?(point: CGPoint): void;

  updateFloatingCursorAtPoint?(point: CGPoint): void;

  endFloatingCursor?(): void;

  caretTransformForPosition?(position: UITextPosition): CGAffineTransform;

  editMenuForTextRangeSuggestedActions?(textRange: UITextRange, suggestedActions: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  willPresentEditMenuWithAnimator?(animator: UIEditMenuInteractionAnimating): void;

  willDismissEditMenuWithAnimator?(animator: UIEditMenuInteractionAnimating): void;
}

declare class UITextInput extends NativeObject implements UITextInput {
}

declare interface UIItemProviderReadingAugmentationDesignating extends NSItemProviderReading {
}

declare class UIItemProviderReadingAugmentationDesignating extends NativeObject implements UIItemProviderReadingAugmentationDesignating {
  static _ui_augmentingNSItemProviderReadingClass(): UIItemProviderReadingAugmentationProviding;
}

declare interface UIDragInteractionDelegate extends NSObjectProtocol {
  dragInteractionItemsForBeginningSession(interaction: UIDragInteraction, session: UIDragSession): NSArray;

  dragInteractionPreviewForLiftingItemSession?(interaction: UIDragInteraction, item: UIDragItem, session: UIDragSession): UITargetedDragPreview;

  dragInteractionWillAnimateLiftWithAnimatorSession?(interaction: UIDragInteraction, animator: UIDragAnimating, session: UIDragSession): void;

  dragInteractionSessionWillBegin?(interaction: UIDragInteraction, session: UIDragSession): void;

  dragInteractionSessionAllowsMoveOperation?(interaction: UIDragInteraction, session: UIDragSession): boolean;

  dragInteractionSessionIsRestrictedToDraggingApplication?(interaction: UIDragInteraction, session: UIDragSession): boolean;

  dragInteractionPrefersFullSizePreviewsForSession?(interaction: UIDragInteraction, session: UIDragSession): boolean;

  dragInteractionSessionDidMove?(interaction: UIDragInteraction, session: UIDragSession): void;

  dragInteractionSessionWillEndWithOperation?(interaction: UIDragInteraction, session: UIDragSession, operation: interop.Enum<typeof UIDropOperation>): void;

  dragInteractionSessionDidEndWithOperation?(interaction: UIDragInteraction, session: UIDragSession, operation: interop.Enum<typeof UIDropOperation>): void;

  dragInteractionSessionDidTransferItems?(interaction: UIDragInteraction, session: UIDragSession): void;

  dragInteractionItemsForAddingToSessionWithTouchAtPoint?(interaction: UIDragInteraction, session: UIDragSession, point: CGPoint): NSArray;

  dragInteractionSessionForAddingItemsWithTouchAtPoint?(interaction: UIDragInteraction, sessions: NSArray<interop.Object> | Array<interop.Object>, point: CGPoint): UIDragSession;

  dragInteractionSessionWillAddItemsForInteraction?(interaction: UIDragInteraction, session: UIDragSession, items: NSArray<interop.Object> | Array<interop.Object>, addingInteraction: UIDragInteraction): void;

  dragInteractionPreviewForCancellingItemWithDefault?(interaction: UIDragInteraction, item: UIDragItem, defaultPreview: UITargetedDragPreview): UITargetedDragPreview;

  dragInteractionItemWillAnimateCancelWithAnimator?(interaction: UIDragInteraction, item: UIDragItem, animator: UIDragAnimating): void;
}

declare class UIDragInteractionDelegate extends NativeObject implements UIDragInteractionDelegate {
}

declare interface UIItemProviderReadingAugmentationProviding {
}

declare class UIItemProviderReadingAugmentationProviding extends NativeObject implements UIItemProviderReadingAugmentationProviding {
  static objectWithItemProviderDataTypeIdentifierRequestedClassError(data: NSData, typeIdentifier: string, requestedClass: interop.Object, outError: interop.PointerConvertible): interop.Object;

  static readonly additionalLeadingReadableTypeIdentifiersForItemProvider: NSArray;

  static readonly additionalTrailingReadableTypeIdentifiersForItemProvider: NSArray;
}

declare interface NSTextLayoutManagerDelegate extends NSObjectProtocol {
  textLayoutManagerTextLayoutFragmentForLocationInTextElement?(textLayoutManager: NSTextLayoutManager, location: NSTextLocation, textElement: NSTextElement): NSTextLayoutFragment;

  textLayoutManagerShouldBreakLineBeforeLocationHyphenating?(textLayoutManager: NSTextLayoutManager, location: NSTextLocation, hyphenating: boolean): boolean;

  textLayoutManagerRenderingAttributesForLinkAtLocationDefaultAttributes?(textLayoutManager: NSTextLayoutManager, link: interop.Object, location: NSTextLocation, renderingAttributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSDictionary;
}

declare class NSTextLayoutManagerDelegate extends NativeObject implements NSTextLayoutManagerDelegate {
}

declare interface UISearchResultsUpdating extends NSObjectProtocol {
  updateSearchResultsForSearchController(searchController: UISearchController): void;

  updateSearchResultsForSearchControllerSelectingSearchSuggestion?(searchController: UISearchController, searchSuggestion: UISearchSuggestion): void;
}

declare class UISearchResultsUpdating extends NativeObject implements UISearchResultsUpdating {
}

declare interface NSTextAttachmentLayout extends NSObjectProtocol {
  imageForBoundsAttributesLocationTextContainer(bounds: CGRect, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, location: NSTextLocation, textContainer: NSTextContainer | null): UIImage;

  attachmentBoundsForAttributesLocationTextContainerProposedLineFragmentPosition(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, location: NSTextLocation, textContainer: NSTextContainer | null, proposedLineFragment: CGRect, position: CGPoint): CGRect;

  viewProviderForParentViewLocationTextContainer(parentView: UIView | null, location: NSTextLocation, textContainer: NSTextContainer | null): NSTextAttachmentViewProvider;
}

declare class NSTextAttachmentLayout extends NativeObject implements NSTextAttachmentLayout {
}

declare interface UIPopoverBackgroundViewMethods {
}

declare class UIPopoverBackgroundViewMethods extends NativeObject implements UIPopoverBackgroundViewMethods {
  static arrowBase(): number;

  static contentViewInsets(): UIEdgeInsets;

  static arrowHeight(): number;
}

declare interface UITraitOverrides extends UIMutableTraits {
  containsTrait(trait: UITraitDefinition): boolean;

  removeTrait(trait: UITraitDefinition): void;
}

declare class UITraitOverrides extends NativeObject implements UITraitOverrides {
}

declare interface UIBarPositioning extends NSObjectProtocol {
  readonly barPosition: interop.Enum<typeof UIBarPosition>;
}

declare class UIBarPositioning extends NativeObject implements UIBarPositioning {
}

declare interface UIInteraction extends NSObjectProtocol {
  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;
}

declare class UIInteraction extends NativeObject implements UIInteraction {
}

declare interface UITextInputTokenizer extends NSObjectProtocol {
  rangeEnclosingPositionWithGranularityInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): UITextRange;

  isPositionAtBoundaryInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): boolean;

  positionFromPositionToBoundaryInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): UITextPosition;

  isPositionWithinTextUnitInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): boolean;
}

declare class UITextInputTokenizer extends NativeObject implements UITextInputTokenizer {
}

declare interface UIWindowSceneDelegate extends UISceneDelegate {
  window?: UIWindow;

  windowSceneDidUpdateCoordinateSpaceInterfaceOrientationTraitCollection?(windowScene: UIWindowScene, previousCoordinateSpace: UICoordinateSpace, previousInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>, previousTraitCollection: UITraitCollection): void;

  windowScenePerformActionForShortcutItemCompletionHandler?(windowScene: UIWindowScene, shortcutItem: UIApplicationShortcutItem, completionHandler: (p1: boolean) => void): void;

  windowSceneUserDidAcceptCloudKitShareWithMetadata?(windowScene: UIWindowScene, cloudKitShareMetadata: CKShareMetadata): void;
}

declare class UIWindowSceneDelegate extends NativeObject implements UIWindowSceneDelegate {
}

declare interface UIObjectTraitDefinition extends UITraitDefinition {
}

declare class UIObjectTraitDefinition extends NativeObject implements UIObjectTraitDefinition {
  static readonly defaultValue: NSObject;
}

declare interface UIAdaptivePresentationControllerDelegate extends NSObjectProtocol {
  adaptivePresentationStyleForPresentationController?(controller: UIPresentationController): interop.Enum<typeof UIModalPresentationStyle>;

  adaptivePresentationStyleForPresentationControllerTraitCollection?(controller: UIPresentationController, traitCollection: UITraitCollection): interop.Enum<typeof UIModalPresentationStyle>;

  presentationControllerPrepareAdaptivePresentationController?(presentationController: UIPresentationController, adaptivePresentationController: UIPresentationController): void;

  presentationControllerViewControllerForAdaptivePresentationStyle?(controller: UIPresentationController, style: interop.Enum<typeof UIModalPresentationStyle>): UIViewController;

  presentationControllerWillPresentWithAdaptiveStyleTransitionCoordinator?(presentationController: UIPresentationController, style: interop.Enum<typeof UIModalPresentationStyle>, transitionCoordinator: UIViewControllerTransitionCoordinator | null): void;

  presentationControllerShouldDismiss?(presentationController: UIPresentationController): boolean;

  presentationControllerWillDismiss?(presentationController: UIPresentationController): void;

  presentationControllerDidDismiss?(presentationController: UIPresentationController): void;

  presentationControllerDidAttemptToDismiss?(presentationController: UIPresentationController): void;
}

declare class UIAdaptivePresentationControllerDelegate extends NativeObject implements UIAdaptivePresentationControllerDelegate {
}

declare interface UINavigationBarDelegate extends UIBarPositioningDelegate {
  navigationBarShouldPushItem?(navigationBar: UINavigationBar, item: UINavigationItem): boolean;

  navigationBarDidPushItem?(navigationBar: UINavigationBar, item: UINavigationItem): void;

  navigationBarShouldPopItem?(navigationBar: UINavigationBar, item: UINavigationItem): boolean;

  navigationBarDidPopItem?(navigationBar: UINavigationBar, item: UINavigationItem): void;

  navigationBarNSToolbarSection?(navigationBar: UINavigationBar): interop.Enum<typeof UINavigationBarNSToolbarSection>;
}

declare class UINavigationBarDelegate extends NativeObject implements UINavigationBarDelegate {
}

declare interface UIPageControlProgressDelegate extends NSObjectProtocol {
  pageControlProgressInitialProgressForPage?(progress: UIPageControlProgress, page: number): number;

  pageControlProgressVisibilityDidChange?(progress: UIPageControlProgress): void;
}

declare class UIPageControlProgressDelegate extends NativeObject implements UIPageControlProgressDelegate {
}

declare interface UIWebViewDelegate extends NSObjectProtocol {
  webViewShouldStartLoadWithRequestNavigationType?(webView: UIWebView, request: NSURLRequest, navigationType: interop.Enum<typeof UIWebViewNavigationType>): boolean;

  webViewDidStartLoad?(webView: UIWebView): void;

  webViewDidFinishLoad?(webView: UIWebView): void;

  webViewDidFailLoadWithError?(webView: UIWebView, error: NSError): void;
}

declare class UIWebViewDelegate extends NativeObject implements UIWebViewDelegate {
}

declare interface UIFocusItemScrollableContainer extends UIFocusItemContainer {
  contentOffset: CGPoint;

  readonly contentSize: CGSize;

  readonly visibleSize: CGSize;
}

declare class UIFocusItemScrollableContainer extends NativeObject implements UIFocusItemScrollableContainer {
}

declare interface UICollectionViewDataSourcePrefetching extends NSObjectProtocol {
  collectionViewPrefetchItemsAtIndexPaths(collectionView: UICollectionView, indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  collectionViewCancelPrefetchingForItemsAtIndexPaths?(collectionView: UICollectionView, indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;
}

declare class UICollectionViewDataSourcePrefetching extends NativeObject implements UICollectionViewDataSourcePrefetching {
}

declare interface UITextDocumentProxy extends UIKeyInput {
  readonly documentContextBeforeInput: string;

  readonly documentContextAfterInput: string;

  readonly selectedText: string;

  readonly documentInputMode: UITextInputMode;

  readonly documentIdentifier: NSUUID;

  adjustTextPositionByCharacterOffset(offset: number): void;

  setMarkedTextSelectedRange(markedText: string, selectedRange: _NSRange): void;

  unmarkText(): void;
}

declare class UITextDocumentProxy extends NativeObject implements UITextDocumentProxy {
}

declare interface UICollectionViewDropPlaceholderContext extends UIDragAnimating {
  readonly dragItem: UIDragItem;

  commitInsertionWithDataSourceUpdates(dataSourceUpdates: (p1: NSIndexPath) => void): boolean;

  deletePlaceholder(): boolean;

  setNeedsCellUpdate(): void;
}

declare class UICollectionViewDropPlaceholderContext extends NativeObject implements UICollectionViewDropPlaceholderContext {
}

declare interface UIDynamicItem extends NSObjectProtocol {
  center: CGPoint;

  readonly bounds: CGRect;

  transform: CGAffineTransform;

  readonly collisionBoundsType?: interop.Enum<typeof UIDynamicItemCollisionBoundsType>;

  readonly collisionBoundingPath?: UIBezierPath;
}

declare class UIDynamicItem extends NativeObject implements UIDynamicItem {
}

declare interface UIViewControllerContextTransitioning extends NSObjectProtocol {
  readonly containerView: UIView;

  readonly isAnimated: boolean;

  readonly isInteractive: boolean;

  readonly transitionWasCancelled: boolean;

  readonly presentationStyle: interop.Enum<typeof UIModalPresentationStyle>;

  updateInteractiveTransition(percentComplete: number): void;

  finishInteractiveTransition(): void;

  cancelInteractiveTransition(): void;

  pauseInteractiveTransition(): void;

  completeTransition(didComplete: boolean): void;

  viewControllerForKey(key: string): UIViewController;

  viewForKey(key: string): UIView;

  readonly targetTransform: CGAffineTransform;

  initialFrameForViewController(vc: UIViewController): this;

  finalFrameForViewController(vc: UIViewController): CGRect;
}

declare class UIViewControllerContextTransitioning extends NativeObject implements UIViewControllerContextTransitioning {
}

declare interface UIContentContainer extends NSObjectProtocol {
  readonly preferredContentSize: CGSize;

  preferredContentSizeDidChangeForChildContentContainer(container: UIContentContainer): void;

  systemLayoutFittingSizeDidChangeForChildContentContainer(container: UIContentContainer): void;

  sizeForChildContentContainerWithParentContainerSize(container: UIContentContainer, parentSize: CGSize): CGSize;

  viewWillTransitionToSizeWithTransitionCoordinator(size: CGSize, coordinator: UIViewControllerTransitionCoordinator): void;

  willTransitionToTraitCollectionWithTransitionCoordinator(newCollection: UITraitCollection, coordinator: UIViewControllerTransitionCoordinator): void;
}

declare class UIContentContainer extends NativeObject implements UIContentContainer {
}

declare interface UIScreenshotServiceDelegate extends NSObjectProtocol {
  screenshotServiceGeneratePDFRepresentationWithCompletion?(screenshotService: UIScreenshotService, completionHandler: (p1: NSData, p2: number, p3: CGRect) => void | null): void;
}

declare class UIScreenshotServiceDelegate extends NativeObject implements UIScreenshotServiceDelegate {
}

declare interface UIPreviewActionItem extends NSObjectProtocol {
  readonly title: string;
}

declare class UIPreviewActionItem extends NativeObject implements UIPreviewActionItem {
}

declare interface NSTextElementProvider extends NSObjectProtocol {
  readonly documentRange: NSTextRange;

  enumerateTextElementsFromLocationOptionsUsingBlock(textLocation: NSTextLocation | null, options: interop.Enum<typeof NSTextContentManagerEnumerationOptions>, block: (p1: NSTextElement) => boolean): NSTextLocation;

  replaceContentsInRangeWithTextElements(range: NSTextRange, textElements: NSArray<interop.Object> | Array<interop.Object> | null): void;

  synchronizeToBackingStore(completionHandler: (p1: NSError) => void | null): void;

  locationFromLocationWithOffset?(location: NSTextLocation, offset: number): NSTextLocation;

  offsetFromLocationToLocation?(from: NSTextLocation, to: NSTextLocation): number;

  adjustedRangeFromRangeForEditingTextSelection?(textRange: NSTextRange, forEditingTextSelection: boolean): NSTextRange;
}

declare class NSTextElementProvider extends NativeObject implements NSTextElementProvider {
}

declare class NSLayoutAnchor<AnchorType = interop.Object> extends NSObject implements NSCopying, NSCoding {
  constraintEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;

  constraintGreaterThanOrEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;

  constraintLessThanOrEqualToAnchor(anchor: NSLayoutAnchor): NSLayoutConstraint;

  constraintEqualToAnchorConstant(anchor: NSLayoutAnchor, c: number): NSLayoutConstraint;

  constraintGreaterThanOrEqualToAnchorConstant(anchor: NSLayoutAnchor, c: number): NSLayoutConstraint;

  constraintLessThanOrEqualToAnchorConstant(anchor: NSLayoutAnchor, c: number): NSLayoutConstraint;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIDragPreview extends NSObject implements NSCopying {
  initWithViewParameters(view: UIView, parameters: UIDragPreviewParameters): this;

  initWithView(view: UIView): this;

  readonly view: UIView;

  readonly parameters: UIDragPreviewParameters;

  static previewForURL<This extends abstract new (...args: any) => any>(this: This, url: NSURL): InstanceType<This>;

  static previewForURLTitle<This extends abstract new (...args: any) => any>(this: This, url: NSURL, title: string | null): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPencilInteractionSqueeze extends NSObject {
  readonly timestamp: number;

  readonly phase: interop.Enum<typeof UIPencilInteractionPhase>;

  readonly hoverPose: UIPencilHoverPose;
}

declare class UIToolTipConfiguration extends NSObject {
  readonly toolTip: string;

  readonly sourceRect: CGRect;

  static configurationWithToolTip<This extends abstract new (...args: any) => any>(this: This, toolTip: string): InstanceType<This>;

  static configurationWithToolTipInRect<This extends abstract new (...args: any) => any>(this: This, toolTip: string, sourceRect: CGRect): InstanceType<This>;
}

declare class UICalendarViewDecoration extends NSObject {
  init(): this;

  initWithImageColorSize(image: UIImage | null, color: UIColor | null, size: interop.Enum<typeof UICalendarViewDecorationSize>): this;

  initWithCustomViewProvider(customViewProvider: () => UIView): this;

  static decorationWithColorSize<This extends abstract new (...args: any) => any>(this: This, color: UIColor | null, size: interop.Enum<typeof UICalendarViewDecorationSize>): InstanceType<This>;

  static decorationWithImage<This extends abstract new (...args: any) => any>(this: This, image: UIImage | null): InstanceType<This>;

  static decorationWithImageColorSize<This extends abstract new (...args: any) => any>(this: This, image: UIImage | null, color: UIColor | null, size: interop.Enum<typeof UICalendarViewDecorationSize>): InstanceType<This>;

  static decorationWithCustomViewProvider<This extends abstract new (...args: any) => any>(this: This, customViewProvider: () => UIView): InstanceType<This>;
}

declare class UILexiconEntry extends NSObject implements NSCopying {
  readonly documentText: string;

  readonly userInput: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIDeferredMenuElement extends UIMenuElement {
  static elementWithProvider<This extends abstract new (...args: any) => any>(this: This, elementProvider: (p1: (p1: NSArray<interop.Object> | Array<interop.Object>) => void) => void): InstanceType<This>;

  static elementWithUncachedProvider<This extends abstract new (...args: any) => any>(this: This, elementProvider: (p1: (p1: NSArray<interop.Object> | Array<interop.Object>) => void) => void): InstanceType<This>;
}

declare class UITextSelectionRect extends NSObject {
  readonly rect: CGRect;

  readonly writingDirection: interop.Enum<typeof NSWritingDirection>;

  readonly containsStart: boolean;

  readonly containsEnd: boolean;

  readonly isVertical: boolean;

  readonly transform: CGAffineTransform;
}

declare class UIScribbleInteraction extends NSObject implements UIInteraction {
  initWithDelegate(delegate: UIScribbleInteractionDelegate): this;

  readonly delegate: UIScribbleInteractionDelegate;

  readonly isHandlingWriting: boolean;

  static readonly isPencilInputExpected: boolean;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIAccelerometer extends NSObject {
  static sharedAccelerometer(): UIAccelerometer;

  updateInterval: number;

  delegate: UIAccelerometerDelegate;
}

declare class UITraitVerticalSizeClass extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIStoryboardUnwindSegueSource extends NSObject {
  readonly sourceViewController: UIViewController;

  readonly unwindAction: string;

  readonly sender: interop.Object;
}

declare class UICollectionViewCell extends UICollectionReusableView {
  readonly configurationState: UICellConfigurationState;

  setNeedsUpdateConfiguration(): void;

  updateConfigurationUsingState(state: UICellConfigurationState): void;

  configurationUpdateHandler: (p1: UICollectionViewCell, p2: UICellConfigurationState) => void;

  contentConfiguration: UIContentConfiguration;

  automaticallyUpdatesContentConfiguration: boolean;

  readonly contentView: UIView;

  isSelected: boolean;

  isHighlighted: boolean;

  dragStateDidChange(dragState: interop.Enum<typeof UICollectionViewCellDragState>): void;

  defaultBackgroundConfiguration(): UIBackgroundConfiguration;

  backgroundConfiguration: UIBackgroundConfiguration;

  automaticallyUpdatesBackgroundConfiguration: boolean;

  backgroundView: UIView;

  selectedBackgroundView: UIView;
}

declare class UIMotionEffectGroup extends UIMotionEffect {
  get motionEffects(): NSArray;
  set motionEffects(value: NSArray<interop.Object> | Array<interop.Object>);
}

declare class NSLayoutYAxisAnchor extends NSLayoutAnchor {
  anchorWithOffsetToAnchor(otherAnchor: NSLayoutYAxisAnchor): NSLayoutDimension;

  constraintEqualToSystemSpacingBelowAnchorMultiplier(anchor: NSLayoutYAxisAnchor, multiplier: number): NSLayoutConstraint;

  constraintGreaterThanOrEqualToSystemSpacingBelowAnchorMultiplier(anchor: NSLayoutYAxisAnchor, multiplier: number): NSLayoutConstraint;

  constraintLessThanOrEqualToSystemSpacingBelowAnchorMultiplier(anchor: NSLayoutYAxisAnchor, multiplier: number): NSLayoutConstraint;
}

declare class UITabBarAppearance extends UIBarAppearance {
  stackedLayoutAppearance: UITabBarItemAppearance;

  inlineLayoutAppearance: UITabBarItemAppearance;

  compactInlineLayoutAppearance: UITabBarItemAppearance;

  selectionIndicatorTintColor: UIColor;

  selectionIndicatorImage: UIImage;

  stackedItemPositioning: interop.Enum<typeof UITabBarItemPositioning>;

  stackedItemWidth: number;

  stackedItemSpacing: number;
}

declare class UISceneDestructionRequestOptions extends NSObject {
}

declare class UIView extends UIResponder implements NSCoding, UIAppearance, UIAppearanceContainer, UIDynamicItem, UITraitEnvironment, UICoordinateSpace, UIFocusItem, UIFocusItemContainer, CALayerDelegate {
  static readonly layerClass: interop.Object;

  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  isUserInteractionEnabled: boolean;

  tag: number;

  readonly layer: CALayer;

  readonly canBecomeFocused: boolean;

  readonly isFocused: boolean;

  focusGroupIdentifier: string;

  focusGroupPriority: number;

  focusEffect: UIFocusEffect;

  semanticContentAttribute: interop.Enum<typeof UISemanticContentAttribute>;

  static userInterfaceLayoutDirectionForSemanticContentAttribute(attribute: interop.Enum<typeof UISemanticContentAttribute>): interop.Enum<typeof UIUserInterfaceLayoutDirection>;

  static userInterfaceLayoutDirectionForSemanticContentAttributeRelativeToLayoutDirection(semanticContentAttribute: interop.Enum<typeof UISemanticContentAttribute>, layoutDirection: interop.Enum<typeof UIUserInterfaceLayoutDirection>): interop.Enum<typeof UIUserInterfaceLayoutDirection>;

  readonly effectiveUserInterfaceLayoutDirection: interop.Enum<typeof UIUserInterfaceLayoutDirection>;

  frame: CGRect;

  bounds: CGRect;

  center: CGPoint;

  transform: CGAffineTransform;

  transform3D: CATransform3D;

  contentScaleFactor: number;

  anchorPoint: CGPoint;

  isMultipleTouchEnabled: boolean;

  isExclusiveTouch: boolean;

  hitTestWithEvent(point: CGPoint, event: UIEvent | null): UIView;

  pointInsideWithEvent(point: CGPoint, event: UIEvent | null): boolean;

  convertPointToView(point: CGPoint, view: UIView | null): CGPoint;

  convertPointFromView(point: CGPoint, view: UIView | null): CGPoint;

  convertRectToView(rect: CGRect, view: UIView | null): CGRect;

  convertRectFromView(rect: CGRect, view: UIView | null): CGRect;

  autoresizesSubviews: boolean;

  autoresizingMask: interop.Enum<typeof UIViewAutoresizing>;

  sizeThatFits(size: CGSize): CGSize;

  sizeToFit(): void;

  readonly superview: UIView;

  readonly subviews: NSArray;

  readonly window: UIWindow;

  removeFromSuperview(): void;

  insertSubviewAtIndex(view: UIView, index: number): void;

  exchangeSubviewAtIndexWithSubviewAtIndex(index1: number, index2: number): void;

  addSubview(view: UIView): void;

  insertSubviewBelowSubview(view: UIView, siblingSubview: UIView): void;

  insertSubviewAboveSubview(view: UIView, siblingSubview: UIView): void;

  bringSubviewToFront(view: UIView): void;

  sendSubviewToBack(view: UIView): void;

  didAddSubview(subview: UIView): void;

  willRemoveSubview(subview: UIView): void;

  willMoveToSuperview(newSuperview: UIView | null): void;

  didMoveToSuperview(): void;

  willMoveToWindow(newWindow: UIWindow | null): void;

  didMoveToWindow(): void;

  isDescendantOfView(view: UIView): boolean;

  viewWithTag(tag: number): UIView;

  setNeedsLayout(): void;

  layoutIfNeeded(): void;

  layoutSubviews(): void;

  layoutMargins: UIEdgeInsets;

  directionalLayoutMargins: NSDirectionalEdgeInsets;

  preservesSuperviewLayoutMargins: boolean;

  insetsLayoutMarginsFromSafeArea: boolean;

  layoutMarginsDidChange(): void;

  readonly safeAreaInsets: UIEdgeInsets;

  safeAreaInsetsDidChange(): void;

  readonly layoutMarginsGuide: UILayoutGuide;

  readonly readableContentGuide: UILayoutGuide;

  readonly safeAreaLayoutGuide: UILayoutGuide;

  readonly keyboardLayoutGuide: UIKeyboardLayoutGuide;

  drawRect(rect: CGRect): void;

  setNeedsDisplay(): void;

  setNeedsDisplayInRect(rect: CGRect): void;

  clipsToBounds: boolean;

  backgroundColor: UIColor;

  alpha: number;

  isOpaque: boolean;

  clearsContextBeforeDrawing: boolean;

  isHidden: boolean;

  contentMode: interop.Enum<typeof UIViewContentMode>;

  contentStretch: CGRect;

  maskView: UIView;

  tintColor: UIColor;

  tintAdjustmentMode: interop.Enum<typeof UIViewTintAdjustmentMode>;

  tintColorDidChange(): void;

  static setAnimationsEnabled(enabled: boolean): void;

  static readonly areAnimationsEnabled: boolean;

  static performWithoutAnimation(actionsWithoutAnimation: () => void): void;

  static readonly inheritedAnimationDuration: number;

  static animateWithDurationDelayOptionsAnimationsCompletion(duration: number, delay: number, options: interop.Enum<typeof UIViewAnimationOptions>, animations: () => void, completion: (p1: boolean) => void | null): void;

  static animateWithDurationAnimationsCompletion(duration: number, animations: () => void, completion: (p1: boolean) => void | null): void;

  static animateWithDurationAnimations(duration: number, animations: () => void): void;

  static animateWithSpringDurationBounceInitialSpringVelocityDelayOptionsAnimationsCompletion(duration: number, bounce: number, velocity: number, delay: number, options: interop.Enum<typeof UIViewAnimationOptions>, animations: () => void, completion: (p1: boolean) => void | null): void;

  static animateWithDurationDelayUsingSpringWithDampingInitialSpringVelocityOptionsAnimationsCompletion(duration: number, delay: number, dampingRatio: number, velocity: number, options: interop.Enum<typeof UIViewAnimationOptions>, animations: () => void, completion: (p1: boolean) => void | null): void;

  static transitionWithViewDurationOptionsAnimationsCompletion(view: UIView, duration: number, options: interop.Enum<typeof UIViewAnimationOptions>, animations: () => void | null, completion: (p1: boolean) => void | null): void;

  static transitionFromViewToViewDurationOptionsCompletion(fromView: UIView, toView: UIView, duration: number, options: interop.Enum<typeof UIViewAnimationOptions>, completion: (p1: boolean) => void | null): void;

  static performSystemAnimationOnViewsOptionsAnimationsCompletion(animation: interop.Enum<typeof UISystemAnimation>, views: NSArray<interop.Object> | Array<interop.Object>, options: interop.Enum<typeof UIViewAnimationOptions>, parallelAnimations: () => void | null, completion: (p1: boolean) => void | null): void;

  static modifyAnimationsWithRepeatCountAutoreversesAnimations(count: number, autoreverses: boolean, animations: () => void): void;

  static animateKeyframesWithDurationDelayOptionsAnimationsCompletion(duration: number, delay: number, options: interop.Enum<typeof UIViewKeyframeAnimationOptions>, animations: () => void, completion: (p1: boolean) => void | null): void;

  static addKeyframeWithRelativeStartTimeRelativeDurationAnimations(frameStartTime: number, frameDuration: number, animations: () => void): void;

  get gestureRecognizers(): NSArray;
  set gestureRecognizers(value: NSArray<interop.Object> | Array<interop.Object>);

  addGestureRecognizer(gestureRecognizer: UIGestureRecognizer): void;

  removeGestureRecognizer(gestureRecognizer: UIGestureRecognizer): void;

  gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer): boolean;

  addMotionEffect(effect: UIMotionEffect): void;

  removeMotionEffect(effect: UIMotionEffect): void;

  get motionEffects(): NSArray;
  set motionEffects(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly constraints: NSArray;

  addConstraint(constraint: NSLayoutConstraint): void;

  addConstraints(constraints: NSArray<interop.Object> | Array<interop.Object>): void;

  removeConstraint(constraint: NSLayoutConstraint): void;

  removeConstraints(constraints: NSArray<interop.Object> | Array<interop.Object>): void;

  updateConstraintsIfNeeded(): void;

  updateConstraints(): void;

  needsUpdateConstraints(): boolean;

  setNeedsUpdateConstraints(): void;

  translatesAutoresizingMaskIntoConstraints: boolean;

  static readonly requiresConstraintBasedLayout: boolean;

  alignmentRectForFrame(frame: CGRect): CGRect;

  frameForAlignmentRect(alignmentRect: CGRect): CGRect;

  readonly alignmentRectInsets: UIEdgeInsets;

  viewForBaselineLayout(): UIView;

  readonly viewForFirstBaselineLayout: UIView;

  readonly viewForLastBaselineLayout: UIView;

  readonly intrinsicContentSize: CGSize;

  invalidateIntrinsicContentSize(): void;

  contentHuggingPriorityForAxis(axis: interop.Enum<typeof UILayoutConstraintAxis>): number;

  setContentHuggingPriorityForAxis(priority: number, axis: interop.Enum<typeof UILayoutConstraintAxis>): void;

  contentCompressionResistancePriorityForAxis(axis: interop.Enum<typeof UILayoutConstraintAxis>): number;

  setContentCompressionResistancePriorityForAxis(priority: number, axis: interop.Enum<typeof UILayoutConstraintAxis>): void;

  systemLayoutSizeFittingSize(targetSize: CGSize): CGSize;

  systemLayoutSizeFittingSizeWithHorizontalFittingPriorityVerticalFittingPriority(targetSize: CGSize, horizontalFittingPriority: number, verticalFittingPriority: number): CGSize;

  readonly layoutGuides: NSArray;

  addLayoutGuide(layoutGuide: UILayoutGuide): void;

  removeLayoutGuide(layoutGuide: UILayoutGuide): void;

  readonly leadingAnchor: NSLayoutXAxisAnchor;

  readonly trailingAnchor: NSLayoutXAxisAnchor;

  readonly leftAnchor: NSLayoutXAxisAnchor;

  readonly rightAnchor: NSLayoutXAxisAnchor;

  readonly topAnchor: NSLayoutYAxisAnchor;

  readonly bottomAnchor: NSLayoutYAxisAnchor;

  readonly widthAnchor: NSLayoutDimension;

  readonly heightAnchor: NSLayoutDimension;

  readonly centerXAnchor: NSLayoutXAxisAnchor;

  readonly centerYAnchor: NSLayoutYAxisAnchor;

  readonly firstBaselineAnchor: NSLayoutYAxisAnchor;

  readonly lastBaselineAnchor: NSLayoutYAxisAnchor;

  constraintsAffectingLayoutForAxis(axis: interop.Enum<typeof UILayoutConstraintAxis>): NSArray;

  readonly hasAmbiguousLayout: boolean;

  exerciseAmbiguityInLayout(): void;

  restorationIdentifier: string;

  encodeRestorableStateWithCoder(coder: NSCoder): void;

  decodeRestorableStateWithCoder(coder: NSCoder): void;

  snapshotViewAfterScreenUpdates(afterUpdates: boolean): UIView;

  resizableSnapshotViewFromRectAfterScreenUpdatesWithCapInsets(rect: CGRect, afterUpdates: boolean, capInsets: UIEdgeInsets): UIView;

  drawViewHierarchyInRectAfterScreenUpdates(rect: CGRect, afterUpdates: boolean): boolean;

  static beginAnimationsContext(animationID: string | null, context: interop.PointerConvertible): void;

  static commitAnimations(): void;

  static setAnimationDelegate(delegate: interop.Object | null): void;

  static setAnimationWillStartSelector(selector: string | null): void;

  static setAnimationDidStopSelector(selector: string | null): void;

  static setAnimationDuration(duration: number): void;

  static setAnimationDelay(delay: number): void;

  static setAnimationStartDate(startDate: NSDate): void;

  static setAnimationCurve(curve: interop.Enum<typeof UIViewAnimationCurve>): void;

  static setAnimationRepeatCount(repeatCount: number): void;

  static setAnimationRepeatAutoreverses(repeatAutoreverses: boolean): void;

  static setAnimationBeginsFromCurrentState(fromCurrentState: boolean): void;

  static setAnimationTransitionForViewCache(transition: interop.Enum<typeof UIViewAnimationTransition>, view: UIView, cache: boolean): void;

  overrideUserInterfaceStyle: interop.Enum<typeof UIUserInterfaceStyle>;

  minimumContentSizeCategory: string;

  maximumContentSizeCategory: string;

  readonly appliedContentSizeCategoryLimitsDescription: string;

  readonly traitOverrides: UITraitOverrides;

  updateTraitsIfNeeded(): void;

  addInteraction(interaction: UIInteraction): void;

  removeInteraction(interaction: UIInteraction): void;

  get interactions(): NSArray;
  set interactions(value: NSArray<interop.Object> | Array<interop.Object>);

  accessibilityIgnoresInvertColors: boolean;

  endEditing(force: boolean): boolean;

  showsLargeContentViewer: boolean;

  largeContentTitle: string;

  largeContentImage: UIImage;

  scalesLargeContentImage: boolean;

  largeContentImageInsets: UIEdgeInsets;

  hoverStyle: UIHoverStyle;

  viewPrintFormatter(): UIViewPrintFormatter;

  drawRectForViewPrintFormatter(rect: CGRect, formatter: UIViewPrintFormatter): void;

  encodeWithCoder(coder: NSCoder): void;

  static appearance<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static appearanceWhenContainedIn<This extends abstract new (...args: any) => any>(this: This, ContainerClass: UIAppearanceContainer | null): InstanceType<This>;

  static appearanceWhenContainedInInstancesOfClasses<This extends abstract new (...args: any) => any>(this: This, containerTypes: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static appearanceForTraitCollection<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection): InstanceType<This>;

  static appearanceForTraitCollectionWhenContainedIn<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection, ContainerClass: UIAppearanceContainer | null): InstanceType<This>;

  static appearanceForTraitCollectionWhenContainedInInstancesOfClasses<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection, containerTypes: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  readonly collisionBoundsType: interop.Enum<typeof UIDynamicItemCollisionBoundsType>;

  readonly collisionBoundingPath: UIBezierPath;

  readonly traitCollection: UITraitCollection;

  traitCollectionDidChange(previousTraitCollection: UITraitCollection | null): void;

  convertPointToCoordinateSpace(point: CGPoint, coordinateSpace: UICoordinateSpace): CGPoint;

  convertPointFromCoordinateSpace(point: CGPoint, coordinateSpace: UICoordinateSpace): CGPoint;

  convertRectToCoordinateSpace(rect: CGRect, coordinateSpace: UICoordinateSpace): CGRect;

  convertRectFromCoordinateSpace(rect: CGRect, coordinateSpace: UICoordinateSpace): CGRect;

  readonly isTransparentFocusItem: boolean;

  didHintFocusMovement(hint: UIFocusMovementHint): void;

  readonly preferredFocusEnvironments: NSArray;

  readonly parentFocusEnvironment: UIFocusEnvironment;

  readonly focusItemContainer: UIFocusItemContainer;

  setNeedsFocusUpdate(): void;

  updateFocusIfNeeded(): void;

  shouldUpdateFocusInContext(context: UIFocusUpdateContext): boolean;

  didUpdateFocusInContextWithAnimationCoordinator(context: UIFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  readonly preferredFocusedView: UIView;

  readonly coordinateSpace: UICoordinateSpace;

  focusItemsInRect(rect: CGRect): NSArray;

  displayLayer(layer: CALayer): void;

  drawLayerInContext(layer: CALayer, ctx: interop.PointerConvertible): void;

  layerWillDraw(layer: CALayer): void;

  layoutSublayersOfLayer(layer: CALayer): void;

  actionForLayerForKey(layer: CALayer, event: string): CAAction;
}

declare class UIFocusMovementHint extends NSObject implements NSCopying {
  readonly movementDirection: CGVector;

  readonly perspectiveTransform: CATransform3D;

  readonly rotation: CGVector;

  readonly translation: CGVector;

  readonly interactionTransform: CATransform3D;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITextItemMenuPreview extends NSObject {
  static defaultPreview<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  initWithView(view: UIView): this;
}

declare class UIMenuController extends NSObject {
  static readonly sharedMenuController: UIMenuController;

  isMenuVisible: boolean;

  setMenuVisibleAnimated(menuVisible: boolean, animated: boolean): void;

  setTargetRectInView(targetRect: CGRect, targetView: UIView): void;

  showMenuFromViewRect(targetView: UIView, targetRect: CGRect): void;

  hideMenuFromView(targetView: UIView): void;

  hideMenu(): void;

  arrowDirection: interop.Enum<typeof UIMenuControllerArrowDirection>;

  get menuItems(): NSArray;
  set menuItems(value: NSArray<interop.Object> | Array<interop.Object>);

  update(): void;

  readonly menuFrame: CGRect;
}

declare class NSDiffableDataSourceTransaction<SectionIdentifierType = interop.Object, ItemIdentifierType = interop.Object> extends NSObject {
  readonly initialSnapshot: NSDiffableDataSourceSnapshot;

  readonly finalSnapshot: NSDiffableDataSourceSnapshot;

  readonly difference: NSOrderedCollectionDifference;

  readonly sectionTransactions: NSArray;
}

declare class UIBackgroundConfiguration extends NSObject implements NSCopying, NSSecureCoding {
  static clearConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listPlainCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listPlainHeaderFooterConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listGroupedCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listGroupedHeaderFooterConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listSidebarHeaderConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listSidebarCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static listAccompaniedSidebarCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  updatedConfigurationForState(state: UIConfigurationState): this;

  customView: UIView;

  cornerRadius: number;

  backgroundInsets: NSDirectionalEdgeInsets;

  edgesAddingLayoutMarginsToBackgroundInsets: interop.Enum<typeof NSDirectionalRectEdge>;

  backgroundColor: UIColor;

  backgroundColorTransformer: (p1: UIColor) => UIColor;

  resolvedBackgroundColorForTintColor(tintColor: UIColor): UIColor;

  visualEffect: UIVisualEffect;

  image: UIImage;

  imageContentMode: interop.Enum<typeof UIViewContentMode>;

  strokeColor: UIColor;

  strokeColorTransformer: (p1: UIColor) => UIColor;

  resolvedStrokeColorForTintColor(tintColor: UIColor): UIColor;

  strokeWidth: number;

  strokeOutset: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UITextLoupeSession extends NSObject {
  static beginLoupeSessionAtPointFromSelectionWidgetViewInView<This extends abstract new (...args: any) => any>(this: This, point: CGPoint, selectionWidget: UIView | null, interactionView: UIView): InstanceType<This>;

  moveToPointWithCaretRectTrackingCaret(point: CGPoint, caretRect: CGRect, tracksCaret: boolean): void;

  invalidate(): void;
}

declare class UITapGestureRecognizer extends UIGestureRecognizer {
  numberOfTapsRequired: number;

  numberOfTouchesRequired: number;

  buttonMaskRequired: interop.Enum<typeof UIEventButtonMask>;
}

declare class UIColorWell extends UIControl {
  title: string;

  supportsAlpha: boolean;

  selectedColor: UIColor;
}

declare class UIHoverAutomaticEffect extends NSObject implements UIHoverEffect {
  static effect<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICalendarSelection extends NSObject {
  updateSelectableDates(): void;
}

declare class UICalendarSelectionSingleDate extends UICalendarSelection {
  readonly delegate: UICalendarSelectionSingleDateDelegate;

  selectedDate: NSDateComponents;

  setSelectedDateAnimated(selectedDate: NSDateComponents | null, animated: boolean): void;

  initWithDelegate(delegate: UICalendarSelectionSingleDateDelegate | null): this;
}

declare class UITextRange extends NSObject {
  readonly isEmpty: boolean;

  readonly start: UITextPosition;

  readonly end: UITextPosition;
}

declare class UITextInteraction extends NSObject implements UIInteraction {
  delegate: UITextInteractionDelegate | null;

  textInput: UIResponder | null;

  readonly textInteractionMode: interop.Enum<typeof UITextInteractionMode>;

  readonly gesturesForFailureRequirements: NSArray;

  static textInteractionForMode<This extends abstract new (...args: any) => any>(this: This, mode: interop.Enum<typeof UITextInteractionMode>): InstanceType<This>;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIRefreshControl extends UIControl {
  init(): this;

  readonly isRefreshing: boolean;

  tintColor: UIColor;

  attributedTitle: NSAttributedString;

  beginRefreshing(): void;

  endRefreshing(): void;
}

declare class UIFontPickerViewController extends UIViewController {
  initWithConfiguration(configuration: UIFontPickerViewControllerConfiguration): this;

  readonly configuration: UIFontPickerViewControllerConfiguration;

  delegate: UIFontPickerViewControllerDelegate;

  selectedFontDescriptor: UIFontDescriptor;
}

declare class UIWindowSceneGeometry extends NSObject implements NSCopying {
  readonly interfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIWindowSceneActivationInteraction extends NSObject implements UIInteraction {
  initWithConfigurationProviderErrorHandler(configurationProvider: (p1: UIWindowSceneActivationInteraction, p2: CGPoint) => UIWindowSceneActivationConfiguration, errorHandler: (p1: NSError) => void): this;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIWindowSceneProminentPlacement extends UIWindowScenePlacement {
  static prominentPlacement<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSCollectionLayoutGroup extends NSCollectionLayoutItem implements NSCopying {
  static horizontalGroupWithLayoutSizeRepeatingSubitemCount<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): InstanceType<This>;

  static horizontalGroupWithLayoutSizeSubitems<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, subitems: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static verticalGroupWithLayoutSizeRepeatingSubitemCount<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): InstanceType<This>;

  static verticalGroupWithLayoutSizeSubitems<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, subitems: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static customGroupWithLayoutSizeItemProvider<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, itemProvider: (p1: NSCollectionLayoutEnvironment) => NSArray): InstanceType<This>;

  // @ts-ignore MemberDecl.tsIgnore
  get supplementaryItems(): NSArray;
  // @ts-ignore MemberDecl.tsIgnore
  set supplementaryItems(value: NSArray<interop.Object> | Array<interop.Object>);

  interItemSpacing: NSCollectionLayoutSpacing;

  readonly subitems: NSArray;

  visualDescription(): string;

  static horizontalGroupWithLayoutSizeSubitemCount<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): InstanceType<This>;

  static verticalGroupWithLayoutSizeSubitemCount<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, subitem: NSCollectionLayoutItem, count: number): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UISlider extends UIControl implements NSCoding {
  value: number;

  minimumValue: number;

  maximumValue: number;

  minimumValueImage: UIImage;

  maximumValueImage: UIImage;

  isContinuous: boolean;

  minimumTrackTintColor: UIColor;

  maximumTrackTintColor: UIColor;

  thumbTintColor: UIColor;

  setValueAnimated(value: number, animated: boolean): void;

  setThumbImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  setMinimumTrackImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  setMaximumTrackImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  thumbImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  minimumTrackImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  maximumTrackImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  readonly currentThumbImage: UIImage;

  readonly currentMinimumTrackImage: UIImage;

  readonly currentMaximumTrackImage: UIImage;

  minimumValueImageRectForBounds(bounds: CGRect): CGRect;

  maximumValueImageRectForBounds(bounds: CGRect): CGRect;

  trackRectForBounds(bounds: CGRect): CGRect;

  thumbRectForBoundsTrackRectValue(bounds: CGRect, rect: CGRect, value: number): CGRect;

  readonly behavioralStyle: interop.Enum<typeof UIBehavioralStyle>;

  preferredBehavioralStyle: interop.Enum<typeof UIBehavioralStyle>;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIVibrancyEffect extends UIVisualEffect {
  static effectForBlurEffect(blurEffect: UIBlurEffect): UIVibrancyEffect;

  static effectForBlurEffectStyle(blurEffect: UIBlurEffect, style: interop.Enum<typeof UIVibrancyEffectStyle>): UIVibrancyEffect;
}

declare class NSCollectionLayoutItem extends NSObject implements NSCopying {
  static itemWithLayoutSize<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize): InstanceType<This>;

  static itemWithLayoutSizeSupplementaryItems<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, supplementaryItems: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  contentInsets: NSDirectionalEdgeInsets;

  edgeSpacing: NSCollectionLayoutEdgeSpacing;

  readonly layoutSize: NSCollectionLayoutSize;

  readonly supplementaryItems: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UISearchTextField extends UITextField {
  get tokens(): NSArray;
  set tokens(value: NSArray<interop.Object> | Array<interop.Object>);

  insertTokenAtIndex(token: UISearchToken, tokenIndex: number): void;

  removeTokenAtIndex(tokenIndex: number): void;

  positionOfTokenAtIndex(tokenIndex: number): UITextPosition;

  tokensInRange(textRange: UITextRange): NSArray;

  readonly textualRange: UITextRange;

  replaceTextualPortionOfRangeWithTokenAtIndex(textRange: UITextRange, token: UISearchToken, tokenIndex: number): void;

  tokenBackgroundColor: UIColor;

  allowsDeletingTokens: boolean;

  allowsCopyingTokens: boolean;

  get searchSuggestions(): NSArray;
  set searchSuggestions(value: NSArray<interop.Object> | Array<interop.Object>);
}

declare class UIScene extends UIResponder {
  initWithSessionConnectionOptions(session: UISceneSession, connectionOptions: UISceneConnectionOptions): this;

  readonly session: UISceneSession;

  delegate: UISceneDelegate;

  readonly activationState: interop.Enum<typeof UISceneActivationState>;

  openURLOptionsCompletionHandler(url: NSURL, options: UISceneOpenExternalURLOptions | null, completion: (p1: boolean) => void | null): void;

  title: string;

  subtitle: string;

  activationConditions: UISceneActivationConditions;

  readonly pointerLockState: UIPointerLockState;

  extendStateRestoration(): void;

  completeStateRestoration(): void;
}

declare class UIListContentImageProperties extends NSObject implements NSCopying, NSSecureCoding {
  preferredSymbolConfiguration: UIImageSymbolConfiguration;

  tintColor: UIColor;

  tintColorTransformer: (p1: UIColor) => UIColor;

  resolvedTintColorForTintColor(tintColor: UIColor): UIColor;

  cornerRadius: number;

  maximumSize: CGSize;

  reservedLayoutSize: CGSize;

  accessibilityIgnoresInvertColors: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIWindowSceneDestructionRequestOptions extends UISceneDestructionRequestOptions {
  windowDismissalAnimation: interop.Enum<typeof UIWindowSceneDismissalAnimation>;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIPageControlTimerProgress extends UIPageControlProgress {
  initWithPreferredDuration(preferredDuration: number): this;

  // @ts-ignore MemberDecl.tsIgnore
  delegate: UIPageControlTimerProgressDelegate;

  resetsToInitialPageAfterEnd: boolean;

  readonly isRunning: boolean;

  resumeTimer(): void;

  pauseTimer(): void;

  preferredDuration: number;

  setDurationForPage(duration: number, page: number): void;

  durationForPage(page: number): number;
}

declare class UIDynamicBehavior extends NSObject {
  addChildBehavior(behavior: UIDynamicBehavior): void;

  removeChildBehavior(behavior: UIDynamicBehavior): void;

  readonly childBehaviors: NSArray;

  action: () => void;

  willMoveToAnimator(dynamicAnimator: UIDynamicAnimator | null): void;

  readonly dynamicAnimator: UIDynamicAnimator;
}

declare class UITextFormattingCoordinator extends NSObject implements UIFontPickerViewControllerDelegate {
  delegate: UITextFormattingCoordinatorDelegate;

  static readonly isFontPanelVisible: boolean;

  static textFormattingCoordinatorForWindowScene<This extends abstract new (...args: any) => any>(this: This, windowScene: UIWindowScene): InstanceType<This>;

  initWithWindowScene(windowScene: UIWindowScene): this;

  setSelectedAttributesIsMultiple(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, flag: boolean): void;

  static toggleFontPanel(sender: interop.Object): void;

  fontPickerViewControllerDidCancel(viewController: UIFontPickerViewController): void;

  fontPickerViewControllerDidPickFont(viewController: UIFontPickerViewController): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSCollectionLayoutSpacing extends NSObject implements NSCopying {
  static flexibleSpacing<This extends abstract new (...args: any) => any>(this: This, flexibleSpacing: number): InstanceType<This>;

  static fixedSpacing<This extends abstract new (...args: any) => any>(this: This, fixedSpacing: number): InstanceType<This>;

  readonly spacing: number;

  readonly isFlexibleSpacing: boolean;

  readonly isFixedSpacing: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIMenuDisplayPreferences extends NSObject implements NSCopying, NSSecureCoding {
  maximumNumberOfTitleLines: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIStackView extends UIView {
  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  initWithArrangedSubviews(views: NSArray<interop.Object> | Array<interop.Object>): this;

  readonly arrangedSubviews: NSArray;

  addArrangedSubview(view: UIView): void;

  removeArrangedSubview(view: UIView): void;

  insertArrangedSubviewAtIndex(view: UIView, stackIndex: number): void;

  axis: interop.Enum<typeof UILayoutConstraintAxis>;

  distribution: interop.Enum<typeof UIStackViewDistribution>;

  alignment: interop.Enum<typeof UIStackViewAlignment>;

  spacing: number;

  setCustomSpacingAfterView(spacing: number, arrangedSubview: UIView): void;

  customSpacingAfterView(arrangedSubview: UIView): number;

  isBaselineRelativeArrangement: boolean;

  isLayoutMarginsRelativeArrangement: boolean;
}

declare class UITextDragPreviewRenderer extends NSObject {
  initWithLayoutManagerRange(layoutManager: NSLayoutManager, range: _NSRange): this;

  initWithLayoutManagerRangeUnifyRects(layoutManager: NSLayoutManager, range: _NSRange, unifyRects: boolean): this;

  readonly layoutManager: NSLayoutManager;

  readonly image: UIImage;

  readonly firstLineRect: CGRect;

  readonly bodyRect: CGRect;

  readonly lastLineRect: CGRect;

  adjustFirstLineRectBodyRectLastLineRectTextOrigin(firstLineRect: interop.PointerConvertible, bodyRect: interop.PointerConvertible, lastLineRect: interop.PointerConvertible, origin: CGPoint): void;
}

declare class UICollectionLayoutSectionOrthogonalScrollingProperties extends NSObject implements NSCopying {
  decelerationRate: number;

  bounce: interop.Enum<typeof UICollectionLayoutSectionOrthogonalScrollingBounce>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITextPlaceholder extends NSObject {
  readonly rects: NSArray;
}

declare class UICollectionViewLayout extends NSObject implements NSCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  readonly collectionView: UICollectionView;

  invalidateLayout(): void;

  invalidateLayoutWithContext(context: UICollectionViewLayoutInvalidationContext): void;

  registerClassForDecorationViewOfKind(viewClass: interop.Object | null, elementKind: string): void;

  registerNibForDecorationViewOfKind(nib: UINib | null, elementKind: string): void;

  static readonly layoutAttributesClass: interop.Object;

  static readonly invalidationContextClass: interop.Object;

  prepareLayout(): void;

  layoutAttributesForElementsInRect(rect: CGRect): NSArray;

  layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  layoutAttributesForSupplementaryViewOfKindAtIndexPath(elementKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  layoutAttributesForDecorationViewOfKindAtIndexPath(elementKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  shouldInvalidateLayoutForBoundsChange(newBounds: CGRect): boolean;

  invalidationContextForBoundsChange(newBounds: CGRect): UICollectionViewLayoutInvalidationContext;

  shouldInvalidateLayoutForPreferredLayoutAttributesWithOriginalAttributes(preferredAttributes: UICollectionViewLayoutAttributes, originalAttributes: UICollectionViewLayoutAttributes): boolean;

  invalidationContextForPreferredLayoutAttributesWithOriginalAttributes(preferredAttributes: UICollectionViewLayoutAttributes, originalAttributes: UICollectionViewLayoutAttributes): UICollectionViewLayoutInvalidationContext;

  targetContentOffsetForProposedContentOffsetWithScrollingVelocity(proposedContentOffset: CGPoint, velocity: CGPoint): CGPoint;

  targetContentOffsetForProposedContentOffset(proposedContentOffset: CGPoint): CGPoint;

  readonly collectionViewContentSize: CGSize;

  readonly developmentLayoutDirection: interop.Enum<typeof UIUserInterfaceLayoutDirection>;

  readonly flipsHorizontallyInOppositeLayoutDirection: boolean;

  prepareForCollectionViewUpdates(updateItems: NSArray<interop.Object> | Array<interop.Object>): void;

  finalizeCollectionViewUpdates(): void;

  prepareForAnimatedBoundsChange(oldBounds: CGRect): void;

  finalizeAnimatedBoundsChange(): void;

  prepareForTransitionToLayout(newLayout: UICollectionViewLayout): void;

  prepareForTransitionFromLayout(oldLayout: UICollectionViewLayout): void;

  finalizeLayoutTransition(): void;

  initialLayoutAttributesForAppearingItemAtIndexPath(itemIndexPath: NSIndexPath): this;

  finalLayoutAttributesForDisappearingItemAtIndexPath(itemIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  initialLayoutAttributesForAppearingSupplementaryElementOfKindAtIndexPath(elementKind: string, elementIndexPath: NSIndexPath): this;

  finalLayoutAttributesForDisappearingSupplementaryElementOfKindAtIndexPath(elementKind: string, elementIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  initialLayoutAttributesForAppearingDecorationElementOfKindAtIndexPath(elementKind: string, decorationIndexPath: NSIndexPath): this;

  finalLayoutAttributesForDisappearingDecorationElementOfKindAtIndexPath(elementKind: string, decorationIndexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  indexPathsToDeleteForSupplementaryViewOfKind(elementKind: string): NSArray;

  indexPathsToDeleteForDecorationViewOfKind(elementKind: string): NSArray;

  indexPathsToInsertForSupplementaryViewOfKind(elementKind: string): NSArray;

  indexPathsToInsertForDecorationViewOfKind(elementKind: string): NSArray;

  targetIndexPathForInteractivelyMovingItemWithPosition(previousIndexPath: NSIndexPath, position: CGPoint): NSIndexPath;

  layoutAttributesForInteractivelyMovingItemAtIndexPathWithTargetPosition(indexPath: NSIndexPath, position: CGPoint): UICollectionViewLayoutAttributes;

  invalidationContextForInteractivelyMovingItemsWithTargetPositionPreviousIndexPathsPreviousPosition(targetIndexPaths: NSArray<interop.Object> | Array<interop.Object>, targetPosition: CGPoint, previousIndexPaths: NSArray<interop.Object> | Array<interop.Object>, previousPosition: CGPoint): UICollectionViewLayoutInvalidationContext;

  invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPathsPreviousIndexPathsMovementCancelled(indexPaths: NSArray<interop.Object> | Array<interop.Object>, previousIndexPaths: NSArray<interop.Object> | Array<interop.Object>, movementCancelled: boolean): UICollectionViewLayoutInvalidationContext;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UITextInputPasswordRules extends NSObject implements NSSecureCoding, NSCopying {
  readonly passwordRulesDescriptor: string;

  static passwordRulesWithDescriptor<This extends abstract new (...args: any) => any>(this: This, passwordRulesDescriptor: string): InstanceType<This>;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIHoverHighlightEffect extends NSObject implements UIHoverEffect {
  static effect<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPanGestureRecognizer extends UIGestureRecognizer {
  minimumNumberOfTouches: number;

  maximumNumberOfTouches: number;

  translationInView(view: UIView | null): CGPoint;

  setTranslationInView(translation: CGPoint, view: UIView | null): void;

  velocityInView(view: UIView | null): CGPoint;

  allowedScrollTypesMask: interop.Enum<typeof UIScrollTypeMask>;
}

declare class UIViewPrintFormatter extends UIPrintFormatter {
  readonly view: UIView;
}

declare class UIRotationGestureRecognizer extends UIGestureRecognizer {
  rotation: number;

  readonly velocity: number;
}

declare class UICollectionViewListCell extends UICollectionViewCell {
  defaultContentConfiguration(): UIListContentConfiguration;

  indentationLevel: number;

  indentationWidth: number;

  indentsAccessories: boolean;

  get accessories(): NSArray;
  set accessories(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly separatorLayoutGuide: UILayoutGuide;
}

declare class UIFocusGuide extends UILayoutGuide {
  isEnabled: boolean;

  get preferredFocusEnvironments(): NSArray;
  set preferredFocusEnvironments(value: NSArray<interop.Object> | Array<interop.Object>);

  preferredFocusedView: UIView;
}

declare class UIPercentDrivenInteractiveTransition extends NSObject implements UIViewControllerInteractiveTransitioning {
  readonly duration: number;

  readonly percentComplete: number;

  completionSpeed: number;

  completionCurve: interop.Enum<typeof UIViewAnimationCurve>;

  timingCurve: UITimingCurveProvider;

  wantsInteractiveStart: boolean;

  pauseInteractiveTransition(): void;

  updateInteractiveTransition(percentComplete: number): void;

  cancelInteractiveTransition(): void;

  finishInteractiveTransition(): void;

  startInteractiveTransition(transitionContext: UIViewControllerContextTransitioning): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSCollectionLayoutSupplementaryItem extends NSCollectionLayoutItem implements NSCopying {
  static supplementaryItemWithLayoutSizeElementKindContainerAnchor<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor): InstanceType<This>;

  static supplementaryItemWithLayoutSizeElementKindContainerAnchorItemAnchor<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, elementKind: string, containerAnchor: NSCollectionLayoutAnchor, itemAnchor: NSCollectionLayoutAnchor): InstanceType<This>;

  zIndex: number;

  readonly elementKind: string;

  readonly containerAnchor: NSCollectionLayoutAnchor;

  readonly itemAnchor: NSCollectionLayoutAnchor;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITraitImageDynamicRange extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UICollectionViewSupplementaryRegistration extends NSObject {
  static registrationWithSupplementaryClassElementKindConfigurationHandler<This extends abstract new (...args: any) => any>(this: This, supplementaryClass: interop.Object, elementKind: string, configurationHandler: (p1: UICollectionReusableView, p2: string, p3: NSIndexPath) => void): InstanceType<This>;

  static registrationWithSupplementaryNibElementKindConfigurationHandler<This extends abstract new (...args: any) => any>(this: This, supplementaryNib: UINib, elementKind: string, configurationHandler: (p1: UICollectionReusableView, p2: string, p3: NSIndexPath) => void): InstanceType<This>;

  readonly supplementaryClass: interop.Object;

  readonly supplementaryNib: UINib;

  readonly elementKind: string;

  readonly configurationHandler: (p1: UICollectionReusableView, p2: string, p3: NSIndexPath) => void;
}

declare class UICellAccessoryDisclosureIndicator extends UICellAccessory {
}

declare class UICollectionViewCellRegistration extends NSObject {
  static registrationWithCellClassConfigurationHandler<This extends abstract new (...args: any) => any>(this: This, cellClass: interop.Object, configurationHandler: (p1: UICollectionViewCell, p2: NSIndexPath, p3: interop.Object) => void): InstanceType<This>;

  static registrationWithCellNibConfigurationHandler<This extends abstract new (...args: any) => any>(this: This, cellNib: UINib, configurationHandler: (p1: UICollectionViewCell, p2: NSIndexPath, p3: interop.Object) => void): InstanceType<This>;

  readonly cellClass: interop.Object;

  readonly cellNib: UINib;

  readonly configurationHandler: (p1: UICollectionViewCell, p2: NSIndexPath, p3: interop.Object) => void;
}

declare class UIPrintInteractionController extends NSObject {
  static readonly isPrintingAvailable: boolean;

  static readonly printableUTIs: NSSet;

  static canPrintURL(url: NSURL): boolean;

  static canPrintData(data: NSData): boolean;

  static readonly sharedPrintController: UIPrintInteractionController;

  printInfo: UIPrintInfo;

  delegate: UIPrintInteractionControllerDelegate;

  showsPageRange: boolean;

  showsNumberOfCopies: boolean;

  showsPaperSelectionForLoadedPapers: boolean;

  showsPaperOrientation: boolean;

  readonly printPaper: UIPrintPaper;

  printPageRenderer: UIPrintPageRenderer;

  printFormatter: UIPrintFormatter;

  printingItem: interop.Object;

  get printingItems(): NSArray;
  set printingItems(value: NSArray<interop.Object> | Array<interop.Object>);

  presentAnimatedCompletionHandler(animated: boolean, completion: (p1: UIPrintInteractionController, p2: boolean, p3: NSError) => void | null): boolean;

  presentFromRectInViewAnimatedCompletionHandler(rect: CGRect, view: UIView, animated: boolean, completion: (p1: UIPrintInteractionController, p2: boolean, p3: NSError) => void | null): boolean;

  presentFromBarButtonItemAnimatedCompletionHandler(item: UIBarButtonItem, animated: boolean, completion: (p1: UIPrintInteractionController, p2: boolean, p3: NSError) => void | null): boolean;

  printToPrinterCompletionHandler(printer: UIPrinter, completion: (p1: UIPrintInteractionController, p2: boolean, p3: NSError) => void | null): boolean;

  dismissAnimated(animated: boolean): void;
}

declare class UITableViewDropPlaceholder extends UITableViewPlaceholder {
  previewParametersProvider: (p1: UITableViewCell) => UIDragPreviewParameters | null;
}

declare class UIWindowSceneStandardPlacement extends UIWindowScenePlacement {
  static standardPlacement<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;
}

declare class UITableViewDiffableDataSource<SectionIdentifierType = interop.Object, ItemIdentifierType = interop.Object> extends NSObject implements UITableViewDataSource {
  initWithTableViewCellProvider(tableView: UITableView, cellProvider: (p1: UITableView, p2: NSIndexPath, p3: interop.Object) => UITableViewCell): this;

  snapshot(): NSDiffableDataSourceSnapshot;

  applySnapshotAnimatingDifferences(snapshot: NSDiffableDataSourceSnapshot, animatingDifferences: boolean): void;

  applySnapshotAnimatingDifferencesCompletion(snapshot: NSDiffableDataSourceSnapshot, animatingDifferences: boolean, completion: () => void | null): void;

  applySnapshotUsingReloadData(snapshot: NSDiffableDataSourceSnapshot): void;

  applySnapshotUsingReloadDataCompletion(snapshot: NSDiffableDataSourceSnapshot, completion: () => void | null): void;

  sectionIdentifierForIndex(index: number): SectionIdentifierType;

  indexForSectionIdentifier(identifier: SectionIdentifierType): number;

  itemIdentifierForIndexPath(indexPath: NSIndexPath): ItemIdentifierType;

  indexPathForItemIdentifier(identifier: ItemIdentifierType): NSIndexPath;

  defaultRowAnimation: interop.Enum<typeof UITableViewRowAnimation>;

  tableViewNumberOfRowsInSection(tableView: UITableView, section: number): number;

  tableViewCellForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UITableViewCell;

  numberOfSectionsInTableView(tableView: UITableView): number;

  tableViewTitleForHeaderInSection(tableView: UITableView, section: number): string;

  tableViewTitleForFooterInSection(tableView: UITableView, section: number): string;

  tableViewCanEditRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewCanMoveRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  sectionIndexTitlesForTableView(tableView: UITableView): NSArray;

  tableViewSectionForSectionIndexTitleAtIndex(tableView: UITableView, title: string, index: number): number;

  tableViewCommitEditingStyleForRowAtIndexPath(tableView: UITableView, editingStyle: interop.Enum<typeof UITableViewCellEditingStyle>, indexPath: NSIndexPath): void;

  tableViewMoveRowAtIndexPathToIndexPath(tableView: UITableView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIPasteboard extends NSObject {
  static readonly generalPasteboard: UIPasteboard;

  static pasteboardWithNameCreate(pasteboardName: string, create: boolean): UIPasteboard;

  static pasteboardWithUniqueName(): UIPasteboard;

  readonly name: string;

  static removePasteboardWithName(pasteboardName: string): void;

  readonly isPersistent: boolean;

  readonly changeCount: number;

  get itemProviders(): NSArray;
  set itemProviders(value: NSArray<interop.Object> | Array<interop.Object>);

  setItemProvidersLocalOnlyExpirationDate(itemProviders: NSArray<interop.Object> | Array<interop.Object>, localOnly: boolean, expirationDate: NSDate | null): void;

  setObjects(objects: NSArray<interop.Object> | Array<interop.Object>): void;

  setObjectsLocalOnlyExpirationDate(objects: NSArray<interop.Object> | Array<interop.Object>, localOnly: boolean, expirationDate: NSDate | null): void;

  readonly pasteboardTypes: NSArray;

  containsPasteboardTypes(pasteboardTypes: NSArray<interop.Object> | Array<interop.Object>): boolean;

  dataForPasteboardType(pasteboardType: string): NSData;

  valueForPasteboardType(pasteboardType: string): interop.Object;

  setValueForPasteboardType(value: interop.Object, pasteboardType: string): void;

  setDataForPasteboardType(data: NSData, pasteboardType: string): void;

  readonly numberOfItems: number;

  pasteboardTypesForItemSet(itemSet: NSIndexSet | null): NSArray;

  containsPasteboardTypesInItemSet(pasteboardTypes: NSArray<interop.Object> | Array<interop.Object>, itemSet: NSIndexSet | null): boolean;

  itemSetWithPasteboardTypes(pasteboardTypes: NSArray<interop.Object> | Array<interop.Object>): NSIndexSet;

  valuesForPasteboardTypeInItemSet(pasteboardType: string, itemSet: NSIndexSet | null): NSArray;

  dataForPasteboardTypeInItemSet(pasteboardType: string, itemSet: NSIndexSet | null): NSArray;

  get items(): NSArray;
  set items(value: NSArray<interop.Object> | Array<interop.Object>);

  addItems(items: NSArray<interop.Object> | Array<interop.Object>): void;

  setItemsOptions(items: NSArray<interop.Object> | Array<interop.Object>, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  string: string;

  get strings(): NSArray;
  set strings(value: NSArray<interop.Object> | Array<interop.Object>);

  URL: NSURL;

  get URLs(): NSArray;
  set URLs(value: NSArray<interop.Object> | Array<interop.Object>);

  image: UIImage;

  get images(): NSArray;
  set images(value: NSArray<interop.Object> | Array<interop.Object>);

  color: UIColor;

  get colors(): NSArray;
  set colors(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly hasStrings: boolean;

  readonly hasURLs: boolean;

  readonly hasImages: boolean;

  readonly hasColors: boolean;

  detectPatternsForPatternsCompletionHandler(patterns: NSSet, completionHandler: (p1: NSSet, p2: NSError) => void | null): void;

  detectPatternsForPatternsInItemSetCompletionHandler(patterns: NSSet, itemSet: NSIndexSet | null, completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>, p2: NSError) => void | null): void;

  detectValuesForPatternsCompletionHandler(patterns: NSSet, completionHandler: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p2: NSError) => void | null): void;

  detectValuesForPatternsInItemSetCompletionHandler(patterns: NSSet, itemSet: NSIndexSet | null, completionHandler: (p1: NSArray<interop.Object> | Array<interop.Object>, p2: NSError) => void | null): void;
}

declare class UIActivityItemProvider extends NSOperation implements UIActivityItemSource {
  initWithPlaceholderItem(placeholderItem: interop.Object): this;

  readonly placeholderItem: interop.Object;

  readonly activityType: string;

  readonly item: interop.Object;

  activityViewControllerPlaceholderItem(activityViewController: UIActivityViewController): interop.Object;

  activityViewControllerItemForActivityType(activityViewController: UIActivityViewController, activityType: string | null): interop.Object;

  activityViewControllerSubjectForActivityType(activityViewController: UIActivityViewController, activityType: string | null): string;

  activityViewControllerDataTypeIdentifierForActivityType(activityViewController: UIActivityViewController, activityType: string | null): string;

  activityViewControllerThumbnailImageForActivityTypeSuggestedSize(activityViewController: UIActivityViewController, activityType: string | null, size: CGSize): UIImage;

  activityViewControllerLinkMetadata(activityViewController: UIActivityViewController): interop.Object;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIDragInteraction extends NSObject implements UIInteraction {
  initWithDelegate(delegate: UIDragInteractionDelegate): this;

  readonly delegate: UIDragInteractionDelegate;

  allowsSimultaneousRecognitionDuringLift: boolean;

  isEnabled: boolean;

  static readonly isEnabledByDefault: boolean;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSCollectionLayoutEdgeSpacing extends NSObject implements NSCopying {
  static spacingForLeadingTopTrailingBottom<This extends abstract new (...args: any) => any>(this: This, leading: NSCollectionLayoutSpacing | null, top: NSCollectionLayoutSpacing | null, trailing: NSCollectionLayoutSpacing | null, bottom: NSCollectionLayoutSpacing | null): InstanceType<This>;

  readonly leading: NSCollectionLayoutSpacing;

  readonly top: NSCollectionLayoutSpacing;

  readonly trailing: NSCollectionLayoutSpacing;

  readonly bottom: NSCollectionLayoutSpacing;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIDynamicItemGroup extends NSObject implements UIDynamicItem {
  initWithItems(items: NSArray<interop.Object> | Array<interop.Object>): this;

  readonly items: NSArray;

  center: CGPoint;

  readonly bounds: CGRect;

  transform: CGAffineTransform;

  readonly collisionBoundsType: interop.Enum<typeof UIDynamicItemCollisionBoundsType>;

  readonly collisionBoundingPath: UIBezierPath;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIWindowSceneGeometryPreferencesMac extends UIWindowSceneGeometryPreferences {
  init(): this;

  initWithSystemFrame(systemFrame: CGRect): this;

  systemFrame: CGRect;
}

declare class UIPageControlProgress extends NSObject {
  delegate: UIPageControlProgressDelegate;

  currentProgress: number;

  readonly isProgressVisible: boolean;
}

declare class UITargetedPreview extends NSObject implements NSCopying {
  initWithViewParametersTarget(view: UIView, parameters: UIPreviewParameters, target: UIPreviewTarget): this;

  initWithViewParameters(view: UIView, parameters: UIPreviewParameters): this;

  initWithView(view: UIView): this;

  readonly target: UIPreviewTarget;

  readonly view: UIView;

  readonly parameters: UIPreviewParameters;

  readonly size: CGSize;

  retargetedPreviewWithTarget(newTarget: UIPreviewTarget): UITargetedPreview;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITextCursorDropPositionAnimator extends NSObject {
  readonly cursorView: UIView;

  readonly textInput: UIView;

  initWithTextCursorViewTextInput(cursorView: UIView, textInput: UIView): this;

  setCursorVisibleAnimated(visible: boolean, animated: boolean): void;

  placeCursorAtPositionAnimated(position: UITextPosition, animated: boolean): void;

  animateAlongsideChangesCompletion(animation: () => void | null, completion: () => void | null): void;
}

declare class UIPreviewInteraction extends NSObject {
  initWithView(view: UIView): this;

  readonly view: UIView | null;

  delegate: UIPreviewInteractionDelegate;

  locationInCoordinateSpace(coordinateSpace: UICoordinateSpace | null): CGPoint;

  cancelInteraction(): void;
}

declare class UISwipeGestureRecognizer extends UIGestureRecognizer {
  numberOfTouchesRequired: number;

  direction: interop.Enum<typeof UISwipeGestureRecognizerDirection>;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIWindowSceneActivationAction extends UIAction {
  // @ts-ignore MemberDecl.tsIgnore
  title: string;

  static actionWithIdentifierAlternateActionConfigurationProvider<This extends abstract new (...args: any) => any>(this: This, identifier: string | null, alternateAction: UIAction | null, configurationProvider: (p1: UIWindowSceneActivationAction) => UIWindowSceneActivationConfiguration): InstanceType<This>;
}

declare class NSCollectionLayoutDecorationItem extends NSCollectionLayoutItem implements NSCopying {
  static backgroundDecorationItemWithElementKind<This extends abstract new (...args: any) => any>(this: This, elementKind: string): InstanceType<This>;

  zIndex: number;

  readonly elementKind: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPrintPaper extends NSObject {
  static bestPaperForPageSizeWithPapersFromArray(contentSize: CGSize, paperList: NSArray<interop.Object> | Array<interop.Object>): UIPrintPaper;

  readonly paperSize: CGSize;

  readonly printableRect: CGRect;

  printRect(): CGRect;
}

declare class UIPrintPageRenderer extends NSObject {
  headerHeight: number;

  footerHeight: number;

  readonly paperRect: CGRect;

  readonly printableRect: CGRect;

  readonly numberOfPages: number;

  get printFormatters(): NSArray;
  set printFormatters(value: NSArray<interop.Object> | Array<interop.Object>);

  printFormattersForPageAtIndex(pageIndex: number): NSArray;

  addPrintFormatterStartingAtPageAtIndex(formatter: UIPrintFormatter, pageIndex: number): void;

  currentRenderingQualityForRequestedRenderingQuality(requestedRenderingQuality: interop.Enum<typeof UIPrintRenderingQuality>): interop.Enum<typeof UIPrintRenderingQuality>;

  prepareForDrawingPages(range: _NSRange): void;

  drawPageAtIndexInRect(pageIndex: number, printableRect: CGRect): void;

  drawPrintFormatterForPageAtIndex(printFormatter: UIPrintFormatter, pageIndex: number): void;

  drawHeaderForPageAtIndexInRect(pageIndex: number, headerRect: CGRect): void;

  drawContentForPageAtIndexInRect(pageIndex: number, contentRect: CGRect): void;

  drawFooterForPageAtIndexInRect(pageIndex: number, footerRect: CGRect): void;
}

declare class UIPrintInfo extends NSObject implements NSCopying, NSCoding {
  initWithCoder(coder: NSCoder): this;

  static printInfo(): UIPrintInfo;

  static printInfoWithDictionary(dictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): UIPrintInfo;

  printerID: string;

  jobName: string;

  outputType: interop.Enum<typeof UIPrintInfoOutputType>;

  orientation: interop.Enum<typeof UIPrintInfoOrientation>;

  duplex: interop.Enum<typeof UIPrintInfoDuplex>;

  readonly dictionaryRepresentation: NSDictionary;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UITextInputContext extends NSObject {
  isPencilInputExpected: boolean;

  isDictationInputExpected: boolean;

  isHardwareKeyboardInputExpected: boolean;

  static current(): UITextInputContext;
}

declare class UIPrinterPickerController extends NSObject {
  static printerPickerControllerWithInitiallySelectedPrinter(printer: UIPrinter | null): UIPrinterPickerController;

  readonly selectedPrinter: UIPrinter;

  delegate: UIPrinterPickerControllerDelegate;

  presentAnimatedCompletionHandler(animated: boolean, completion: (p1: UIPrinterPickerController, p2: boolean, p3: NSError) => void | null): boolean;

  presentFromRectInViewAnimatedCompletionHandler(rect: CGRect, view: UIView, animated: boolean, completion: (p1: UIPrinterPickerController, p2: boolean, p3: NSError) => void | null): boolean;

  presentFromBarButtonItemAnimatedCompletionHandler(item: UIBarButtonItem, animated: boolean, completion: (p1: UIPrinterPickerController, p2: boolean, p3: NSError) => void | null): boolean;

  dismissAnimated(animated: boolean): void;
}

declare class UIPrintFormatter extends NSObject implements NSCopying {
  readonly printPageRenderer: UIPrintPageRenderer;

  removeFromPrintPageRenderer(): void;

  maximumContentHeight: number;

  maximumContentWidth: number;

  contentInsets: UIEdgeInsets;

  perPageContentInsets: UIEdgeInsets;

  startPage: number;

  readonly pageCount: number;

  readonly requiresMainThread: boolean;

  rectForPageAtIndex(pageIndex: number): CGRect;

  drawInRectForPageAtIndex(rect: CGRect, pageIndex: number): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIMenuItem extends NSObject {
  initWithTitleAction(title: string, action: string): this;

  title: string;

  action: string;
}

declare class UITraitDisplayGamut extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIDocumentInteractionController extends NSObject implements UIActionSheetDelegate {
  static interactionControllerWithURL(url: NSURL): UIDocumentInteractionController;

  delegate: UIDocumentInteractionControllerDelegate;

  URL: NSURL;

  UTI: string;

  name: string;

  readonly icons: NSArray;

  annotation: interop.Object;

  presentOptionsMenuFromRectInViewAnimated(rect: CGRect, view: UIView, animated: boolean): boolean;

  presentOptionsMenuFromBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): boolean;

  presentPreviewAnimated(animated: boolean): boolean;

  presentOpenInMenuFromRectInViewAnimated(rect: CGRect, view: UIView, animated: boolean): boolean;

  presentOpenInMenuFromBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): boolean;

  dismissPreviewAnimated(animated: boolean): void;

  dismissMenuAnimated(animated: boolean): void;

  readonly gestureRecognizers: NSArray;

  actionSheetClickedButtonAtIndex(actionSheet: UIActionSheet, buttonIndex: number): void;

  actionSheetCancel(actionSheet: UIActionSheet): void;

  willPresentActionSheet(actionSheet: UIActionSheet): void;

  didPresentActionSheet(actionSheet: UIActionSheet): void;

  actionSheetWillDismissWithButtonIndex(actionSheet: UIActionSheet, buttonIndex: number): void;

  actionSheetDidDismissWithButtonIndex(actionSheet: UIActionSheet, buttonIndex: number): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSTextListElement extends NSTextParagraph {
  initWithParentElementTextListContentsMarkerAttributesChildElements(parent: NSTextListElement | null, textList: NSTextList, contents: NSAttributedString | null, markerAttributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, children: NSArray<interop.Object> | Array<interop.Object> | null): this;

  static textListElementWithContentsMarkerAttributesTextListChildElements<This extends abstract new (...args: any) => any>(this: This, contents: NSAttributedString, markerAttributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, textList: NSTextList, children: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  static textListElementWithChildElementsTextListNestingLevel<This extends abstract new (...args: any) => any>(this: This, children: NSArray<interop.Object> | Array<interop.Object>, textList: NSTextList, nestingLevel: number): InstanceType<This>;

  readonly textList: NSTextList;

  readonly contents: NSAttributedString;

  readonly markerAttributes: NSDictionary;

  readonly attributedString: NSAttributedString;

  readonly childElements: NSArray;

  // @ts-ignore MemberDecl.tsIgnore
  readonly parentElement: NSTextListElement;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSTextContentStorage extends NSTextContentManager implements NSTextStorageObserving {
  // @ts-ignore MemberDecl.tsIgnore
  delegate: NSTextContentStorageDelegate;

  attributedString: NSAttributedString;

  attributedStringForTextElement(textElement: NSTextElement): NSAttributedString;

  textElementForAttributedString(attributedString: NSAttributedString): NSTextElement;

  locationFromLocationWithOffset(location: NSTextLocation, offset: number): NSTextLocation;

  offsetFromLocationToLocation(from: NSTextLocation, to: NSTextLocation): number;

  adjustedRangeFromRangeForEditingTextSelection(textRange: NSTextRange, forEditingTextSelection: boolean): NSTextRange;

  textStorage: NSTextStorage;

  processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(textStorage: NSTextStorage, editMask: interop.Enum<typeof NSTextStorageEditActions>, newCharRange: _NSRange, delta: number, invalidatedCharRange: _NSRange): void;

  performEditingTransactionForTextStorageUsingBlock(textStorage: NSTextStorage, transaction: () => void): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIContentUnavailableConfiguration extends NSObject implements UIContentConfiguration, NSSecureCoding {
  static emptyConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static loadingConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static searchConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  image: UIImage;

  readonly imageProperties: UIContentUnavailableImageProperties;

  text: string;

  attributedText: NSAttributedString;

  readonly textProperties: UIContentUnavailableTextProperties;

  secondaryText: string;

  secondaryAttributedText: NSAttributedString;

  readonly secondaryTextProperties: UIContentUnavailableTextProperties;

  button: UIButtonConfiguration;

  readonly buttonProperties: UIContentUnavailableButtonProperties;

  secondaryButton: UIButtonConfiguration;

  readonly secondaryButtonProperties: UIContentUnavailableButtonProperties;

  alignment: interop.Enum<typeof UIContentUnavailableAlignment>;

  axesPreservingSuperviewLayoutMargins: interop.Enum<typeof UIAxis>;

  directionalLayoutMargins: NSDirectionalEdgeInsets;

  imageToTextPadding: number;

  textToSecondaryTextPadding: number;

  textToButtonPadding: number;

  buttonToSecondaryButtonPadding: number;

  background: UIBackgroundConfiguration;

  makeContentView(): UIView;

  updatedConfigurationForState(state: UIConfigurationState): this;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSCollectionLayoutGroupCustomItem extends NSObject implements NSCopying {
  static customItemWithFrame<This extends abstract new (...args: any) => any>(this: This, frame: CGRect): InstanceType<This>;

  static customItemWithFrameZIndex<This extends abstract new (...args: any) => any>(this: This, frame: CGRect, zIndex: number): InstanceType<This>;

  readonly frame: CGRect;

  readonly zIndex: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIContentUnavailableButtonProperties extends NSObject implements NSCopying, NSSecureCoding {
  primaryAction: UIAction;

  menu: UIMenu;

  isEnabled: boolean;

  role: interop.Enum<typeof UIButtonRole>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIActivityViewController extends UIViewController {
  initWithActivityItemsApplicationActivities(activityItems: NSArray<interop.Object> | Array<interop.Object>, applicationActivities: NSArray<interop.Object> | Array<interop.Object> | null): this;

  completionHandler: (p1: string, p2: boolean) => void;

  completionWithItemsHandler: (p1: string, p2: boolean, p3: NSArray<interop.Object> | Array<interop.Object>, p4: NSError) => void;

  get excludedActivityTypes(): NSArray;
  set excludedActivityTypes(value: NSArray<interop.Object> | Array<interop.Object>);

  allowsProminentActivity: boolean;

  initWithActivityItemsConfiguration(activityItemsConfiguration: UIActivityItemsConfigurationReading): this;
}

declare class UIContentUnavailableTextProperties extends NSObject implements NSCopying, NSSecureCoding {
  font: UIFont;

  color: UIColor;

  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  numberOfLines: number;

  adjustsFontSizeToFitWidth: boolean;

  minimumScaleFactor: number;

  allowsDefaultTighteningForTruncation: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSShadow extends NSObject implements NSCopying, NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  shadowOffset: CGSize;

  shadowBlurRadius: number;

  shadowColor: interop.Object;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIBarButtonItemGroup extends NSObject implements NSCoding {
  initWithBarButtonItemsRepresentativeItem(barButtonItems: NSArray<interop.Object> | Array<interop.Object>, representativeItem: UIBarButtonItem | null): this;

  initWithCoder(coder: NSCoder): this;

  static fixedGroupWithRepresentativeItemItems(representativeItem: UIBarButtonItem | null, items: NSArray<interop.Object> | Array<interop.Object>): UIBarButtonItemGroup;

  static movableGroupWithCustomizationIdentifierRepresentativeItemItems(customizationIdentifier: string, representativeItem: UIBarButtonItem | null, items: NSArray<interop.Object> | Array<interop.Object>): UIBarButtonItemGroup;

  static optionalGroupWithCustomizationIdentifierInDefaultCustomizationRepresentativeItemItems(customizationIdentifier: string, inDefaultCustomization: boolean, representativeItem: UIBarButtonItem | null, items: NSArray<interop.Object> | Array<interop.Object>): UIBarButtonItemGroup;

  get barButtonItems(): NSArray;
  set barButtonItems(value: NSArray<interop.Object> | Array<interop.Object>);

  representativeItem: UIBarButtonItem;

  readonly isDisplayingRepresentativeItem: boolean;

  alwaysAvailable: boolean;

  menuRepresentation: UIMenuElement;

  isHidden: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UICalendarSelectionMultiDate extends UICalendarSelection {
  get selectedDates(): NSArray;
  set selectedDates(value: NSArray<interop.Object> | Array<interop.Object>);

  setSelectedDatesAnimated(selectedDates: NSArray<interop.Object> | Array<interop.Object>, animated: boolean): void;

  readonly delegate: UICalendarSelectionMultiDateDelegate;

  initWithDelegate(delegate: UICalendarSelectionMultiDateDelegate | null): this;
}

declare class UIPointerRegionRequest extends NSObject {
  readonly location: CGPoint;

  readonly modifiers: interop.Enum<typeof UIKeyModifierFlags>;
}

declare class UIFocusHaloEffect extends UIFocusEffect {
  static effectWithRect<This extends abstract new (...args: any) => any>(this: This, rect: CGRect): InstanceType<This>;

  static effectWithRoundedRectCornerRadiusCurve<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, cornerRadius: number, curve: string): InstanceType<This>;

  static effectWithPath<This extends abstract new (...args: any) => any>(this: This, bezierPath: UIBezierPath): InstanceType<This>;

  containerView: UIView;

  referenceView: UIView;

  position: interop.Enum<typeof UIFocusHaloEffectPosition>;
}

declare class UICollectionViewUpdateItem extends NSObject {
  readonly indexPathBeforeUpdate: NSIndexPath;

  readonly indexPathAfterUpdate: NSIndexPath;

  readonly updateAction: interop.Enum<typeof UICollectionUpdateAction>;
}

declare class UIWindowSceneDragInteraction extends NSObject implements UIInteraction {
  readonly gestureForFailureRelationships: UIGestureRecognizer;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIStatusBarManager extends NSObject {
  readonly statusBarStyle: interop.Enum<typeof UIStatusBarStyle>;

  readonly isStatusBarHidden: boolean;

  readonly statusBarFrame: CGRect;
}

declare class NSTextLayoutFragment extends NSObject implements NSSecureCoding {
  initWithTextElementRange(textElement: NSTextElement, rangeInElement: NSTextRange | null): this;

  initWithCoder(coder: NSCoder): this;

  readonly textLayoutManager: NSTextLayoutManager;

  readonly textElement: NSTextElement | null;

  readonly rangeInElement: NSTextRange;

  readonly textLineFragments: NSArray;

  textLineFragmentForVerticalOffsetRequiresExactMatch(verticalOffset: number, requiresExactMatch: boolean): NSTextLineFragment;

  textLineFragmentForTextLocationIsUpstreamAffinity(textLocation: NSTextLocation, isUpstreamAffinity: boolean): NSTextLineFragment;

  layoutQueue: NSOperationQueue;

  readonly state: interop.Enum<typeof NSTextLayoutFragmentState>;

  invalidateLayout(): void;

  readonly layoutFragmentFrame: CGRect;

  readonly renderingSurfaceBounds: CGRect;

  readonly leadingPadding: number;

  readonly trailingPadding: number;

  readonly topMargin: number;

  readonly bottomMargin: number;

  drawAtPointInContext(point: CGPoint, context: interop.PointerConvertible): void;

  readonly textAttachmentViewProviders: NSArray;

  frameForTextAttachmentAtLocation(location: NSTextLocation): CGRect;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIAlertController extends UIViewController {
  static alertControllerWithTitleMessagePreferredStyle<This extends abstract new (...args: any) => any>(this: This, title: string | null, message: string | null, preferredStyle: interop.Enum<typeof UIAlertControllerStyle>): InstanceType<This>;

  addAction(action: UIAlertAction): void;

  readonly actions: NSArray;

  preferredAction: UIAlertAction;

  addTextFieldWithConfigurationHandler(configurationHandler: (p1: UITextField) => void | null): void;

  readonly textFields: NSArray;

  title: string;

  message: string;

  readonly preferredStyle: interop.Enum<typeof UIAlertControllerStyle>;

  severity: interop.Enum<typeof UIAlertControllerSeverity>;
}

declare class UIWindowSceneActivationConfiguration extends NSObject {
  readonly userActivity: NSUserActivity;

  options: UIWindowSceneActivationRequestOptions;

  preview: UITargetedPreview;

  initWithUserActivity(userActivity: NSUserActivity): this;
}

declare class UICollectionViewLayoutInvalidationContext extends NSObject {
  readonly invalidateEverything: boolean;

  readonly invalidateDataSourceCounts: boolean;

  invalidateItemsAtIndexPaths(indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  invalidateSupplementaryElementsOfKindAtIndexPaths(elementKind: string, indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  invalidateDecorationElementsOfKindAtIndexPaths(elementKind: string, indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  readonly invalidatedItemIndexPaths: NSArray;

  readonly invalidatedSupplementaryIndexPaths: NSDictionary;

  readonly invalidatedDecorationIndexPaths: NSDictionary;

  contentOffsetAdjustment: CGPoint;

  contentSizeAdjustment: CGSize;

  readonly previousIndexPathsForInteractivelyMovingItems: NSArray;

  readonly targetIndexPathsForInteractivelyMovingItems: NSArray;

  readonly interactiveMovementTarget: CGPoint;
}

declare class UIEventAttributionView extends UIView {
}

declare class UIEventAttribution extends NSObject implements NSCopying {
  readonly sourceIdentifier: number;

  readonly destinationURL: NSURL;

  readonly reportEndpoint: NSURL;

  readonly sourceDescription: string;

  readonly purchaser: string;

  initWithSourceIdentifierDestinationURLSourceDescriptionPurchaser(sourceIdentifier: number, destinationURL: NSURL, sourceDescription: string, purchaser: string): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITableViewCell extends UIView implements NSCoding, UIGestureRecognizerDelegate {
  initWithStyleReuseIdentifier(style: interop.Enum<typeof UITableViewCellStyle>, reuseIdentifier: string | null): this;

  initWithCoder(coder: NSCoder): this;

  readonly configurationState: UICellConfigurationState;

  setNeedsUpdateConfiguration(): void;

  updateConfigurationUsingState(state: UICellConfigurationState): void;

  configurationUpdateHandler: (p1: UITableViewCell, p2: UICellConfigurationState) => void;

  defaultContentConfiguration(): UIListContentConfiguration;

  contentConfiguration: UIContentConfiguration;

  automaticallyUpdatesContentConfiguration: boolean;

  readonly contentView: UIView;

  readonly imageView: UIImageView;

  readonly textLabel: UILabel;

  readonly detailTextLabel: UILabel;

  defaultBackgroundConfiguration(): UIBackgroundConfiguration;

  backgroundConfiguration: UIBackgroundConfiguration;

  automaticallyUpdatesBackgroundConfiguration: boolean;

  backgroundView: UIView;

  selectedBackgroundView: UIView;

  multipleSelectionBackgroundView: UIView;

  readonly reuseIdentifier: string;

  prepareForReuse(): void;

  selectionStyle: interop.Enum<typeof UITableViewCellSelectionStyle>;

  isSelected: boolean;

  isHighlighted: boolean;

  setSelectedAnimated(selected: boolean, animated: boolean): void;

  setHighlightedAnimated(highlighted: boolean, animated: boolean): void;

  readonly editingStyle: interop.Enum<typeof UITableViewCellEditingStyle>;

  showsReorderControl: boolean;

  shouldIndentWhileEditing: boolean;

  accessoryType: interop.Enum<typeof UITableViewCellAccessoryType>;

  accessoryView: UIView;

  editingAccessoryType: interop.Enum<typeof UITableViewCellAccessoryType>;

  editingAccessoryView: UIView;

  indentationLevel: number;

  indentationWidth: number;

  separatorInset: UIEdgeInsets;

  isEditing: boolean;

  setEditingAnimated(editing: boolean, animated: boolean): void;

  readonly showingDeleteConfirmation: boolean;

  focusStyle: interop.Enum<typeof UITableViewCellFocusStyle>;

  willTransitionToState(state: interop.Enum<typeof UITableViewCellStateMask>): void;

  didTransitionToState(state: interop.Enum<typeof UITableViewCellStateMask>): void;

  dragStateDidChange(dragState: interop.Enum<typeof UITableViewCellDragState>): void;

  userInteractionEnabledWhileDragging: boolean;

  initWithFrameReuseIdentifier(frame: CGRect, reuseIdentifier: string | null): this;

  text: string;

  font: UIFont;

  textAlignment: interop.Enum<typeof NSTextAlignment>;

  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  textColor: UIColor;

  selectedTextColor: UIColor;

  image: UIImage;

  selectedImage: UIImage;

  hidesAccessoryWhenEditing: boolean;

  target: interop.Object;

  editAction: string;

  accessoryAction: string;

  encodeWithCoder(coder: NSCoder): void;

  gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldRecognizeSimultaneouslyWithGestureRecognizer(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldRequireFailureOfGestureRecognizer(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldBeRequiredToFailByGestureRecognizer(gestureRecognizer: UIGestureRecognizer, otherGestureRecognizer: UIGestureRecognizer): boolean;

  gestureRecognizerShouldReceiveTouch(gestureRecognizer: UIGestureRecognizer, touch: UITouch): boolean;

  gestureRecognizerShouldReceivePress(gestureRecognizer: UIGestureRecognizer, press: UIPress): boolean;

  gestureRecognizerShouldReceiveEvent(gestureRecognizer: UIGestureRecognizer, event: UIEvent): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIPointerAccessory extends NSObject implements NSCopying {
  readonly shape: UIPointerShape;

  readonly position: UIPointerAccessoryPosition;

  orientationMatchesAngle: boolean;

  static accessoryWithShapePosition<This extends abstract new (...args: any) => any>(this: This, shape: UIPointerShape, position: UIPointerAccessoryPosition): InstanceType<This>;

  static arrowAccessoryWithPosition<This extends abstract new (...args: any) => any>(this: This, position: UIPointerAccessoryPosition): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UISwipeActionsConfiguration extends NSObject {
  static configurationWithActions<This extends abstract new (...args: any) => any>(this: This, actions: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  readonly actions: NSArray;

  performsFirstActionWithFullSwipe: boolean;
}

declare class UIPointerInteraction extends NSObject implements UIInteraction {
  readonly delegate: UIPointerInteractionDelegate;

  isEnabled: boolean;

  initWithDelegate(delegate: UIPointerInteractionDelegate | null): this;

  invalidate(): void;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UISearchController extends UIViewController implements UIViewControllerTransitioningDelegate, UIViewControllerAnimatedTransitioning {
  initWithSearchResultsController(searchResultsController: UIViewController | null): this;

  initWithNibNameBundle(nibNameOrNil: string | null, nibBundleOrNil: NSBundle | null): this;

  initWithCoder(coder: NSCoder): this;

  searchResultsUpdater: UISearchResultsUpdating;

  isActive: boolean;

  delegate: UISearchControllerDelegate;

  dimsBackgroundDuringPresentation: boolean;

  obscuresBackgroundDuringPresentation: boolean;

  hidesNavigationBarDuringPresentation: boolean;

  readonly searchResultsController: UIViewController;

  readonly searchBar: UISearchBar;

  readonly searchBarPlacement: interop.Enum<typeof UINavigationItemSearchBarPlacement>;

  automaticallyShowsSearchResultsController: boolean;

  showsSearchResultsController: boolean;

  automaticallyShowsCancelButton: boolean;

  automaticallyShowsScopeBar: boolean;

  scopeBarActivation: interop.Enum<typeof UISearchControllerScopeBarActivation>;

  get searchSuggestions(): NSArray;
  set searchSuggestions(value: NSArray<interop.Object> | Array<interop.Object>);

  ignoresSearchSuggestionsForSearchBarPlacementStacked: boolean;

  animationControllerForPresentedControllerPresentingControllerSourceController(presented: UIViewController, presenting: UIViewController, source: UIViewController): UIViewControllerAnimatedTransitioning;

  animationControllerForDismissedController(dismissed: UIViewController): UIViewControllerAnimatedTransitioning;

  interactionControllerForPresentation(animator: UIViewControllerAnimatedTransitioning): UIViewControllerInteractiveTransitioning;

  interactionControllerForDismissal(animator: UIViewControllerAnimatedTransitioning): UIViewControllerInteractiveTransitioning;

  presentationControllerForPresentedViewControllerPresentingViewControllerSourceViewController(presented: UIViewController, presenting: UIViewController | null, source: UIViewController): UIPresentationController;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  transitionDuration(transitionContext: UIViewControllerContextTransitioning | null): number;

  animateTransition(transitionContext: UIViewControllerContextTransitioning): void;

  interruptibleAnimatorForTransition(transitionContext: UIViewControllerContextTransitioning): UIViewImplicitlyAnimating;

  animationEnded(transitionCompleted: boolean): void;
}

declare class UIEditMenuInteraction extends NSObject implements UIInteraction {
  readonly delegate: UIEditMenuInteractionDelegate;

  initWithDelegate(delegate: UIEditMenuInteractionDelegate | null): this;

  presentEditMenuWithConfiguration(configuration: UIEditMenuConfiguration): void;

  dismissMenu(): void;

  reloadVisibleMenu(): void;

  updateVisibleMenuPositionAnimated(animated: boolean): void;

  locationInView(view: UIView | null): CGPoint;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIPointerHoverEffect extends UIPointerEffect {
  preferredTintMode: interop.Enum<typeof UIPointerEffectTintMode>;

  prefersShadow: boolean;

  prefersScaledContent: boolean;
}

declare class UIMenuSystem extends NSObject {
  static readonly mainSystem: UIMenuSystem;

  static readonly contextSystem: UIMenuSystem;

  setNeedsRebuild(): void;

  setNeedsRevalidate(): void;
}

declare class UISearchContainerViewController extends UIViewController {
  readonly searchController: UISearchController;

  initWithSearchController(searchController: UISearchController): this;
}

declare class NSDataAsset extends NSObject implements NSCopying {
  initWithName(name: string): this;

  initWithNameBundle(name: string, bundle: NSBundle): this;

  readonly name: string;

  readonly data: NSData;

  readonly typeIdentifier: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIAccessibilityCustomRotor extends NSObject {
  initWithNameItemSearchBlock(name: string, itemSearchBlock: (p1: UIAccessibilityCustomRotorSearchPredicate) => UIAccessibilityCustomRotorItemResult): this;

  initWithAttributedNameItemSearchBlock(attributedName: NSAttributedString, itemSearchBlock: (p1: UIAccessibilityCustomRotorSearchPredicate) => UIAccessibilityCustomRotorItemResult): this;

  initWithSystemTypeItemSearchBlock(type: interop.Enum<typeof UIAccessibilityCustomSystemRotorType>, itemSearchBlock: (p1: UIAccessibilityCustomRotorSearchPredicate) => UIAccessibilityCustomRotorItemResult): this;

  name: string;

  attributedName: NSAttributedString;

  itemSearchBlock: (p1: UIAccessibilityCustomRotorSearchPredicate) => UIAccessibilityCustomRotorItemResult;

  readonly systemRotorType: interop.Enum<typeof UIAccessibilityCustomSystemRotorType>;
}

declare class UIContentUnavailableConfigurationState extends NSObject implements UIConfigurationState {
  initWithTraitCollection(traitCollection: UITraitCollection): this;

  initWithCoder(coder: NSCoder): this;

  traitCollection: UITraitCollection;

  searchText: string;

  customStateForKey(key: string): interop.Object;

  setCustomStateForKey(customState: interop.Object | null, key: string): void;

  objectForKeyedSubscript(key: string): interop.Object;

  setObjectForKeyedSubscript(obj: interop.Object | null, key: string): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIPointerHighlightEffect extends UIPointerEffect {
}

declare class NSLayoutDimension extends NSLayoutAnchor {
  constraintEqualToConstant(c: number): NSLayoutConstraint;

  constraintGreaterThanOrEqualToConstant(c: number): NSLayoutConstraint;

  constraintLessThanOrEqualToConstant(c: number): NSLayoutConstraint;

  constraintEqualToAnchorMultiplier(anchor: NSLayoutDimension, m: number): NSLayoutConstraint;

  constraintGreaterThanOrEqualToAnchorMultiplier(anchor: NSLayoutDimension, m: number): NSLayoutConstraint;

  constraintLessThanOrEqualToAnchorMultiplier(anchor: NSLayoutDimension, m: number): NSLayoutConstraint;

  constraintEqualToAnchorMultiplierConstant(anchor: NSLayoutDimension, m: number, c: number): NSLayoutConstraint;

  constraintGreaterThanOrEqualToAnchorMultiplierConstant(anchor: NSLayoutDimension, m: number, c: number): NSLayoutConstraint;

  constraintLessThanOrEqualToAnchorMultiplierConstant(anchor: NSLayoutDimension, m: number, c: number): NSLayoutConstraint;
}

declare class UISceneSession extends NSObject implements NSSecureCoding {
  readonly scene: UIScene;

  readonly role: string;

  readonly configuration: UISceneConfiguration;

  readonly persistentIdentifier: string;

  stateRestorationActivity: NSUserActivity;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UISceneConfiguration extends NSObject implements NSCopying, NSSecureCoding {
  static configurationWithNameSessionRole<This extends abstract new (...args: any) => any>(this: This, name: string | null, sessionRole: string): InstanceType<This>;

  initWithNameSessionRole(name: string | null, sessionRole: string): this;

  readonly name: string;

  readonly role: string;

  sceneClass: interop.Object;

  delegateClass: interop.Object;

  storyboard: UIStoryboard;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UISceneWindowingBehaviors extends NSObject {
  isClosable: boolean;

  isMiniaturizable: boolean;
}

declare class UIPencilInteractionTap extends NSObject {
  readonly timestamp: number;

  readonly hoverPose: UIPencilHoverPose;
}

declare class NSLayoutConstraint extends NSObject {
  static constraintsWithVisualFormatOptionsMetricsViews(format: string, opts: interop.Enum<typeof NSLayoutFormatOptions>, metrics: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, views: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSArray;

  static constraintWithItemAttributeRelatedByToItemAttributeMultiplierConstant<This extends abstract new (...args: any) => any>(this: This, view1: interop.Object, attr1: interop.Enum<typeof NSLayoutAttribute>, relation: interop.Enum<typeof NSLayoutRelation>, view2: interop.Object | null, attr2: interop.Enum<typeof NSLayoutAttribute>, multiplier: number, c: number): InstanceType<This>;

  priority: number;

  shouldBeArchived: boolean;

  readonly firstItem: interop.Object;

  readonly secondItem: interop.Object;

  readonly firstAttribute: interop.Enum<typeof NSLayoutAttribute>;

  readonly secondAttribute: interop.Enum<typeof NSLayoutAttribute>;

  readonly firstAnchor: NSLayoutAnchor;

  readonly secondAnchor: NSLayoutAnchor;

  readonly relation: interop.Enum<typeof NSLayoutRelation>;

  readonly multiplier: number;

  constant: number;

  isActive: boolean;

  static activateConstraints(constraints: NSArray<interop.Object> | Array<interop.Object>): void;

  static deactivateConstraints(constraints: NSArray<interop.Object> | Array<interop.Object>): void;

  identifier: string;
}

declare class UIContextMenuInteraction extends NSObject implements UIInteraction {
  readonly delegate: UIContextMenuInteractionDelegate | null;

  readonly menuAppearance: interop.Enum<typeof UIContextMenuInteractionAppearance>;

  initWithDelegate(delegate: UIContextMenuInteractionDelegate): this;

  locationInView(view: UIView | null): CGPoint;

  updateVisibleMenuWithBlock(block: (p1: UIMenu) => UIMenu): void;

  dismissMenu(): void;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITextItemMenuConfiguration extends NSObject {
  static configurationWithMenu<This extends abstract new (...args: any) => any>(this: This, menu: UIMenu): InstanceType<This>;

  static configurationWithPreviewMenu<This extends abstract new (...args: any) => any>(this: This, preview: UITextItemMenuPreview | null, menu: UIMenu): InstanceType<This>;
}

declare class UINotificationFeedbackGenerator extends UIFeedbackGenerator {
  notificationOccurred(notificationType: interop.Enum<typeof UINotificationFeedbackType>): void;

  notificationOccurredAtLocation(notificationType: interop.Enum<typeof UINotificationFeedbackType>, location: CGPoint): void;
}

declare class UISceneSessionActivationRequest extends NSObject implements NSCopying {
  readonly role: string;

  readonly session: UISceneSession;

  userActivity: NSUserActivity;

  options: UISceneActivationRequestOptions;

  static request<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static requestWithRole<This extends abstract new (...args: any) => any>(this: This, role: string): InstanceType<This>;

  static requestWithSession<This extends abstract new (...args: any) => any>(this: This, session: UISceneSession): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIScreen extends NSObject implements UITraitEnvironment {
  static readonly screens: NSArray;

  static readonly mainScreen: UIScreen;

  readonly bounds: CGRect;

  readonly scale: number;

  readonly availableModes: NSArray;

  readonly preferredMode: UIScreenMode;

  currentMode: UIScreenMode;

  overscanCompensation: interop.Enum<typeof UIScreenOverscanCompensation>;

  readonly overscanCompensationInsets: UIEdgeInsets;

  readonly mirroredScreen: UIScreen;

  readonly isCaptured: boolean;

  brightness: number;

  wantsSoftwareDimming: boolean;

  readonly coordinateSpace: UICoordinateSpace;

  readonly fixedCoordinateSpace: UICoordinateSpace;

  readonly nativeBounds: CGRect;

  readonly nativeScale: number;

  displayLinkWithTargetSelector(target: interop.Object, sel: string): CADisplayLink;

  readonly maximumFramesPerSecond: number;

  readonly calibratedLatency: number;

  readonly referenceDisplayModeStatus: interop.Enum<typeof UIScreenReferenceDisplayModeStatus>;

  readonly currentEDRHeadroom: number;

  readonly potentialEDRHeadroom: number;

  readonly focusedItem: UIFocusItem;

  readonly focusedView: UIView;

  readonly supportsFocus: boolean;

  readonly applicationFrame: CGRect;

  snapshotViewAfterScreenUpdates(afterUpdates: boolean): UIView;

  readonly traitCollection: UITraitCollection;

  traitCollectionDidChange(previousTraitCollection: UITraitCollection | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIImpactFeedbackGenerator extends UIFeedbackGenerator {
  static feedbackGeneratorWithStyleForView<This extends abstract new (...args: any) => any>(this: This, style: interop.Enum<typeof UIImpactFeedbackStyle>, view: UIView): InstanceType<This>;

  impactOccurred(): void;

  impactOccurredAtLocation(location: CGPoint): void;

  impactOccurredWithIntensity(intensity: number): void;

  impactOccurredWithIntensityAtLocation(intensity: number, location: CGPoint): void;

  initWithStyle(style: interop.Enum<typeof UIImpactFeedbackStyle>): this;
}

declare class UISelectionFeedbackGenerator extends UIFeedbackGenerator {
  selectionChanged(): void;

  selectionChangedAtLocation(location: CGPoint): void;
}

declare class UIViewPropertyAnimator extends NSObject implements UIViewImplicitlyAnimating, NSCopying {
  readonly timingParameters: UITimingCurveProvider;

  readonly duration: number;

  readonly delay: number;

  isUserInteractionEnabled: boolean;

  isManualHitTestingEnabled: boolean;

  isInterruptible: boolean;

  scrubsLinearly: boolean;

  pausesOnCompletion: boolean;

  initWithDurationTimingParameters(duration: number, parameters: UITimingCurveProvider): this;

  initWithDurationCurveAnimations(duration: number, curve: interop.Enum<typeof UIViewAnimationCurve>, animations: () => void | null): this;

  initWithDurationControlPoint1ControlPoint2Animations(duration: number, point1: CGPoint, point2: CGPoint, animations: () => void | null): this;

  initWithDurationDampingRatioAnimations(duration: number, ratio: number, animations: () => void | null): this;

  static runningPropertyAnimatorWithDurationDelayOptionsAnimationsCompletion<This extends abstract new (...args: any) => any>(this: This, duration: number, delay: number, options: interop.Enum<typeof UIViewAnimationOptions>, animations: () => void, completion: (p1: interop.Enum<typeof UIViewAnimatingPosition>) => void | null): InstanceType<This>;

  addAnimationsDelayFactor(animation: () => void, delayFactor: number): void;

  addAnimations(animation: () => void): void;

  addCompletion(completion: (p1: interop.Enum<typeof UIViewAnimatingPosition>) => void): void;

  continueAnimationWithTimingParametersDurationFactor(parameters: UITimingCurveProvider | null, durationFactor: number): void;

  readonly state: interop.Enum<typeof UIViewAnimatingState>;

  readonly isRunning: boolean;

  isReversed: boolean;

  fractionComplete: number;

  startAnimation(): void;

  startAnimationAfterDelay(delay: number): void;

  pauseAnimation(): void;

  stopAnimation(withoutFinishing: boolean): void;

  finishAnimationAtPosition(finalPosition: interop.Enum<typeof UIViewAnimatingPosition>): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIRegion extends NSObject implements NSCopying, NSCoding {
  static readonly infiniteRegion: UIRegion;

  initWithRadius(radius: number): this;

  initWithSize(size: CGSize): this;

  inverseRegion(): this;

  regionByUnionWithRegion(region: UIRegion): this;

  regionByDifferenceFromRegion(region: UIRegion): this;

  regionByIntersectionWithRegion(region: UIRegion): this;

  containsPoint(point: CGPoint): boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UISceneActivationConditions extends NSObject implements NSSecureCoding {
  init(): this;

  initWithCoder(aDecoder: NSCoder): this;

  canActivateForTargetContentIdentifierPredicate: NSPredicate;

  prefersToActivateForTargetContentIdentifierPredicate: NSPredicate;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIAttachmentBehavior extends UIDynamicBehavior {
  initWithItemAttachedToAnchor(item: UIDynamicItem, point: CGPoint): this;

  initWithItemOffsetFromCenterAttachedToAnchor(item: UIDynamicItem, offset: UIOffset, point: CGPoint): this;

  initWithItemAttachedToItem(item1: UIDynamicItem, item2: UIDynamicItem): this;

  initWithItemOffsetFromCenterAttachedToItemOffsetFromCenter(item1: UIDynamicItem, offset1: UIOffset, item2: UIDynamicItem, offset2: UIOffset): this;

  static slidingAttachmentWithItemAttachedToItemAttachmentAnchorAxisOfTranslation<This extends abstract new (...args: any) => any>(this: This, item1: UIDynamicItem, item2: UIDynamicItem, point: CGPoint, axis: CGVector): InstanceType<This>;

  static slidingAttachmentWithItemAttachmentAnchorAxisOfTranslation<This extends abstract new (...args: any) => any>(this: This, item: UIDynamicItem, point: CGPoint, axis: CGVector): InstanceType<This>;

  static limitAttachmentWithItemOffsetFromCenterAttachedToItemOffsetFromCenter<This extends abstract new (...args: any) => any>(this: This, item1: UIDynamicItem, offset1: UIOffset, item2: UIDynamicItem, offset2: UIOffset): InstanceType<This>;

  static fixedAttachmentWithItemAttachedToItemAttachmentAnchor<This extends abstract new (...args: any) => any>(this: This, item1: UIDynamicItem, item2: UIDynamicItem, point: CGPoint): InstanceType<This>;

  static pinAttachmentWithItemAttachedToItemAttachmentAnchor<This extends abstract new (...args: any) => any>(this: This, item1: UIDynamicItem, item2: UIDynamicItem, point: CGPoint): InstanceType<This>;

  readonly items: NSArray;

  readonly attachedBehaviorType: interop.Enum<typeof UIAttachmentBehaviorType>;

  anchorPoint: CGPoint;

  length: number;

  damping: number;

  frequency: number;

  frictionTorque: number;

  attachmentRange: UIFloatRange;
}

declare class UICellAccessoryCustomView extends UICellAccessory {
  initWithCustomViewPlacement(customView: UIView, placement: interop.Enum<typeof UICellAccessoryPlacement>): this;

  readonly customView: UIView;

  readonly placement: interop.Enum<typeof UICellAccessoryPlacement>;

  maintainsFixedSize: boolean;

  position: (p1: NSArray<interop.Object> | Array<interop.Object>) => number;

  initWithCoder(coder: NSCoder): this;
}

declare class UIPushBehavior extends UIDynamicBehavior {
  initWithItemsMode(items: NSArray<interop.Object> | Array<interop.Object>, mode: interop.Enum<typeof UIPushBehaviorMode>): this;

  addItem(item: UIDynamicItem): void;

  removeItem(item: UIDynamicItem): void;

  readonly items: NSArray;

  targetOffsetFromCenterForItem(item: UIDynamicItem): UIOffset;

  setTargetOffsetFromCenterForItem(o: UIOffset, item: UIDynamicItem): void;

  readonly mode: interop.Enum<typeof UIPushBehaviorMode>;

  active: boolean;

  angle: number;

  magnitude: number;

  pushDirection: CGVector;

  setAngleMagnitude(angle: number, magnitude: number): void;
}

declare class UITableViewFocusUpdateContext extends UIFocusUpdateContext {
  readonly previouslyFocusedIndexPath: NSIndexPath;

  readonly nextFocusedIndexPath: NSIndexPath;
}

declare class UIDynamicAnimator extends NSObject {
  initWithReferenceView(view: UIView): this;

  addBehavior(behavior: UIDynamicBehavior): void;

  removeBehavior(behavior: UIDynamicBehavior): void;

  removeAllBehaviors(): void;

  readonly referenceView: UIView;

  readonly behaviors: NSArray;

  itemsInRect(rect: CGRect): NSArray;

  updateItemUsingCurrentState(item: UIDynamicItem): void;

  readonly isRunning: boolean;

  readonly elapsedTime: number;

  delegate: UIDynamicAnimatorDelegate;

  initWithCollectionViewLayout(layout: UICollectionViewLayout): this;

  layoutAttributesForCellAtIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  layoutAttributesForSupplementaryViewOfKindAtIndexPath(kind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  layoutAttributesForDecorationViewOfKindAtIndexPath(decorationViewKind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;
}

declare class UITabBarController extends UIViewController implements UITabBarDelegate, NSCoding {
  get viewControllers(): NSArray;
  set viewControllers(value: NSArray<interop.Object> | Array<interop.Object>);

  setViewControllersAnimated(viewControllers: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  selectedViewController: UIViewController;

  selectedIndex: number;

  readonly moreNavigationController: UINavigationController;

  get customizableViewControllers(): NSArray;
  set customizableViewControllers(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly tabBar: UITabBar;

  delegate: UITabBarControllerDelegate;

  tabBarDidSelectItem(tabBar: UITabBar, item: UITabBarItem): void;

  tabBarWillBeginCustomizingItems(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>): void;

  tabBarDidBeginCustomizingItems(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>): void;

  tabBarWillEndCustomizingItemsChanged(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>, changed: boolean): void;

  tabBarDidEndCustomizingItemsChanged(tabBar: UITabBar, items: NSArray<interop.Object> | Array<interop.Object>, changed: boolean): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIGraphicsImageRendererContext extends UIGraphicsRendererContext {
  readonly currentImage: UIImage;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIPopoverPresentationController extends UIPresentationController {
  // @ts-ignore MemberDecl.tsIgnore
  delegate: UIPopoverPresentationControllerDelegate;

  permittedArrowDirections: interop.Enum<typeof UIPopoverArrowDirection>;

  sourceView: UIView;

  sourceRect: CGRect;

  canOverlapSourceViewRect: boolean;

  sourceItem: UIPopoverPresentationControllerSourceItem;

  barButtonItem: UIBarButtonItem;

  readonly arrowDirection: interop.Enum<typeof UIPopoverArrowDirection>;

  get passthroughViews(): NSArray;
  set passthroughViews(value: NSArray<interop.Object> | Array<interop.Object>);

  backgroundColor: UIColor;

  popoverLayoutMargins: UIEdgeInsets;

  popoverBackgroundViewClass: UIPopoverBackgroundViewMethods;

  readonly adaptiveSheetPresentationController: UISheetPresentationController;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UISheetPresentationController extends UIPresentationController {
  // @ts-ignore MemberDecl.tsIgnore
  delegate: UISheetPresentationControllerDelegate;

  sourceView: UIView;

  prefersPageSizing: boolean;

  prefersEdgeAttachedInCompactHeight: boolean;

  widthFollowsPreferredContentSizeWhenEdgeAttached: boolean;

  prefersGrabberVisible: boolean;

  preferredCornerRadius: number;

  get detents(): NSArray;
  set detents(value: NSArray<interop.Object> | Array<interop.Object>);

  invalidateDetents(): void;

  selectedDetentIdentifier: string;

  largestUndimmedDetentIdentifier: string;

  prefersScrollingExpandsWhenScrolledToEdge: boolean;

  animateChanges(changes: () => void): void;
}

declare class UIDynamicItemBehavior extends UIDynamicBehavior {
  initWithItems(items: NSArray<interop.Object> | Array<interop.Object>): this;

  addItem(item: UIDynamicItem): void;

  removeItem(item: UIDynamicItem): void;

  readonly items: NSArray;

  elasticity: number;

  friction: number;

  density: number;

  resistance: number;

  angularResistance: number;

  charge: number;

  isAnchored: boolean;

  allowsRotation: boolean;

  addLinearVelocityForItem(velocity: CGPoint, item: UIDynamicItem): void;

  linearVelocityForItem(item: UIDynamicItem): CGPoint;

  addAngularVelocityForItem(velocity: number, item: UIDynamicItem): void;

  angularVelocityForItem(item: UIDynamicItem): number;
}

declare class UISheetPresentationControllerDetent extends NSObject {
  static mediumDetent<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static largeDetent<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static customDetentWithIdentifierResolver<This extends abstract new (...args: any) => any>(this: This, identifier: string | null, resolver: (p1: UISheetPresentationControllerDetentResolutionContext) => number): InstanceType<This>;

  readonly identifier: string;

  resolvedValueInContext(context: UISheetPresentationControllerDetentResolutionContext): number;
}

declare class NSTextSelectionNavigation extends NSObject {
  initWithDataSource(dataSource: NSTextSelectionDataSource): this;

  readonly textSelectionDataSource: NSTextSelectionDataSource | null;

  allowsNonContiguousRanges: boolean;

  rotatesCoordinateSystemForLayoutOrientation: boolean;

  flushLayoutCache(): void;

  destinationSelectionForTextSelectionDirectionDestinationExtendingConfined(textSelection: NSTextSelection, direction: interop.Enum<typeof NSTextSelectionNavigationDirection>, destination: interop.Enum<typeof NSTextSelectionNavigationDestination>, extending: boolean, confined: boolean): NSTextSelection;

  textSelectionsInteractingAtPointInContainerAtLocationAnchorsModifiersSelectingBounds(point: CGPoint, containerLocation: NSTextLocation, anchors: NSArray<interop.Object> | Array<interop.Object>, modifiers: interop.Enum<typeof NSTextSelectionNavigationModifier>, selecting: boolean, bounds: CGRect): NSArray;

  textSelectionForSelectionGranularityEnclosingTextSelection(selectionGranularity: interop.Enum<typeof NSTextSelectionGranularity>, textSelection: NSTextSelection): NSTextSelection;

  textSelectionForSelectionGranularityEnclosingPointInContainerAtLocation(selectionGranularity: interop.Enum<typeof NSTextSelectionGranularity>, point: CGPoint, location: NSTextLocation): NSTextSelection;

  resolvedInsertionLocationForTextSelectionWritingDirection(textSelection: NSTextSelection, writingDirection: interop.Enum<typeof NSTextSelectionNavigationWritingDirection>): NSTextLocation;

  deletionRangesForTextSelectionDirectionDestinationAllowsDecomposition(textSelection: NSTextSelection, direction: interop.Enum<typeof NSTextSelectionNavigationDirection>, destination: interop.Enum<typeof NSTextSelectionNavigationDestination>, allowsDecomposition: boolean): NSArray;
}

declare class NSTextContainer extends NSObject implements NSSecureCoding, NSTextLayoutOrientationProvider {
  initWithSize(size: CGSize): this;

  initWithCoder(coder: NSCoder): this;

  layoutManager: NSLayoutManager;

  replaceLayoutManager(newLayoutManager: NSLayoutManager): void;

  readonly textLayoutManager: NSTextLayoutManager;

  size: CGSize;

  get exclusionPaths(): NSArray;
  set exclusionPaths(value: NSArray<interop.Object> | Array<interop.Object>);

  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  lineFragmentPadding: number;

  maximumNumberOfLines: number;

  lineFragmentRectForProposedRectAtIndexWritingDirectionRemainingRect(proposedRect: CGRect, characterIndex: number, baseWritingDirection: interop.Enum<typeof NSWritingDirection>, remainingRect: interop.PointerConvertible): CGRect;

  readonly isSimpleRectangularTextContainer: boolean;

  widthTracksTextView: boolean;

  heightTracksTextView: boolean;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  readonly layoutOrientation: interop.Enum<typeof NSTextLayoutOrientation>;
}

declare class UIPointerEffect extends NSObject implements NSCopying, UIHoverEffect {
  readonly preview: UITargetedPreview;

  static effectWithPreview<This extends abstract new (...args: any) => any>(this: This, preview: UITargetedPreview): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIIndirectScribbleInteraction extends NSObject implements UIInteraction {
  initWithDelegate(delegate: UIIndirectScribbleInteractionDelegate): this;

  readonly delegate: UIIndirectScribbleInteractionDelegate;

  readonly isHandlingWriting: boolean;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UINavigationItem extends NSObject implements NSCoding {
  initWithTitle(title: string): this;

  initWithCoder(coder: NSCoder): this;

  title: string;

  titleView: UIView;

  prompt: string;

  backBarButtonItem: UIBarButtonItem;

  backButtonTitle: string;

  hidesBackButton: boolean;

  setHidesBackButtonAnimated(hidesBackButton: boolean, animated: boolean): void;

  backButtonDisplayMode: interop.Enum<typeof UINavigationItemBackButtonDisplayMode>;

  backAction: UIAction;

  titleMenuProvider: (p1: NSArray<interop.Object> | Array<interop.Object>) => UIMenu | null;

  renameDelegate: UINavigationItemRenameDelegate;

  documentProperties: UIDocumentProperties;

  get leftBarButtonItems(): NSArray;
  set leftBarButtonItems(value: NSArray<interop.Object> | Array<interop.Object>);

  get rightBarButtonItems(): NSArray;
  set rightBarButtonItems(value: NSArray<interop.Object> | Array<interop.Object>);

  setLeftBarButtonItemsAnimated(items: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  setRightBarButtonItemsAnimated(items: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  leftItemsSupplementBackButton: boolean;

  leftBarButtonItem: UIBarButtonItem;

  rightBarButtonItem: UIBarButtonItem;

  setLeftBarButtonItemAnimated(item: UIBarButtonItem | null, animated: boolean): void;

  setRightBarButtonItemAnimated(item: UIBarButtonItem | null, animated: boolean): void;

  customizationIdentifier: string;

  get leadingItemGroups(): NSArray;
  set leadingItemGroups(value: NSArray<interop.Object> | Array<interop.Object>);

  get centerItemGroups(): NSArray;
  set centerItemGroups(value: NSArray<interop.Object> | Array<interop.Object>);

  get trailingItemGroups(): NSArray;
  set trailingItemGroups(value: NSArray<interop.Object> | Array<interop.Object>);

  pinnedTrailingGroup: UIBarButtonItemGroup;

  additionalOverflowItems: UIDeferredMenuElement;

  readonly overflowPresentationSource: UIPopoverPresentationControllerSourceItem;

  largeTitleDisplayMode: interop.Enum<typeof UINavigationItemLargeTitleDisplayMode>;

  style: interop.Enum<typeof UINavigationItemStyle>;

  searchController: UISearchController;

  hidesSearchBarWhenScrolling: boolean;

  preferredSearchBarPlacement: interop.Enum<typeof UINavigationItemSearchBarPlacement>;

  readonly searchBarPlacement: interop.Enum<typeof UINavigationItemSearchBarPlacement>;

  standardAppearance: UINavigationBarAppearance;

  compactAppearance: UINavigationBarAppearance;

  scrollEdgeAppearance: UINavigationBarAppearance;

  compactScrollEdgeAppearance: UINavigationBarAppearance;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UISearchSuggestionItem extends NSObject implements UISearchSuggestion {
  static suggestionWithLocalizedSuggestion<This extends abstract new (...args: any) => any>(this: This, suggestion: string): InstanceType<This>;

  static suggestionWithLocalizedSuggestionDescriptionString<This extends abstract new (...args: any) => any>(this: This, suggestion: string, description: string | null): InstanceType<This>;

  static suggestionWithLocalizedSuggestionDescriptionStringIconImage<This extends abstract new (...args: any) => any>(this: This, suggestion: string, description: string | null, iconImage: UIImage | null): InstanceType<This>;

  static suggestionWithLocalizedAttributedSuggestion<This extends abstract new (...args: any) => any>(this: This, suggestion: NSAttributedString): InstanceType<This>;

  static suggestionWithLocalizedAttributedSuggestionDescriptionString<This extends abstract new (...args: any) => any>(this: This, suggestion: NSAttributedString, description: string | null): InstanceType<This>;

  static suggestionWithLocalizedAttributedSuggestionDescriptionStringIconImage<This extends abstract new (...args: any) => any>(this: This, suggestion: NSAttributedString, description: string | null, iconImage: UIImage | null): InstanceType<This>;

  initWithLocalizedSuggestion(suggestion: string): this;

  initWithLocalizedSuggestionLocalizedDescription(suggestion: string, description: string | null): this;

  initWithLocalizedSuggestionLocalizedDescriptionIconImage(suggestion: string, description: string | null, iconImage: UIImage | null): this;

  initWithLocalizedAttributedSuggestion(suggestion: NSAttributedString): this;

  initWithLocalizedAttributedSuggestionLocalizedDescription(suggestion: NSAttributedString, description: string | null): this;

  initWithLocalizedAttributedSuggestionLocalizedDescriptionIconImage(suggestion: NSAttributedString, description: string | null, iconImage: UIImage | null): this;

  readonly localizedAttributedSuggestion: NSAttributedString;

  readonly localizedSuggestion: string;

  readonly localizedDescription: string;

  readonly iconImage: UIImage;

  representedObject: interop.Object;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITabBarItemStateAppearance extends NSObject {
  get titleTextAttributes(): NSDictionary;
  set titleTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  titlePositionAdjustment: UIOffset;

  iconColor: UIColor;

  badgePositionAdjustment: UIOffset;

  badgeBackgroundColor: UIColor;

  get badgeTextAttributes(): NSDictionary;
  set badgeTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  badgeTitlePositionAdjustment: UIOffset;
}

declare class UIToolbarAppearance extends UIBarAppearance {
  buttonAppearance: UIBarButtonItemAppearance;

  doneButtonAppearance: UIBarButtonItemAppearance;
}

declare class UIBarButtonItemStateAppearance extends NSObject {
  get titleTextAttributes(): NSDictionary;
  set titleTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  titlePositionAdjustment: UIOffset;

  backgroundImage: UIImage;

  backgroundImagePositionAdjustment: UIOffset;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIBarAppearance extends NSObject implements NSCopying, NSSecureCoding {
  init(): this;

  initWithIdiom(idiom: interop.Enum<typeof UIUserInterfaceIdiom>): this;

  readonly idiom: interop.Enum<typeof UIUserInterfaceIdiom>;

  initWithBarAppearance(barAppearance: UIBarAppearance): this;

  initWithCoder(coder: NSCoder): this;

  // @ts-ignore MemberDecl.tsIgnore
  copy(): this;

  configureWithDefaultBackground(): void;

  configureWithOpaqueBackground(): void;

  configureWithTransparentBackground(): void;

  backgroundEffect: UIBlurEffect;

  backgroundColor: UIColor;

  backgroundImage: UIImage;

  backgroundImageContentMode: interop.Enum<typeof UIViewContentMode>;

  shadowColor: UIColor;

  shadowImage: UIImage;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIPreviewTarget extends NSObject implements NSCopying {
  initWithContainerCenterTransform(container: UIView, center: CGPoint, transform: CGAffineTransform): this;

  initWithContainerCenter(container: UIView, center: CGPoint): this;

  readonly container: UIView;

  readonly center: CGPoint;

  readonly transform: CGAffineTransform;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICanvasFeedbackGenerator extends UIFeedbackGenerator {
  alignmentOccurredAtLocation(location: CGPoint): void;

  pathCompletedAtLocation(location: CGPoint): void;
}

declare class UIDragPreviewParameters extends UIPreviewParameters {
}

declare class UIPreviewParameters extends NSObject implements NSCopying {
  init(): this;

  initWithTextLineRects(textLineRects: NSArray<interop.Object> | Array<interop.Object>): this;

  visiblePath: UIBezierPath;

  shadowPath: UIBezierPath;

  backgroundColor: UIColor;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICellAccessoryReorder extends UICellAccessory {
  showsVerticalSeparator: boolean;
}

declare class UIDragItem extends NSObject {
  initWithItemProvider(itemProvider: NSItemProvider): this;

  readonly itemProvider: NSItemProvider;

  localObject: interop.Object;

  previewProvider: () => UIDragPreview | null;

  setNeedsDropPreviewUpdate(): void;
}

declare class UIToolbar extends UIView implements UIBarPositioning {
  barStyle: interop.Enum<typeof UIBarStyle>;

  get items(): NSArray;
  set items(value: NSArray<interop.Object> | Array<interop.Object>);

  isTranslucent: boolean;

  setItemsAnimated(items: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  tintColor: UIColor;

  barTintColor: UIColor;

  setBackgroundImageForToolbarPositionBarMetrics(backgroundImage: UIImage | null, topOrBottom: interop.Enum<typeof UIBarPosition>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForToolbarPositionBarMetrics(topOrBottom: interop.Enum<typeof UIBarPosition>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setShadowImageForToolbarPosition(shadowImage: UIImage | null, topOrBottom: interop.Enum<typeof UIBarPosition>): void;

  shadowImageForToolbarPosition(topOrBottom: interop.Enum<typeof UIBarPosition>): UIImage;

  standardAppearance: UIToolbarAppearance;

  compactAppearance: UIToolbarAppearance;

  scrollEdgeAppearance: UIToolbarAppearance;

  compactScrollEdgeAppearance: UIToolbarAppearance;

  delegate: UIToolbarDelegate;

  readonly barPosition: interop.Enum<typeof UIBarPosition>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UISnapBehavior extends UIDynamicBehavior {
  initWithItemSnapToPoint(item: UIDynamicItem, point: CGPoint): this;

  snapPoint: CGPoint;

  damping: number;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UITextView extends UIScrollView implements UITextInput, UIContentSizeCategoryAdjusting, UILetterformAwareAdjusting {
  // @ts-ignore MemberDecl.tsIgnore
  delegate: UITextViewDelegate;

  text: string;

  font: UIFont;

  textColor: UIColor;

  textAlignment: interop.Enum<typeof NSTextAlignment>;

  selectedRange: _NSRange;

  isEditable: boolean;

  isSelectable: boolean;

  dataDetectorTypes: interop.Enum<typeof UIDataDetectorTypes>;

  allowsEditingTextAttributes: boolean;

  attributedText: NSAttributedString;

  get typingAttributes(): NSDictionary;
  set typingAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  scrollRangeToVisible(range: _NSRange): void;

  // @ts-ignore MemberDecl.tsIgnore
  inputView: UIView;

  // @ts-ignore MemberDecl.tsIgnore
  inputAccessoryView: UIView;

  clearsOnInsertion: boolean;

  initWithFrameTextContainer(frame: CGRect, textContainer: NSTextContainer | null): this;

  static textViewUsingTextLayoutManager<This extends abstract new (...args: any) => any>(this: This, usingTextLayoutManager: boolean): InstanceType<This>;

  initWithCoder(coder: NSCoder): this;

  readonly textContainer: NSTextContainer;

  textContainerInset: UIEdgeInsets;

  readonly textLayoutManager: NSTextLayoutManager;

  readonly layoutManager: NSLayoutManager;

  readonly textStorage: NSTextStorage;

  get linkTextAttributes(): NSDictionary;
  set linkTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  usesStandardTextScaling: boolean;

  readonly findInteraction: UIFindInteraction;

  isFindInteractionEnabled: boolean;

  borderStyle: interop.Enum<typeof UITextViewBorderStyle>;

  interactionState: interop.Object;

  textInRange(range: UITextRange): string;

  replaceRangeWithText(range: UITextRange, text: string): void;

  selectedTextRange: UITextRange;

  readonly markedTextRange: UITextRange;

  get markedTextStyle(): NSDictionary;
  set markedTextStyle(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  setMarkedTextSelectedRange(markedText: string | null, selectedRange: _NSRange): void;

  unmarkText(): void;

  readonly beginningOfDocument: UITextPosition;

  readonly endOfDocument: UITextPosition;

  textRangeFromPositionToPosition(fromPosition: UITextPosition, toPosition: UITextPosition): UITextRange;

  positionFromPositionOffset(position: UITextPosition, offset: number): UITextPosition;

  positionFromPositionInDirectionOffset(position: UITextPosition, direction: interop.Enum<typeof UITextLayoutDirection>, offset: number): UITextPosition;

  comparePositionToPosition(position: UITextPosition, other: UITextPosition): interop.Enum<typeof NSComparisonResult>;

  offsetFromPositionToPosition(from: UITextPosition, toPosition: UITextPosition): number;

  inputDelegate: UITextInputDelegate;

  readonly tokenizer: UITextInputTokenizer;

  positionWithinRangeFarthestInDirection(range: UITextRange, direction: interop.Enum<typeof UITextLayoutDirection>): UITextPosition;

  characterRangeByExtendingPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextLayoutDirection>): UITextRange;

  baseWritingDirectionForPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextStorageDirection>): interop.Enum<typeof NSWritingDirection>;

  setBaseWritingDirectionForRange(writingDirection: interop.Enum<typeof NSWritingDirection>, range: UITextRange): void;

  firstRectForRange(range: UITextRange): CGRect;

  caretRectForPosition(position: UITextPosition): CGRect;

  selectionRectsForRange(range: UITextRange): NSArray;

  closestPositionToPoint(point: CGPoint): UITextPosition;

  closestPositionToPointWithinRange(point: CGPoint, range: UITextRange): UITextPosition;

  characterRangeAtPoint(point: CGPoint): UITextRange;

  shouldChangeTextInRangeReplacementText(range: UITextRange, text: string): boolean;

  textStylingAtPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextStorageDirection>): NSDictionary;

  positionWithinRangeAtCharacterOffset(range: UITextRange, offset: number): UITextPosition;

  characterOffsetOfPositionWithinRange(position: UITextPosition, range: UITextRange): number;

  readonly textInputView: UIView;

  selectionAffinity: interop.Enum<typeof UITextStorageDirection>;

  insertDictationResult(dictationResult: NSArray<interop.Object> | Array<interop.Object>): void;

  dictationRecordingDidEnd(): void;

  dictationRecognitionFailed(): void;

  readonly insertDictationResultPlaceholder: interop.Object;

  frameForDictationResultPlaceholder(placeholder: interop.Object): CGRect;

  removeDictationResultPlaceholderWillInsertResult(placeholder: interop.Object, willInsertResult: boolean): void;

  insertTextAlternativesStyle(text: string, alternatives: NSArray<interop.Object> | Array<interop.Object>, style: interop.Enum<typeof UITextAlternativeStyle>): void;

  setAttributedMarkedTextSelectedRange(markedText: NSAttributedString | null, selectedRange: _NSRange): void;

  insertTextPlaceholderWithSize(size: CGSize): UITextPlaceholder;

  removeTextPlaceholder(textPlaceholder: UITextPlaceholder): void;

  beginFloatingCursorAtPoint(point: CGPoint): void;

  updateFloatingCursorAtPoint(point: CGPoint): void;

  endFloatingCursor(): void;

  caretTransformForPosition(position: UITextPosition): CGAffineTransform;

  editMenuForTextRangeSuggestedActions(textRange: UITextRange, suggestedActions: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  willPresentEditMenuWithAnimator(animator: UIEditMenuInteractionAnimating): void;

  willDismissEditMenuWithAnimator(animator: UIEditMenuInteractionAnimating): void;

  readonly hasText: boolean;

  insertText(text: string): void;

  deleteBackward(): void;

  autocapitalizationType: interop.Enum<typeof UITextAutocapitalizationType>;

  autocorrectionType: interop.Enum<typeof UITextAutocorrectionType>;

  spellCheckingType: interop.Enum<typeof UITextSpellCheckingType>;

  smartQuotesType: interop.Enum<typeof UITextSmartQuotesType>;

  smartDashesType: interop.Enum<typeof UITextSmartDashesType>;

  smartInsertDeleteType: interop.Enum<typeof UITextSmartInsertDeleteType>;

  inlinePredictionType: interop.Enum<typeof UITextInlinePredictionType>;

  keyboardType: interop.Enum<typeof UIKeyboardType>;

  keyboardAppearance: interop.Enum<typeof UIKeyboardAppearance>;

  returnKeyType: interop.Enum<typeof UIReturnKeyType>;

  enablesReturnKeyAutomatically: boolean;

  isSecureTextEntry: boolean;

  textContentType: string;

  passwordRules: UITextInputPasswordRules;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  adjustsFontForContentSizeCategory: boolean;

  sizingRule: interop.Enum<typeof UILetterformAwareSizingRule>;
}

declare class UIDocumentBrowserAction extends NSObject {
  initWithIdentifierLocalizedTitleAvailabilityHandler(identifier: string, localizedTitle: string, availability: interop.Enum<typeof UIDocumentBrowserActionAvailability>, handler: (p1: NSArray<interop.Object> | Array<interop.Object>) => void): this;

  readonly identifier: string;

  readonly localizedTitle: string;

  readonly availability: interop.Enum<typeof UIDocumentBrowserActionAvailability>;

  image: UIImage;

  get supportedContentTypes(): NSArray;
  set supportedContentTypes(value: NSArray<interop.Object> | Array<interop.Object>);

  supportsMultipleItems: boolean;
}

declare class UIFindInteraction extends NSObject implements UIInteraction {
  readonly isFindNavigatorVisible: boolean;

  readonly activeFindSession: UIFindSession;

  searchText: string;

  replacementText: string;

  optionsMenuProvider: (p1: NSArray<interop.Object> | Array<interop.Object>) => UIMenu | null;

  readonly delegate: UIFindInteractionDelegate | null;

  initWithSessionDelegate(sessionDelegate: UIFindInteractionDelegate): this;

  presentFindNavigatorShowingReplace(showingReplace: boolean): void;

  dismissFindNavigator(): void;

  findNext(): void;

  findPrevious(): void;

  updateResultCount(): void;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIVideoEditorController extends UINavigationController {
  static canEditVideoAtPath(videoPath: string): boolean;

  delegate: UINavigationControllerDelegate;

  videoPath: string;

  videoMaximumDuration: number;

  videoQuality: interop.Enum<typeof UIImagePickerControllerQualityType>;
}

declare class UITextSearchingFindSession extends UIFindSession {
  readonly searchableObject: UITextSearching | null;

  initWithSearchableObject(searchableObject: UITextSearching): this;
}

declare class UIFindSession extends NSObject {
  readonly resultCount: number;

  readonly highlightedResultIndex: number;

  searchResultDisplayStyle: interop.Enum<typeof UIFindSessionSearchResultDisplayStyle>;

  readonly supportsReplacement: boolean;

  readonly allowsReplacementForCurrentlyHighlightedResult: boolean;

  performSearchWithQueryOptions(query: string, options: UITextSearchOptions | null): void;

  performSingleReplacementWithSearchQueryReplacementStringOptions(searchQuery: string, replacementString: string, options: UITextSearchOptions | null): void;

  replaceAllInstancesOfSearchQueryWithReplacementStringOptions(searchQuery: string, replacementString: string, options: UITextSearchOptions | null): void;

  highlightNextResultInDirection(direction: interop.Enum<typeof UITextStorageDirection>): void;

  invalidateFoundResults(): void;

  readonly allowsReplacement: boolean;
}

declare class UIFieldBehavior extends UIDynamicBehavior {
  addItem(item: UIDynamicItem): void;

  removeItem(item: UIDynamicItem): void;

  readonly items: NSArray;

  position: CGPoint;

  region: UIRegion;

  strength: number;

  falloff: number;

  minimumRadius: number;

  direction: CGVector;

  smoothness: number;

  animationSpeed: number;

  static dragField<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static vortexField<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static radialGravityFieldWithPosition<This extends abstract new (...args: any) => any>(this: This, position: CGPoint): InstanceType<This>;

  static linearGravityFieldWithVector<This extends abstract new (...args: any) => any>(this: This, direction: CGVector): InstanceType<This>;

  static velocityFieldWithVector<This extends abstract new (...args: any) => any>(this: This, direction: CGVector): InstanceType<This>;

  static noiseFieldWithSmoothnessAnimationSpeed<This extends abstract new (...args: any) => any>(this: This, smoothness: number, speed: number): InstanceType<This>;

  static turbulenceFieldWithSmoothnessAnimationSpeed<This extends abstract new (...args: any) => any>(this: This, smoothness: number, speed: number): InstanceType<This>;

  static springField<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static electricField<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static magneticField<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static fieldWithEvaluationBlock<This extends abstract new (...args: any) => any>(this: This, block: (p1: UIFieldBehavior, p2: CGPoint, p3: CGVector, p4: number, p5: number, p6: number) => CGVector): InstanceType<This>;
}

declare class UITextSelectionDisplayInteraction extends NSObject implements UIInteraction {
  isActivated: boolean;

  readonly textInput: UITextInput | null;

  readonly delegate: UITextSelectionDisplayInteractionDelegate | null;

  cursorView: UIView;

  highlightView: UIView;

  get handleViews(): NSArray;
  set handleViews(value: NSArray<interop.Object> | Array<interop.Object>);

  initWithTextInputDelegate(textInput: UITextInput, delegate: UITextSelectionDisplayInteractionDelegate): this;

  layoutManagedSubviews(): void;

  setNeedsSelectionUpdate(): void;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UILongPressGestureRecognizer extends UIGestureRecognizer {
  numberOfTapsRequired: number;

  numberOfTouchesRequired: number;

  minimumPressDuration: number;

  allowableMovement: number;
}

declare class UIPointerRegion extends NSObject implements NSCopying {
  readonly rect: CGRect;

  readonly identifier: NSObject;

  latchingAxes: interop.Enum<typeof UIAxis>;

  static regionWithRectIdentifier<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, identifier: NSObject | null): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITextChecker extends NSObject {
  rangeOfMisspelledWordInStringRangeStartingAtWrapLanguage(stringToCheck: string, range: _NSRange, startingOffset: number, wrapFlag: boolean, language: string): _NSRange;

  guessesForWordRangeInStringLanguage(range: _NSRange, string: string, language: string): NSArray;

  completionsForPartialWordRangeInStringLanguage(range: _NSRange, string: string, language: string): NSArray;

  ignoreWord(wordToIgnore: string): void;

  get ignoredWords(): NSArray;
  set ignoredWords(value: NSArray<interop.Object> | Array<interop.Object>);

  static learnWord(word: string): void;

  static hasLearnedWord(word: string): boolean;

  static unlearnWord(word: string): void;

  static readonly availableLanguages: NSArray;
}

declare class UITableViewHeaderFooterView extends UIView {
  initWithReuseIdentifier(reuseIdentifier: string | null): this;

  initWithCoder(coder: NSCoder): this;

  readonly configurationState: UIViewConfigurationState;

  setNeedsUpdateConfiguration(): void;

  updateConfigurationUsingState(state: UIViewConfigurationState): void;

  configurationUpdateHandler: (p1: UITableViewHeaderFooterView, p2: UIViewConfigurationState) => void;

  defaultContentConfiguration(): UIListContentConfiguration;

  contentConfiguration: UIContentConfiguration;

  automaticallyUpdatesContentConfiguration: boolean;

  readonly contentView: UIView;

  readonly textLabel: UILabel;

  readonly detailTextLabel: UILabel;

  defaultBackgroundConfiguration(): UIBackgroundConfiguration;

  backgroundConfiguration: UIBackgroundConfiguration;

  automaticallyUpdatesBackgroundConfiguration: boolean;

  backgroundView: UIView;

  readonly reuseIdentifier: string;

  prepareForReuse(): void;
}

declare class UIStoryboardSegue extends NSObject {
  static segueWithIdentifierSourceDestinationPerformHandler<This extends abstract new (...args: any) => any>(this: This, identifier: string | null, source: UIViewController, destination: UIViewController, performHandler: () => void): InstanceType<This>;

  initWithIdentifierSourceDestination(identifier: string | null, source: UIViewController, destination: UIViewController): this;

  readonly identifier: string;

  readonly sourceViewController: UIViewController;

  readonly destinationViewController: UIViewController;

  perform(): void;
}

declare class UISegmentedControl extends UIControl implements NSCoding {
  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  initWithItems(items: NSArray<interop.Object> | Array<interop.Object> | null): this;

  initWithFrameActions(frame: CGRect, actions: NSArray<interop.Object> | Array<interop.Object>): this;

  insertSegmentWithActionAtIndexAnimated(action: UIAction, segment: number, animated: boolean): void;

  setActionForSegmentAtIndex(action: UIAction, segment: number): void;

  actionForSegmentAtIndex(segment: number): UIAction;

  segmentIndexForActionIdentifier(actionIdentifier: string): number;

  segmentedControlStyle: interop.Enum<typeof UISegmentedControlStyle>;

  isMomentary: boolean;

  readonly numberOfSegments: number;

  apportionsSegmentWidthsByContent: boolean;

  insertSegmentWithTitleAtIndexAnimated(title: string | null, segment: number, animated: boolean): void;

  insertSegmentWithImageAtIndexAnimated(image: UIImage | null, segment: number, animated: boolean): void;

  removeSegmentAtIndexAnimated(segment: number, animated: boolean): void;

  removeAllSegments(): void;

  setTitleForSegmentAtIndex(title: string | null, segment: number): void;

  titleForSegmentAtIndex(segment: number): string;

  setImageForSegmentAtIndex(image: UIImage | null, segment: number): void;

  imageForSegmentAtIndex(segment: number): UIImage;

  setWidthForSegmentAtIndex(width: number, segment: number): void;

  widthForSegmentAtIndex(segment: number): number;

  setContentOffsetForSegmentAtIndex(offset: CGSize, segment: number): void;

  contentOffsetForSegmentAtIndex(segment: number): CGSize;

  setEnabledForSegmentAtIndex(enabled: boolean, segment: number): void;

  isEnabledForSegmentAtIndex(segment: number): boolean;

  selectedSegmentIndex: number;

  selectedSegmentTintColor: UIColor;

  setBackgroundImageForStateBarMetrics(backgroundImage: UIImage | null, state: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForStateBarMetrics(state: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setDividerImageForLeftSegmentStateRightSegmentStateBarMetrics(dividerImage: UIImage | null, leftState: interop.Enum<typeof UIControlState>, rightState: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  dividerImageForLeftSegmentStateRightSegmentStateBarMetrics(leftState: interop.Enum<typeof UIControlState>, rightState: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setTitleTextAttributesForState(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, state: interop.Enum<typeof UIControlState>): void;

  titleTextAttributesForState(state: interop.Enum<typeof UIControlState>): NSDictionary;

  setContentPositionAdjustmentForSegmentTypeBarMetrics(adjustment: UIOffset, leftCenterRightOrAlone: interop.Enum<typeof UISegmentedControlSegment>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  contentPositionAdjustmentForSegmentTypeBarMetrics(leftCenterRightOrAlone: interop.Enum<typeof UISegmentedControlSegment>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIOffset;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UISearchToken extends NSObject {
  static tokenWithIconText(icon: UIImage | null, text: string): UISearchToken;

  representedObject: interop.Object;
}

declare class UICubicTimingParameters extends NSObject implements UITimingCurveProvider {
  readonly animationCurve: interop.Enum<typeof UIViewAnimationCurve>;

  readonly controlPoint1: CGPoint;

  readonly controlPoint2: CGPoint;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  initWithAnimationCurve(curve: interop.Enum<typeof UIViewAnimationCurve>): this;

  initWithControlPoint1ControlPoint2(point1: CGPoint, point2: CGPoint): this;

  readonly timingCurveType: interop.Enum<typeof UITimingCurveType>;

  readonly cubicTimingParameters: UICubicTimingParameters;

  readonly springTimingParameters: UISpringTimingParameters;

  encodeWithCoder(coder: NSCoder): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIScreenEdgePanGestureRecognizer extends UIPanGestureRecognizer {
  edges: interop.Enum<typeof UIRectEdge>;
}

declare class UITextInputAssistantItem extends NSObject {
  allowsHidingShortcuts: boolean;

  get leadingBarButtonGroups(): NSArray;
  set leadingBarButtonGroups(value: NSArray<interop.Object> | Array<interop.Object>);

  get trailingBarButtonGroups(): NSArray;
  set trailingBarButtonGroups(value: NSArray<interop.Object> | Array<interop.Object>);
}

declare class UITextInputStringTokenizer extends NSObject implements UITextInputTokenizer {
  initWithTextInput(textInput: UIResponder): this;

  rangeEnclosingPositionWithGranularityInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): UITextRange;

  isPositionAtBoundaryInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): boolean;

  positionFromPositionToBoundaryInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): UITextPosition;

  isPositionWithinTextUnitInDirection(position: UITextPosition, granularity: interop.Enum<typeof UITextGranularity>, direction: number): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIProgressView extends UIView implements NSCoding {
  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  initWithProgressViewStyle(style: interop.Enum<typeof UIProgressViewStyle>): this;

  progressViewStyle: interop.Enum<typeof UIProgressViewStyle>;

  progress: number;

  progressTintColor: UIColor;

  trackTintColor: UIColor;

  progressImage: UIImage;

  trackImage: UIImage;

  setProgressAnimated(progress: number, animated: boolean): void;

  observedProgress: NSProgress;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UICommandAlternate extends NSObject implements NSCopying, NSSecureCoding {
  readonly title: string;

  readonly action: string;

  readonly modifierFlags: interop.Enum<typeof UIKeyModifierFlags>;

  static alternateWithTitleActionModifierFlags<This extends abstract new (...args: any) => any>(this: This, title: string, action: string, modifierFlags: interop.Enum<typeof UIKeyModifierFlags>): InstanceType<This>;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UITrackingLayoutGuide extends UILayoutGuide {
  setConstraintsActiveWhenNearEdge(trackingConstraints: NSArray<interop.Object> | Array<interop.Object>, edge: interop.Enum<typeof NSDirectionalRectEdge>): void;

  constraintsActiveWhenNearEdge(edge: interop.Enum<typeof NSDirectionalRectEdge>): NSArray;

  setConstraintsActiveWhenAwayFromEdge(trackingConstraints: NSArray<interop.Object> | Array<interop.Object>, edge: interop.Enum<typeof NSDirectionalRectEdge>): void;

  constraintsActiveWhenAwayFromEdge(edge: interop.Enum<typeof NSDirectionalRectEdge>): NSArray;

  removeAllTrackedConstraints(): void;
}

declare class UIPopoverController extends NSObject implements UIAppearanceContainer {
  initWithContentViewController(viewController: UIViewController): this;

  delegate: UIPopoverControllerDelegate;

  contentViewController: UIViewController;

  setContentViewControllerAnimated(viewController: UIViewController, animated: boolean): void;

  popoverContentSize: CGSize;

  setPopoverContentSizeAnimated(size: CGSize, animated: boolean): void;

  readonly isPopoverVisible: boolean;

  readonly popoverArrowDirection: interop.Enum<typeof UIPopoverArrowDirection>;

  get passthroughViews(): NSArray;
  set passthroughViews(value: NSArray<interop.Object> | Array<interop.Object>);

  presentPopoverFromRectInViewPermittedArrowDirectionsAnimated(rect: CGRect, view: UIView, arrowDirections: interop.Enum<typeof UIPopoverArrowDirection>, animated: boolean): void;

  presentPopoverFromBarButtonItemPermittedArrowDirectionsAnimated(item: UIBarButtonItem, arrowDirections: interop.Enum<typeof UIPopoverArrowDirection>, animated: boolean): void;

  dismissPopoverAnimated(animated: boolean): void;

  backgroundColor: UIColor;

  popoverLayoutMargins: UIEdgeInsets;

  popoverBackgroundViewClass: interop.Object;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UISceneConnectionOptions extends NSObject {
  readonly URLContexts: NSSet;

  readonly sourceApplication: string;

  readonly handoffUserActivityType: string;

  readonly userActivities: NSSet;

  readonly notificationResponse: UNNotificationResponse;

  readonly shortcutItem: UIApplicationShortcutItem;

  readonly cloudKitShareMetadata: CKShareMetadata;
}

declare class UIPasteControl extends UIControl {
  readonly configuration: UIPasteControlConfiguration;

  target: UIPasteConfigurationSupporting;

  initWithConfiguration(configuration: UIPasteControlConfiguration): this;

  initWithCoder(coder: NSCoder): this;

  initWithFrame(frame: CGRect): this;
}

declare class UIPasteControlConfiguration extends NSObject implements NSSecureCoding {
  displayMode: interop.Enum<typeof UIPasteControlDisplayMode>;

  cornerStyle: interop.Enum<typeof UIButtonConfigurationCornerStyle>;

  cornerRadius: number;

  baseForegroundColor: UIColor;

  baseBackgroundColor: UIColor;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UITraitActiveAppearance extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIPageViewController extends UIViewController {
  initWithTransitionStyleNavigationOrientationOptions(style: interop.Enum<typeof UIPageViewControllerTransitionStyle>, navigationOrientation: interop.Enum<typeof UIPageViewControllerNavigationOrientation>, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  initWithCoder(coder: NSCoder): this;

  delegate: UIPageViewControllerDelegate;

  dataSource: UIPageViewControllerDataSource;

  readonly transitionStyle: interop.Enum<typeof UIPageViewControllerTransitionStyle>;

  readonly navigationOrientation: interop.Enum<typeof UIPageViewControllerNavigationOrientation>;

  readonly spineLocation: interop.Enum<typeof UIPageViewControllerSpineLocation>;

  isDoubleSided: boolean;

  readonly gestureRecognizers: NSArray;

  readonly viewControllers: NSArray;

  setViewControllersDirectionAnimatedCompletion(viewControllers: NSArray<interop.Object> | Array<interop.Object> | null, direction: interop.Enum<typeof UIPageViewControllerNavigationDirection>, animated: boolean, completion: (p1: boolean) => void | null): void;
}

declare class UIPageControl extends UIControl {
  numberOfPages: number;

  currentPage: number;

  hidesForSinglePage: boolean;

  progress: UIPageControlProgress;

  pageIndicatorTintColor: UIColor;

  currentPageIndicatorTintColor: UIColor;

  backgroundStyle: interop.Enum<typeof UIPageControlBackgroundStyle>;

  direction: interop.Enum<typeof UIPageControlDirection>;

  readonly interactionState: interop.Enum<typeof UIPageControlInteractionState>;

  allowsContinuousInteraction: boolean;

  preferredIndicatorImage: UIImage;

  indicatorImageForPage(page: number): UIImage;

  setIndicatorImageForPage(image: UIImage | null, page: number): void;

  preferredCurrentPageIndicatorImage: UIImage;

  currentPageIndicatorImageForPage(page: number): UIImage;

  setCurrentPageIndicatorImageForPage(image: UIImage | null, page: number): void;

  sizeForNumberOfPages(pageCount: number): CGSize;

  defersCurrentPageDisplay: boolean;

  updateCurrentPageDisplay(): void;
}

declare class UIShapeResolutionContext extends NSObject {
  readonly contentShape: UIResolvedShape;
}

declare class UINib extends NSObject {
  static nibWithNibNameBundle(name: string, bundleOrNil: NSBundle | null): UINib;

  static nibWithDataBundle(data: NSData, bundleOrNil: NSBundle | null): UINib;

  instantiateWithOwnerOptions(ownerOrNil: interop.Object | null, optionsOrNil: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;
}

declare class UINavigationBar extends UIView implements NSCoding, UIBarPositioning {
  barStyle: interop.Enum<typeof UIBarStyle>;

  delegate: UINavigationBarDelegate;

  isTranslucent: boolean;

  pushNavigationItemAnimated(item: UINavigationItem, animated: boolean): void;

  popNavigationItemAnimated(animated: boolean): UINavigationItem;

  readonly topItem: UINavigationItem;

  readonly backItem: UINavigationItem;

  get items(): NSArray;
  set items(value: NSArray<interop.Object> | Array<interop.Object>);

  setItemsAnimated(items: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  prefersLargeTitles: boolean;

  readonly currentNSToolbarSection: interop.Enum<typeof UINavigationBarNSToolbarSection>;

  readonly behavioralStyle: interop.Enum<typeof UIBehavioralStyle>;

  preferredBehavioralStyle: interop.Enum<typeof UIBehavioralStyle>;

  tintColor: UIColor;

  barTintColor: UIColor;

  setBackgroundImageForBarPositionBarMetrics(backgroundImage: UIImage | null, barPosition: interop.Enum<typeof UIBarPosition>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForBarPositionBarMetrics(barPosition: interop.Enum<typeof UIBarPosition>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setBackgroundImageForBarMetrics(backgroundImage: UIImage | null, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForBarMetrics(barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  shadowImage: UIImage;

  get titleTextAttributes(): NSDictionary;
  set titleTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  get largeTitleTextAttributes(): NSDictionary;
  set largeTitleTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  setTitleVerticalPositionAdjustmentForBarMetrics(adjustment: number, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  titleVerticalPositionAdjustmentForBarMetrics(barMetrics: interop.Enum<typeof UIBarMetrics>): number;

  backIndicatorImage: UIImage;

  backIndicatorTransitionMaskImage: UIImage;

  standardAppearance: UINavigationBarAppearance;

  compactAppearance: UINavigationBarAppearance;

  scrollEdgeAppearance: UINavigationBarAppearance;

  compactScrollEdgeAppearance: UINavigationBarAppearance;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  readonly barPosition: interop.Enum<typeof UIBarPosition>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIInterpolatingMotionEffect extends UIMotionEffect {
  initWithKeyPathType(keyPath: string, type: interop.Enum<typeof UIInterpolatingMotionEffectType>): this;

  initWithCoder(coder: NSCoder): this;

  readonly keyPath: string;

  readonly type: interop.Enum<typeof UIInterpolatingMotionEffectType>;

  minimumRelativeValue: interop.Object;

  maximumRelativeValue: interop.Object;
}

declare class UICellAccessory extends NSObject implements NSCopying, NSSecureCoding {
  displayedState: interop.Enum<typeof UICellAccessoryDisplayedState>;

  isHidden: boolean;

  reservedLayoutWidth: number;

  tintColor: UIColor;

  initWithCoder(coder: NSCoder): this;

  init(): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UITabBar extends UIView {
  delegate: UITabBarDelegate;

  get items(): NSArray;
  set items(value: NSArray<interop.Object> | Array<interop.Object>);

  selectedItem: UITabBarItem;

  setItemsAnimated(items: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  beginCustomizingItems(items: NSArray<interop.Object> | Array<interop.Object>): void;

  endCustomizingAnimated(animated: boolean): boolean;

  readonly isCustomizing: boolean;

  tintColor: UIColor;

  barTintColor: UIColor;

  unselectedItemTintColor: UIColor;

  selectedImageTintColor: UIColor;

  backgroundImage: UIImage;

  selectionIndicatorImage: UIImage;

  shadowImage: UIImage;

  itemPositioning: interop.Enum<typeof UITabBarItemPositioning>;

  itemWidth: number;

  itemSpacing: number;

  barStyle: interop.Enum<typeof UIBarStyle>;

  isTranslucent: boolean;

  standardAppearance: UITabBarAppearance;

  scrollEdgeAppearance: UITabBarAppearance;
}

declare class UIResolvedShape extends NSObject implements NSCopying {
  readonly shape: UIShape;

  readonly boundingRect: CGRect;

  readonly path: UIBezierPath;

  shapeByApplyingInsets(insets: UIEdgeInsets): UIResolvedShape;

  shapeByApplyingInset(inset: number): UIResolvedShape;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIShape extends NSObject implements UIShapeProvider, NSCopying {
  static readonly rectShape: UIShape;

  static readonly capsuleShape: UIShape;

  static readonly circleShape: UIShape;

  static rectShapeWithCornerRadius<This extends abstract new (...args: any) => any>(this: This, cornerRadius: number): InstanceType<This>;

  static rectShapeWithCornerRadiusCornerCurve<This extends abstract new (...args: any) => any>(this: This, cornerRadius: number, cornerCurve: interop.Enum<typeof UICornerCurve>): InstanceType<This>;

  static rectShapeWithCornerRadiusCornerCurveMaskedCorners<This extends abstract new (...args: any) => any>(this: This, cornerRadius: number, cornerCurve: interop.Enum<typeof UICornerCurve>, maskedCorners: interop.Enum<typeof UIRectCorner>): InstanceType<This>;

  static fixedRectShapeWithRect<This extends abstract new (...args: any) => any>(this: This, rect: CGRect): InstanceType<This>;

  static fixedRectShapeWithRectCornerRadius<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, cornerRadius: number): InstanceType<This>;

  static fixedRectShapeWithRectCornerRadiusCornerCurveMaskedCorners<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, cornerRadius: number, cornerCurve: interop.Enum<typeof UICornerCurve>, maskedCorners: interop.Enum<typeof UIRectCorner>): InstanceType<This>;

  static shapeWithBezierPath<This extends abstract new (...args: any) => any>(this: This, path: UIBezierPath): InstanceType<This>;

  static shapeWithProvider<This extends abstract new (...args: any) => any>(this: This, provider: UIShapeProvider): InstanceType<This>;

  shapeByApplyingInsets(insets: UIEdgeInsets): UIShape;

  shapeByApplyingInset(inset: number): UIShape;

  resolvedShapeInContext(context: UIShapeResolutionContext): UIResolvedShape;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIFocusDebugger extends NSObject {
  static help(): UIFocusDebuggerOutput;

  static status(): UIFocusDebuggerOutput;

  static checkFocusabilityForItem(item: UIFocusItem): UIFocusDebuggerOutput;

  static simulateFocusUpdateRequestFromEnvironment(environment: UIFocusEnvironment): UIFocusDebuggerOutput;

  static focusGroupsForEnvironment(environment: UIFocusEnvironment): UIFocusDebuggerOutput;

  static preferredFocusEnvironmentsForEnvironment(environment: UIFocusEnvironment): UIFocusDebuggerOutput;
}

declare class UIFocusSystem extends NSObject {
  readonly focusedItem: UIFocusItem;

  static focusSystemForEnvironment(environment: UIFocusEnvironment): UIFocusSystem;

  requestFocusUpdateToEnvironment(environment: UIFocusEnvironment): void;

  updateFocusIfNeeded(): void;

  static environmentContainsEnvironment(environment: UIFocusEnvironment, otherEnvironment: UIFocusEnvironment): boolean;
}

declare class UIPrinterDestination extends NSObject implements NSSecureCoding {
  initWithURL(url: NSURL): this;

  URL: NSURL;

  displayName: string;

  txtRecord: NSData;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UISceneSizeRestrictions extends NSObject {
  minimumSize: CGSize;

  maximumSize: CGSize;

  allowsFullScreen: boolean;
}

declare class UICellAccessoryDelete extends UICellAccessory {
  backgroundColor: UIColor;

  actionHandler: () => void;
}

declare class UISceneOpenURLOptions extends NSObject {
  readonly sourceApplication: string;

  readonly annotation: interop.Object;

  readonly openInPlace: boolean;

  readonly eventAttribution: UIEventAttribution;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIMutableUserNotificationCategory extends UIUserNotificationCategory {
  // @ts-ignore MemberDecl.tsIgnore
  identifier: string;

  setActionsForContext(actions: NSArray<interop.Object> | Array<interop.Object> | null, context: interop.Enum<typeof UIUserNotificationActionContext>): void;
}

declare class UIGraphicsImageRendererFormat extends UIGraphicsRendererFormat {
  scale: number;

  opaque: boolean;

  prefersExtendedRange: boolean;

  readonly supportsHighDynamicRange: boolean;

  preferredRange: interop.Enum<typeof UIGraphicsImageRendererFormatRange>;

  static formatForTraitCollection<This extends abstract new (...args: any) => any>(this: This, traitCollection: UITraitCollection): InstanceType<This>;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIMutableApplicationShortcutItem extends UIApplicationShortcutItem {
  // @ts-ignore MemberDecl.tsIgnore
  type: string;

  // @ts-ignore MemberDecl.tsIgnore
  localizedTitle: string;

  // @ts-ignore MemberDecl.tsIgnore
  localizedSubtitle: string;

  // @ts-ignore MemberDecl.tsIgnore
  icon: UIApplicationShortcutIcon;

  // @ts-ignore MemberDecl.tsIgnore
  get userInfo(): NSDictionary;
  // @ts-ignore MemberDecl.tsIgnore
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  // @ts-ignore MemberDecl.tsIgnore
  targetContentIdentifier: interop.Object;
}

declare class UIApplicationShortcutItem extends NSObject implements NSCopying, NSMutableCopying {
  initWithTypeLocalizedTitleLocalizedSubtitleIconUserInfo(type: string, localizedTitle: string, localizedSubtitle: string | null, icon: UIApplicationShortcutIcon | null, userInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  initWithTypeLocalizedTitle(type: string, localizedTitle: string): this;

  readonly type: string;

  readonly localizedTitle: string;

  readonly localizedSubtitle: string;

  readonly icon: UIApplicationShortcutIcon;

  readonly userInfo: NSDictionary;

  readonly targetContentIdentifier: interop.Object;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UILargeContentViewerInteraction extends NSObject implements UIInteraction {
  initWithDelegate(delegate: UILargeContentViewerInteractionDelegate | null): this;

  readonly delegate: UILargeContentViewerInteractionDelegate;

  readonly gestureRecognizerForExclusionRelationship: UIGestureRecognizer;

  static readonly isEnabled: boolean;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UILabel extends UIView implements NSCoding, UIContentSizeCategoryAdjusting, UILetterformAwareAdjusting {
  text: string;

  font: UIFont;

  textColor: UIColor;

  preferredVibrancy: interop.Enum<typeof UILabelVibrancy>;

  shadowColor: UIColor;

  shadowOffset: CGSize;

  textAlignment: interop.Enum<typeof NSTextAlignment>;

  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  attributedText: NSAttributedString;

  highlightedTextColor: UIColor;

  isHighlighted: boolean;

  isUserInteractionEnabled: boolean;

  isEnabled: boolean;

  numberOfLines: number;

  adjustsFontSizeToFitWidth: boolean;

  baselineAdjustment: interop.Enum<typeof UIBaselineAdjustment>;

  minimumScaleFactor: number;

  allowsDefaultTighteningForTruncation: boolean;

  lineBreakStrategy: interop.Enum<typeof NSLineBreakStrategy>;

  textRectForBoundsLimitedToNumberOfLines(bounds: CGRect, numberOfLines: number): CGRect;

  drawTextInRect(rect: CGRect): void;

  preferredMaxLayoutWidth: number;

  showsExpansionTextWhenTruncated: boolean;

  minimumFontSize: number;

  adjustsLetterSpacingToFitWidth: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  adjustsFontForContentSizeCategory: boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  sizingRule: interop.Enum<typeof UILetterformAwareSizingRule>;
}

declare class UIDocumentProperties extends NSObject {
  initWithURL(url: NSURL): this;

  initWithMetadata(metadata: interop.Object): this;

  metadata: interop.Object;

  dragItemsProvider: (p1: UIDragSession) => NSArray;

  activityViewControllerProvider: () => UIActivityViewController;

  wantsIconRepresentation: boolean;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIInputViewController extends UIViewController implements UITextInputDelegate {
  // @ts-ignore MemberDecl.tsIgnore
  inputView: UIInputView;

  readonly textDocumentProxy: UITextDocumentProxy;

  primaryLanguage: string;

  hasDictationKey: boolean;

  readonly hasFullAccess: boolean;

  readonly needsInputModeSwitchKey: boolean;

  dismissKeyboard(): void;

  advanceToNextInputMode(): void;

  handleInputModeListFromViewWithEvent(view: UIView, event: UIEvent): void;

  requestSupplementaryLexiconWithCompletion(completionHandler: (p1: UILexicon) => void): void;

  selectionWillChange(textInput: UITextInput | null): void;

  selectionDidChange(textInput: UITextInput | null): void;

  textWillChange(textInput: UITextInput | null): void;

  textDidChange(textInput: UITextInput | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIInputView extends UIView {
  readonly inputViewStyle: interop.Enum<typeof UIInputViewStyle>;

  allowsSelfSizing: boolean;

  initWithFrameInputViewStyle(frame: CGRect, inputViewStyle: interop.Enum<typeof UIInputViewStyle>): this;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIImagePickerController extends UINavigationController implements NSCoding {
  static isSourceTypeAvailable(sourceType: interop.Enum<typeof UIImagePickerControllerSourceType>): boolean;

  static availableMediaTypesForSourceType(sourceType: interop.Enum<typeof UIImagePickerControllerSourceType>): NSArray;

  static isCameraDeviceAvailable(cameraDevice: interop.Enum<typeof UIImagePickerControllerCameraDevice>): boolean;

  static isFlashAvailableForCameraDevice(cameraDevice: interop.Enum<typeof UIImagePickerControllerCameraDevice>): boolean;

  static availableCaptureModesForCameraDevice(cameraDevice: interop.Enum<typeof UIImagePickerControllerCameraDevice>): NSArray;

  // @ts-ignore MemberDecl.tsIgnore
  delegate: UIImagePickerControllerDelegate;

  sourceType: interop.Enum<typeof UIImagePickerControllerSourceType>;

  get mediaTypes(): NSArray;
  set mediaTypes(value: NSArray<interop.Object> | Array<interop.Object>);

  allowsEditing: boolean;

  allowsImageEditing: boolean;

  imageExportPreset: interop.Enum<typeof UIImagePickerControllerImageURLExportPreset>;

  videoMaximumDuration: number;

  videoQuality: interop.Enum<typeof UIImagePickerControllerQualityType>;

  videoExportPreset: string;

  showsCameraControls: boolean;

  cameraOverlayView: UIView;

  cameraViewTransform: CGAffineTransform;

  takePicture(): void;

  startVideoCapture(): boolean;

  stopVideoCapture(): void;

  cameraCaptureMode: interop.Enum<typeof UIImagePickerControllerCameraCaptureMode>;

  cameraDevice: interop.Enum<typeof UIImagePickerControllerCameraDevice>;

  cameraFlashMode: interop.Enum<typeof UIImagePickerControllerCameraFlashMode>;

  encodeWithCoder(coder: NSCoder): void;

  // @ts-ignore MemberDecl.tsIgnore
  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UINavigationController extends UIViewController {
  initWithNavigationBarClassToolbarClass(navigationBarClass: interop.Object | null, toolbarClass: interop.Object | null): this;

  initWithRootViewController(rootViewController: UIViewController): this;

  initWithNibNameBundle(nibNameOrNil: string | null, nibBundleOrNil: NSBundle | null): this;

  // @ts-ignore MemberDecl.tsIgnore
  initWithCoder(aDecoder: NSCoder): this;

  pushViewControllerAnimated(viewController: UIViewController, animated: boolean): void;

  popViewControllerAnimated(animated: boolean): UIViewController;

  popToViewControllerAnimated(viewController: UIViewController, animated: boolean): NSArray;

  popToRootViewControllerAnimated(animated: boolean): NSArray;

  readonly topViewController: UIViewController;

  readonly visibleViewController: UIViewController;

  get viewControllers(): NSArray;
  set viewControllers(value: NSArray<interop.Object> | Array<interop.Object>);

  setViewControllersAnimated(viewControllers: NSArray<interop.Object> | Array<interop.Object>, animated: boolean): void;

  isNavigationBarHidden: boolean;

  setNavigationBarHiddenAnimated(hidden: boolean, animated: boolean): void;

  readonly navigationBar: UINavigationBar;

  isToolbarHidden: boolean;

  setToolbarHiddenAnimated(hidden: boolean, animated: boolean): void;

  readonly toolbar: UIToolbar;

  delegate: UINavigationControllerDelegate;

  readonly interactivePopGestureRecognizer: UIGestureRecognizer;

  showViewControllerSender(vc: UIViewController, sender: interop.Object | null): void;

  hidesBarsWhenKeyboardAppears: boolean;

  hidesBarsOnSwipe: boolean;

  readonly barHideOnSwipeGestureRecognizer: UIPanGestureRecognizer;

  hidesBarsWhenVerticallyCompact: boolean;

  hidesBarsOnTap: boolean;

  readonly barHideOnTapGestureRecognizer: UITapGestureRecognizer;
}

declare class UIImageAsset extends NSObject implements NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  imageWithConfiguration(configuration: UIImageConfiguration): UIImage;

  registerImageWithConfiguration(image: UIImage, configuration: UIImageConfiguration): void;

  unregisterImageWithConfiguration(configuration: UIImageConfiguration): void;

  imageWithTraitCollection(traitCollection: UITraitCollection): UIImage;

  registerImageWithTraitCollection(image: UIImage, traitCollection: UITraitCollection): void;

  unregisterImageWithTraitCollection(traitCollection: UITraitCollection): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIGraphicsImageRenderer extends UIGraphicsRenderer {
  initWithSize(size: CGSize): this;

  initWithSizeFormat(size: CGSize, format: UIGraphicsImageRendererFormat): this;

  // @ts-ignore MemberDecl.tsIgnore
  initWithBoundsFormat(bounds: CGRect, format: UIGraphicsImageRendererFormat): this;

  imageWithActions(actions: (p1: UIGraphicsImageRendererContext) => void): UIImage;

  PNGDataWithActions(actions: (p1: UIGraphicsImageRendererContext) => void): NSData;

  JPEGDataWithCompressionQualityActions(compressionQuality: number, actions: (p1: UIGraphicsImageRendererContext) => void): NSData;
}

declare class UIGraphicsRenderer extends NSObject {
  initWithBounds(bounds: CGRect): this;

  initWithBoundsFormat(bounds: CGRect, format: UIGraphicsRendererFormat): this;

  readonly format: UIGraphicsRendererFormat;

  readonly allowsImageOutput: boolean;

  static rendererContextClass(): interop.Object;

  static contextWithFormat(format: UIGraphicsRendererFormat): interop.Pointer;

  static prepareCGContextWithRendererContext(context: interop.PointerConvertible, rendererContext: UIGraphicsRendererContext): void;

  runDrawingActionsCompletionActionsError(drawingActions: (p1: UIGraphicsRendererContext) => void, completionActions: (p1: UIGraphicsRendererContext) => void | null, error: interop.PointerConvertible): boolean;
}

declare class UIGraphicsRendererFormat extends NSObject implements NSCopying {
  static defaultFormat<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static preferredFormat<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  readonly bounds: CGRect;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPreviewActionGroup extends NSObject implements NSCopying, UIPreviewActionItem {
  static actionGroupWithTitleStyleActions<This extends abstract new (...args: any) => any>(this: This, title: string, style: interop.Enum<typeof UIPreviewActionStyle>, actions: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  readonly title: string;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIManagedDocument extends UIDocument {
  static readonly persistentStoreName: string;

  readonly managedObjectContext: NSManagedObjectContext;

  readonly managedObjectModel: NSManagedObjectModel;

  get persistentStoreOptions(): NSDictionary;
  set persistentStoreOptions(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  modelConfiguration: string;

  configurePersistentStoreCoordinatorForURLOfTypeModelConfigurationStoreOptionsError(storeURL: NSURL, fileType: string, configuration: string | null, storeOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;

  persistentStoreTypeForFileType(fileType: string): string;

  readAdditionalContentFromURLError(absoluteURL: NSURL, error: interop.PointerConvertible): boolean;

  additionalContentForURLError(absoluteURL: NSURL, error: interop.PointerConvertible): interop.Object;

  writeAdditionalContentToURLOriginalContentsURLError(content: interop.Object, absoluteURL: NSURL, absoluteOriginalContentsURL: NSURL | null, error: interop.PointerConvertible): boolean;
}

declare class UIPrintServiceExtension extends NSObject {
  printerDestinationsForPrintInfo(printInfo: UIPrintInfo): NSArray;
}

declare class UICollectionViewController extends UIViewController implements UICollectionViewDelegate, UICollectionViewDataSource {
  initWithCollectionViewLayout(layout: UICollectionViewLayout): this;

  initWithNibNameBundle(nibNameOrNil: string | null, nibBundleOrNil: NSBundle | null): this;

  initWithCoder(coder: NSCoder): this;

  collectionView: UICollectionView;

  clearsSelectionOnViewWillAppear: boolean;

  useLayoutToLayoutNavigationTransitions: boolean;

  readonly collectionViewLayout: UICollectionViewLayout;

  installsStandardGestureForInteractiveMovement: boolean;

  collectionViewShouldHighlightItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewDidHighlightItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewDidUnhighlightItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewShouldSelectItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewShouldDeselectItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewDidSelectItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewDidDeselectItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewCanPerformPrimaryActionForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewPerformPrimaryActionForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewWillDisplayCellForItemAtIndexPath(collectionView: UICollectionView, cell: UICollectionViewCell, indexPath: NSIndexPath): void;

  collectionViewWillDisplaySupplementaryViewForElementKindAtIndexPath(collectionView: UICollectionView, view: UICollectionReusableView, elementKind: string, indexPath: NSIndexPath): void;

  collectionViewDidEndDisplayingCellForItemAtIndexPath(collectionView: UICollectionView, cell: UICollectionViewCell, indexPath: NSIndexPath): void;

  collectionViewDidEndDisplayingSupplementaryViewForElementOfKindAtIndexPath(collectionView: UICollectionView, view: UICollectionReusableView, elementKind: string, indexPath: NSIndexPath): void;

  collectionViewShouldShowMenuForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewCanPerformActionForItemAtIndexPathWithSender(collectionView: UICollectionView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): boolean;

  collectionViewPerformActionForItemAtIndexPathWithSender(collectionView: UICollectionView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): void;

  collectionViewTransitionLayoutForOldLayoutNewLayout(collectionView: UICollectionView, fromLayout: UICollectionViewLayout, toLayout: UICollectionViewLayout): UICollectionViewTransitionLayout;

  collectionViewCanFocusItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewShouldUpdateFocusInContext(collectionView: UICollectionView, context: UICollectionViewFocusUpdateContext): boolean;

  collectionViewDidUpdateFocusInContextWithAnimationCoordinator(collectionView: UICollectionView, context: UICollectionViewFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  indexPathForPreferredFocusedViewInCollectionView(collectionView: UICollectionView): NSIndexPath;

  collectionViewSelectionFollowsFocusForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewTargetIndexPathForMoveOfItemFromOriginalIndexPathAtCurrentIndexPathToProposedIndexPath(collectionView: UICollectionView, originalIndexPath: NSIndexPath, currentIndexPath: NSIndexPath, proposedIndexPath: NSIndexPath): NSIndexPath;

  collectionViewTargetIndexPathForMoveFromItemAtIndexPathToProposedIndexPath(collectionView: UICollectionView, currentIndexPath: NSIndexPath, proposedIndexPath: NSIndexPath): NSIndexPath;

  collectionViewTargetContentOffsetForProposedContentOffset(collectionView: UICollectionView, proposedContentOffset: CGPoint): CGPoint;

  collectionViewCanEditItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewShouldSpringLoadItemAtIndexPathWithContext(collectionView: UICollectionView, indexPath: NSIndexPath, context: UISpringLoadedInteractionContext): boolean;

  collectionViewShouldBeginMultipleSelectionInteractionAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewDidBeginMultipleSelectionInteractionAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): void;

  collectionViewDidEndMultipleSelectionInteraction(collectionView: UICollectionView): void;

  collectionViewContextMenuConfigurationForItemsAtIndexPathsPoint(collectionView: UICollectionView, indexPaths: NSArray<interop.Object> | Array<interop.Object>, point: CGPoint): UIContextMenuConfiguration;

  collectionViewContextMenuConfigurationHighlightPreviewForItemAtIndexPath(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, indexPath: NSIndexPath): UITargetedPreview;

  collectionViewContextMenuConfigurationDismissalPreviewForItemAtIndexPath(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, indexPath: NSIndexPath): UITargetedPreview;

  collectionViewWillPerformPreviewActionForMenuWithConfigurationAnimator(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating): void;

  collectionViewWillDisplayContextMenuWithConfigurationAnimator(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  collectionViewWillEndContextMenuInteractionWithConfigurationAnimator(collectionView: UICollectionView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  collectionViewSceneActivationConfigurationForItemAtIndexPathPoint(collectionView: UICollectionView, indexPath: NSIndexPath, point: CGPoint): UIWindowSceneActivationConfiguration;

  collectionViewContextMenuConfigurationForItemAtIndexPathPoint(collectionView: UICollectionView, indexPath: NSIndexPath, point: CGPoint): UIContextMenuConfiguration;

  collectionViewPreviewForHighlightingContextMenuWithConfiguration(collectionView: UICollectionView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  collectionViewPreviewForDismissingContextMenuWithConfiguration(collectionView: UICollectionView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  scrollViewDidScroll(scrollView: UIScrollView): void;

  scrollViewDidZoom(scrollView: UIScrollView): void;

  scrollViewWillBeginDragging(scrollView: UIScrollView): void;

  scrollViewWillEndDraggingWithVelocityTargetContentOffset(scrollView: UIScrollView, velocity: CGPoint, targetContentOffset: interop.PointerConvertible): void;

  scrollViewDidEndDraggingWillDecelerate(scrollView: UIScrollView, decelerate: boolean): void;

  scrollViewWillBeginDecelerating(scrollView: UIScrollView): void;

  scrollViewDidEndDecelerating(scrollView: UIScrollView): void;

  scrollViewDidEndScrollingAnimation(scrollView: UIScrollView): void;

  viewForZoomingInScrollView(scrollView: UIScrollView): UIView;

  scrollViewWillBeginZoomingWithView(scrollView: UIScrollView, view: UIView | null): void;

  scrollViewDidEndZoomingWithViewAtScale(scrollView: UIScrollView, view: UIView | null, scale: number): void;

  scrollViewShouldScrollToTop(scrollView: UIScrollView): boolean;

  scrollViewDidScrollToTop(scrollView: UIScrollView): void;

  scrollViewDidChangeAdjustedContentInset(scrollView: UIScrollView): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  collectionViewNumberOfItemsInSection(collectionView: UICollectionView, section: number): number;

  collectionViewCellForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): UICollectionViewCell;

  numberOfSectionsInCollectionView(collectionView: UICollectionView): number;

  collectionViewViewForSupplementaryElementOfKindAtIndexPath(collectionView: UICollectionView, kind: string, indexPath: NSIndexPath): UICollectionReusableView;

  collectionViewCanMoveItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewMoveItemAtIndexPathToIndexPath(collectionView: UICollectionView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;

  indexTitlesForCollectionView(collectionView: UICollectionView): NSArray;

  collectionViewIndexPathForIndexTitleAtIndex(collectionView: UICollectionView, title: string, index: number): NSIndexPath;
}

declare class UIFontPickerViewControllerConfiguration extends NSObject implements NSCopying {
  includeFaces: boolean;

  displayUsingSystemFont: boolean;

  filteredTraits: interop.Enum<typeof UIFontDescriptorSymbolicTraits>;

  filteredLanguagesPredicate: NSPredicate;

  static filterPredicateForFilteredLanguages(filteredLanguages: NSArray<interop.Object> | Array<interop.Object>): NSPredicate;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIVisualEffectView extends UIView implements NSSecureCoding {
  readonly contentView: UIView;

  effect: UIVisualEffect;

  initWithEffect(effect: UIVisualEffect | null): this;

  initWithCoder(coder: NSCoder): this;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIPointerStyle extends UIHoverStyle implements NSCopying {
  get accessories(): NSArray;
  set accessories(value: NSArray<interop.Object> | Array<interop.Object>);

  // @ts-ignore MemberDecl.tsIgnore
  static styleWithEffectShape<This extends abstract new (...args: any) => any>(this: This, effect: UIPointerEffect, shape: UIPointerShape | null): InstanceType<This>;

  static styleWithShapeConstrainedAxes<This extends abstract new (...args: any) => any>(this: This, shape: UIPointerShape, axes: interop.Enum<typeof UIAxis>): InstanceType<This>;

  static hiddenPointerStyle<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static systemPointerStyle<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITableViewController extends UIViewController implements UITableViewDelegate, UITableViewDataSource {
  initWithStyle(style: interop.Enum<typeof UITableViewStyle>): this;

  initWithNibNameBundle(nibNameOrNil: string | null, nibBundleOrNil: NSBundle | null): this;

  initWithCoder(coder: NSCoder): this;

  tableView: UITableView;

  clearsSelectionOnViewWillAppear: boolean;

  refreshControl: UIRefreshControl;

  tableViewWillDisplayCellForRowAtIndexPath(tableView: UITableView, cell: UITableViewCell, indexPath: NSIndexPath): void;

  tableViewWillDisplayHeaderViewForSection(tableView: UITableView, view: UIView, section: number): void;

  tableViewWillDisplayFooterViewForSection(tableView: UITableView, view: UIView, section: number): void;

  tableViewDidEndDisplayingCellForRowAtIndexPath(tableView: UITableView, cell: UITableViewCell, indexPath: NSIndexPath): void;

  tableViewDidEndDisplayingHeaderViewForSection(tableView: UITableView, view: UIView, section: number): void;

  tableViewDidEndDisplayingFooterViewForSection(tableView: UITableView, view: UIView, section: number): void;

  tableViewHeightForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): number;

  tableViewHeightForHeaderInSection(tableView: UITableView, section: number): number;

  tableViewHeightForFooterInSection(tableView: UITableView, section: number): number;

  tableViewEstimatedHeightForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): number;

  tableViewEstimatedHeightForHeaderInSection(tableView: UITableView, section: number): number;

  tableViewEstimatedHeightForFooterInSection(tableView: UITableView, section: number): number;

  tableViewViewForHeaderInSection(tableView: UITableView, section: number): UIView;

  tableViewViewForFooterInSection(tableView: UITableView, section: number): UIView;

  tableViewAccessoryTypeForRowWithIndexPath(tableView: UITableView, indexPath: NSIndexPath): interop.Enum<typeof UITableViewCellAccessoryType>;

  tableViewAccessoryButtonTappedForRowWithIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewShouldHighlightRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewDidHighlightRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidUnhighlightRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewWillSelectRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): NSIndexPath;

  tableViewWillDeselectRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): NSIndexPath;

  tableViewDidSelectRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidDeselectRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewCanPerformPrimaryActionForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewPerformPrimaryActionForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewEditingStyleForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): interop.Enum<typeof UITableViewCellEditingStyle>;

  tableViewTitleForDeleteConfirmationButtonForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): string;

  tableViewEditActionsForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): NSArray;

  tableViewLeadingSwipeActionsConfigurationForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UISwipeActionsConfiguration;

  tableViewTrailingSwipeActionsConfigurationForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UISwipeActionsConfiguration;

  tableViewShouldIndentWhileEditingRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewWillBeginEditingRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidEndEditingRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath | null): void;

  tableViewTargetIndexPathForMoveFromRowAtIndexPathToProposedIndexPath(tableView: UITableView, sourceIndexPath: NSIndexPath, proposedDestinationIndexPath: NSIndexPath): NSIndexPath;

  tableViewIndentationLevelForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): number;

  tableViewShouldShowMenuForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewCanPerformActionForRowAtIndexPathWithSender(tableView: UITableView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): boolean;

  tableViewPerformActionForRowAtIndexPathWithSender(tableView: UITableView, action: string, indexPath: NSIndexPath, sender: interop.Object | null): void;

  tableViewCanFocusRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewShouldUpdateFocusInContext(tableView: UITableView, context: UITableViewFocusUpdateContext): boolean;

  tableViewDidUpdateFocusInContextWithAnimationCoordinator(tableView: UITableView, context: UITableViewFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  indexPathForPreferredFocusedViewInTableView(tableView: UITableView): NSIndexPath;

  tableViewSelectionFollowsFocusForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewShouldSpringLoadRowAtIndexPathWithContext(tableView: UITableView, indexPath: NSIndexPath, context: UISpringLoadedInteractionContext): boolean;

  tableViewShouldBeginMultipleSelectionInteractionAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewDidBeginMultipleSelectionInteractionAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): void;

  tableViewDidEndMultipleSelectionInteraction(tableView: UITableView): void;

  tableViewContextMenuConfigurationForRowAtIndexPathPoint(tableView: UITableView, indexPath: NSIndexPath, point: CGPoint): UIContextMenuConfiguration;

  tableViewPreviewForHighlightingContextMenuWithConfiguration(tableView: UITableView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  tableViewPreviewForDismissingContextMenuWithConfiguration(tableView: UITableView, configuration: UIContextMenuConfiguration): UITargetedPreview;

  tableViewWillPerformPreviewActionForMenuWithConfigurationAnimator(tableView: UITableView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionCommitAnimating): void;

  tableViewWillDisplayContextMenuWithConfigurationAnimator(tableView: UITableView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  tableViewWillEndContextMenuInteractionWithConfigurationAnimator(tableView: UITableView, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  scrollViewDidScroll(scrollView: UIScrollView): void;

  scrollViewDidZoom(scrollView: UIScrollView): void;

  scrollViewWillBeginDragging(scrollView: UIScrollView): void;

  scrollViewWillEndDraggingWithVelocityTargetContentOffset(scrollView: UIScrollView, velocity: CGPoint, targetContentOffset: interop.PointerConvertible): void;

  scrollViewDidEndDraggingWillDecelerate(scrollView: UIScrollView, decelerate: boolean): void;

  scrollViewWillBeginDecelerating(scrollView: UIScrollView): void;

  scrollViewDidEndDecelerating(scrollView: UIScrollView): void;

  scrollViewDidEndScrollingAnimation(scrollView: UIScrollView): void;

  viewForZoomingInScrollView(scrollView: UIScrollView): UIView;

  scrollViewWillBeginZoomingWithView(scrollView: UIScrollView, view: UIView | null): void;

  scrollViewDidEndZoomingWithViewAtScale(scrollView: UIScrollView, view: UIView | null, scale: number): void;

  scrollViewShouldScrollToTop(scrollView: UIScrollView): boolean;

  scrollViewDidScrollToTop(scrollView: UIScrollView): void;

  scrollViewDidChangeAdjustedContentInset(scrollView: UIScrollView): void;

  tableViewNumberOfRowsInSection(tableView: UITableView, section: number): number;

  tableViewCellForRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): UITableViewCell;

  numberOfSectionsInTableView(tableView: UITableView): number;

  tableViewTitleForHeaderInSection(tableView: UITableView, section: number): string;

  tableViewTitleForFooterInSection(tableView: UITableView, section: number): string;

  tableViewCanEditRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  tableViewCanMoveRowAtIndexPath(tableView: UITableView, indexPath: NSIndexPath): boolean;

  sectionIndexTitlesForTableView(tableView: UITableView): NSArray;

  tableViewSectionForSectionIndexTitleAtIndex(tableView: UITableView, title: string, index: number): number;

  tableViewCommitEditingStyleForRowAtIndexPath(tableView: UITableView, editingStyle: interop.Enum<typeof UITableViewCellEditingStyle>, indexPath: NSIndexPath): void;

  tableViewMoveRowAtIndexPathToIndexPath(tableView: UITableView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;
}

declare class UIColor extends NSObject implements NSSecureCoding, NSCopying {
  static colorWithWhiteAlpha(white: number, alpha: number): UIColor;

  static colorWithHueSaturationBrightnessAlpha(hue: number, saturation: number, brightness: number, alpha: number): UIColor;

  static colorWithRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): UIColor;

  static colorWithDisplayP3RedGreenBlueAlpha(displayP3Red: number, green: number, blue: number, alpha: number): UIColor;

  static colorWithCGColor(cgColor: interop.PointerConvertible): UIColor;

  static colorWithPatternImage(image: UIImage): UIColor;

  static colorWithCIColor(ciColor: CIColor): UIColor;

  initWithWhiteAlpha(white: number, alpha: number): this;

  initWithHueSaturationBrightnessAlpha(hue: number, saturation: number, brightness: number, alpha: number): this;

  initWithRedGreenBlueAlpha(red: number, green: number, blue: number, alpha: number): this;

  initWithDisplayP3RedGreenBlueAlpha(displayP3Red: number, green: number, blue: number, alpha: number): this;

  initWithCGColor(cgColor: interop.PointerConvertible): this;

  initWithPatternImage(image: UIImage): this;

  initWithCIColor(ciColor: CIColor): this;

  static readonly blackColor: UIColor;

  static readonly darkGrayColor: UIColor;

  static readonly lightGrayColor: UIColor;

  static readonly whiteColor: UIColor;

  static readonly grayColor: UIColor;

  static readonly redColor: UIColor;

  static readonly greenColor: UIColor;

  static readonly blueColor: UIColor;

  static readonly cyanColor: UIColor;

  static readonly yellowColor: UIColor;

  static readonly magentaColor: UIColor;

  static readonly orangeColor: UIColor;

  static readonly purpleColor: UIColor;

  static readonly brownColor: UIColor;

  static readonly clearColor: UIColor;

  set(): void;

  setFill(): void;

  setStroke(): void;

  getWhiteAlpha(white: interop.PointerConvertible, alpha: interop.PointerConvertible): boolean;

  getHueSaturationBrightnessAlpha(hue: interop.PointerConvertible, saturation: interop.PointerConvertible, brightness: interop.PointerConvertible, alpha: interop.PointerConvertible): boolean;

  getRedGreenBlueAlpha(red: interop.PointerConvertible, green: interop.PointerConvertible, blue: interop.PointerConvertible, alpha: interop.PointerConvertible): boolean;

  colorWithAlphaComponent(alpha: number): UIColor;

  readonly CGColor: interop.Pointer;

  readonly CIColor: CIColor;

  static colorNamed(name: string): UIColor;

  static colorNamedInBundleCompatibleWithTraitCollection(name: string, bundle: NSBundle | null, traitCollection: UITraitCollection | null): UIColor;

  static colorWithDynamicProvider(dynamicProvider: (p1: UITraitCollection) => UIColor): UIColor;

  initWithDynamicProvider(dynamicProvider: (p1: UITraitCollection) => UIColor): this;

  resolvedColorWithTraitCollection(traitCollection: UITraitCollection): UIColor;

  static readonly systemRedColor: UIColor;

  static readonly systemGreenColor: UIColor;

  static readonly systemBlueColor: UIColor;

  static readonly systemOrangeColor: UIColor;

  static readonly systemYellowColor: UIColor;

  static readonly systemPinkColor: UIColor;

  static readonly systemPurpleColor: UIColor;

  static readonly systemTealColor: UIColor;

  static readonly systemIndigoColor: UIColor;

  static readonly systemBrownColor: UIColor;

  static readonly systemMintColor: UIColor;

  static readonly systemCyanColor: UIColor;

  static readonly systemGrayColor: UIColor;

  static readonly systemGray2Color: UIColor;

  static readonly systemGray3Color: UIColor;

  static readonly systemGray4Color: UIColor;

  static readonly systemGray5Color: UIColor;

  static readonly systemGray6Color: UIColor;

  static readonly tintColor: UIColor;

  static readonly labelColor: UIColor;

  static readonly secondaryLabelColor: UIColor;

  static readonly tertiaryLabelColor: UIColor;

  static readonly quaternaryLabelColor: UIColor;

  static readonly linkColor: UIColor;

  static readonly placeholderTextColor: UIColor;

  static readonly separatorColor: UIColor;

  static readonly opaqueSeparatorColor: UIColor;

  static readonly systemBackgroundColor: UIColor;

  static readonly secondarySystemBackgroundColor: UIColor;

  static readonly tertiarySystemBackgroundColor: UIColor;

  static readonly systemGroupedBackgroundColor: UIColor;

  static readonly secondarySystemGroupedBackgroundColor: UIColor;

  static readonly tertiarySystemGroupedBackgroundColor: UIColor;

  static readonly systemFillColor: UIColor;

  static readonly secondarySystemFillColor: UIColor;

  static readonly tertiarySystemFillColor: UIColor;

  static readonly quaternarySystemFillColor: UIColor;

  static readonly lightTextColor: UIColor;

  static readonly darkTextColor: UIColor;

  static readonly groupTableViewBackgroundColor: UIColor;

  static readonly viewFlipsideBackgroundColor: UIColor;

  static readonly scrollViewTexturedBackgroundColor: UIColor;

  static readonly underPageBackgroundColor: UIColor;

  readonly accessibilityName: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UITargetedDragPreview extends UITargetedPreview {
  // @ts-ignore MemberDecl.tsIgnore
  retargetedPreviewWithTarget(newTarget: UIDragPreviewTarget): UITargetedDragPreview;

  static previewForURLTarget<This extends abstract new (...args: any) => any>(this: This, url: NSURL, target: UIDragPreviewTarget): InstanceType<This>;

  static previewForURLTitleTarget<This extends abstract new (...args: any) => any>(this: This, url: NSURL, title: string | null, target: UIDragPreviewTarget): InstanceType<This>;
}

declare class UISpringLoadedInteraction extends NSObject implements UIInteraction {
  initWithInteractionBehaviorInteractionEffectActivationHandler(interactionBehavior: UISpringLoadedInteractionBehavior | null, interactionEffect: UISpringLoadedInteractionEffect | null, handler: (p1: UISpringLoadedInteraction, p2: UISpringLoadedInteractionContext) => void): this;

  initWithActivationHandler(handler: (p1: UISpringLoadedInteraction, p2: UISpringLoadedInteractionContext) => void): this;

  readonly interactionBehavior: UISpringLoadedInteractionBehavior;

  readonly interactionEffect: UISpringLoadedInteractionEffect;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIVisualEffect extends NSObject implements NSCopying, NSSecureCoding {
  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIDocumentPickerExtensionViewController extends UIViewController {
  dismissGrantingAccessToURL(url: NSURL | null): void;

  prepareForPresentationInMode(mode: interop.Enum<typeof UIDocumentPickerMode>): void;

  readonly documentPickerMode: interop.Enum<typeof UIDocumentPickerMode>;

  readonly originalURL: NSURL;

  readonly validTypes: NSArray;

  readonly providerIdentifier: string;

  readonly documentStorageURL: NSURL;
}

declare class UIDocumentMenuViewController extends UIViewController {
  initWithDocumentTypesInMode(allowedUTIs: NSArray<interop.Object> | Array<interop.Object>, mode: interop.Enum<typeof UIDocumentPickerMode>): this;

  initWithURLInMode(url: NSURL, mode: interop.Enum<typeof UIDocumentPickerMode>): this;

  initWithCoder(coder: NSCoder): this;

  addOptionWithTitleImageOrderHandler(title: string, image: UIImage | null, order: interop.Enum<typeof UIDocumentMenuOrder>, handler: () => void): void;

  delegate: UIDocumentMenuDelegate;
}

declare class UIGraphicsPDFRendererContext extends UIGraphicsRendererContext {
  readonly pdfContextBounds: CGRect;

  beginPage(): void;

  beginPageWithBoundsPageInfo(bounds: CGRect, pageInfo: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;

  setURLForRect(url: NSURL, rect: CGRect): void;

  addDestinationWithNameAtPoint(name: string, point: CGPoint): void;

  setDestinationWithNameForRect(name: string, rect: CGRect): void;
}

declare class NSTextAttachmentViewProvider extends NSObject {
  initWithTextAttachmentParentViewTextLayoutManagerLocation(textAttachment: NSTextAttachment, parentView: UIView | null, textLayoutManager: NSTextLayoutManager | null, location: NSTextLocation): this;

  readonly textAttachment: NSTextAttachment | null;

  readonly textLayoutManager: NSTextLayoutManager;

  readonly location: NSTextLocation;

  view: UIView;

  loadView(): void;

  tracksTextAttachmentViewBounds: boolean;

  attachmentBoundsForAttributesLocationTextContainerProposedLineFragmentPosition(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, location: NSTextLocation, textContainer: NSTextContainer | null, proposedLineFragment: CGRect, position: CGPoint): CGRect;
}

declare class UIDocumentPickerViewController extends UIViewController {
  initWithDocumentTypesInMode(allowedUTIs: NSArray<interop.Object> | Array<interop.Object>, mode: interop.Enum<typeof UIDocumentPickerMode>): this;

  initForOpeningContentTypesAsCopy(contentTypes: NSArray<interop.Object> | Array<interop.Object>, asCopy: boolean): this;

  initForOpeningContentTypes(contentTypes: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithCoder(coder: NSCoder): this;

  initWithURLInMode(url: NSURL, mode: interop.Enum<typeof UIDocumentPickerMode>): this;

  initWithURLsInMode(urls: NSArray<interop.Object> | Array<interop.Object>, mode: interop.Enum<typeof UIDocumentPickerMode>): this;

  initForExportingURLsAsCopy(urls: NSArray<interop.Object> | Array<interop.Object>, asCopy: boolean): this;

  initForExportingURLs(urls: NSArray<interop.Object> | Array<interop.Object>): this;

  delegate: UIDocumentPickerDelegate;

  readonly documentPickerMode: interop.Enum<typeof UIDocumentPickerMode>;

  allowsMultipleSelection: boolean;

  shouldShowFileExtensions: boolean;

  directoryURL: NSURL;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIResponder extends NSObject implements UIResponderStandardEditActions {
  readonly nextResponder: UIResponder;

  readonly canBecomeFirstResponder: boolean;

  becomeFirstResponder(): boolean;

  readonly canResignFirstResponder: boolean;

  resignFirstResponder(): boolean;

  readonly isFirstResponder: boolean;

  touchesBeganWithEvent(touches: NSSet, event: UIEvent | null): void;

  touchesMovedWithEvent(touches: NSSet, event: UIEvent | null): void;

  touchesEndedWithEvent(touches: NSSet, event: UIEvent | null): void;

  touchesCancelledWithEvent(touches: NSSet, event: UIEvent | null): void;

  touchesEstimatedPropertiesUpdated(touches: NSSet): void;

  pressesBeganWithEvent(presses: NSSet, event: UIPressesEvent | null): void;

  pressesChangedWithEvent(presses: NSSet, event: UIPressesEvent | null): void;

  pressesEndedWithEvent(presses: NSSet, event: UIPressesEvent | null): void;

  pressesCancelledWithEvent(presses: NSSet, event: UIPressesEvent | null): void;

  motionBeganWithEvent(motion: interop.Enum<typeof UIEventSubtype>, event: UIEvent | null): void;

  motionEndedWithEvent(motion: interop.Enum<typeof UIEventSubtype>, event: UIEvent | null): void;

  motionCancelledWithEvent(motion: interop.Enum<typeof UIEventSubtype>, event: UIEvent | null): void;

  remoteControlReceivedWithEvent(event: UIEvent | null): void;

  canPerformActionWithSender(action: string, sender: interop.Object | null): boolean;

  targetForActionWithSender(action: string, sender: interop.Object | null): interop.Object;

  buildMenuWithBuilder(builder: UIMenuBuilder): void;

  validateCommand(command: UICommand): void;

  readonly undoManager: NSUndoManager;

  readonly editingInteractionConfiguration: interop.Enum<typeof UIEditingInteractionConfiguration>;

  readonly keyCommands: NSArray;

  readonly inputView: UIView;

  readonly inputAccessoryView: UIView;

  readonly inputAssistantItem: UITextInputAssistantItem;

  readonly inputViewController: UIInputViewController;

  readonly inputAccessoryViewController: UIInputViewController;

  readonly textInputMode: UITextInputMode;

  readonly textInputContextIdentifier: string;

  static clearTextInputContextIdentifier(identifier: string): void;

  reloadInputViews(): void;

  userActivity: NSUserActivity;

  updateUserActivityState(activity: NSUserActivity): void;

  restoreUserActivityState(activity: NSUserActivity): void;

  captureTextFromCamera(sender: interop.Object | null): void;

  activityItemsConfiguration: UIActivityItemsConfigurationReading;

  cut(sender: interop.Object | null): void;

  // @ts-ignore MemberDecl.tsIgnore
  copy(sender: interop.Object | null): void;

  paste(sender: interop.Object | null): void;

  pasteAndMatchStyle(sender: interop.Object | null): void;

  pasteAndGo(sender: interop.Object | null): void;

  pasteAndSearch(sender: interop.Object | null): void;

  select(sender: interop.Object | null): void;

  selectAll(sender: interop.Object | null): void;

  delete(sender: interop.Object | null): void;

  makeTextWritingDirectionLeftToRight(sender: interop.Object | null): void;

  makeTextWritingDirectionRightToLeft(sender: interop.Object | null): void;

  toggleBoldface(sender: interop.Object | null): void;

  toggleItalics(sender: interop.Object | null): void;

  toggleUnderline(sender: interop.Object | null): void;

  increaseSize(sender: interop.Object | null): void;

  decreaseSize(sender: interop.Object | null): void;

  find(sender: interop.Object | null): void;

  findAndReplace(sender: interop.Object | null): void;

  findNext(sender: interop.Object | null): void;

  findPrevious(sender: interop.Object | null): void;

  useSelectionForFind(sender: interop.Object | null): void;

  updateTextAttributesWithConversionHandler(conversionHandler: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => NSDictionary): void;

  print(sender: interop.Object | null): void;

  rename(sender: interop.Object | null): void;

  duplicate(sender: interop.Object | null): void;

  move(sender: interop.Object | null): void;

  export(sender: interop.Object | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIGraphicsPDFRendererFormat extends UIGraphicsRendererFormat {
  get documentInfo(): NSDictionary;
  set documentInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);
}

declare class UIDocumentViewController extends UIViewController {
  initWithDocument(document: UIDocument | null): this;

  document: UIDocument;

  navigationItemDidUpdate(): void;

  openDocumentWithCompletionHandler(completionHandler: (p1: boolean) => void): void;

  documentDidOpen(): void;

  readonly undoRedoItemGroup: UIBarButtonItemGroup;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UISearchBar extends UIView implements UIBarPositioning, UITextInputTraits, UILookToDictateCapable {
  init(): this;

  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  barStyle: interop.Enum<typeof UIBarStyle>;

  delegate: UISearchBarDelegate;

  text: string;

  prompt: string;

  placeholder: string;

  showsBookmarkButton: boolean;

  readonly searchTextField: UISearchTextField;

  showsCancelButton: boolean;

  showsSearchResultsButton: boolean;

  isSearchResultsButtonSelected: boolean;

  setShowsCancelButtonAnimated(showsCancelButton: boolean, animated: boolean): void;

  readonly inputAssistantItem: UITextInputAssistantItem;

  tintColor: UIColor;

  barTintColor: UIColor;

  searchBarStyle: interop.Enum<typeof UISearchBarStyle>;

  isTranslucent: boolean;

  get scopeButtonTitles(): NSArray;
  set scopeButtonTitles(value: NSArray<interop.Object> | Array<interop.Object>);

  selectedScopeButtonIndex: number;

  showsScopeBar: boolean;

  setShowsScopeBarAnimated(show: boolean, animate: boolean): void;

  // @ts-ignore MemberDecl.tsIgnore
  inputAccessoryView: UIView;

  isEnabled: boolean;

  backgroundImage: UIImage;

  scopeBarBackgroundImage: UIImage;

  setBackgroundImageForBarPositionBarMetrics(backgroundImage: UIImage | null, barPosition: interop.Enum<typeof UIBarPosition>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForBarPositionBarMetrics(barPosition: interop.Enum<typeof UIBarPosition>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setSearchFieldBackgroundImageForState(backgroundImage: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  searchFieldBackgroundImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  setImageForSearchBarIconState(iconImage: UIImage | null, icon: interop.Enum<typeof UISearchBarIcon>, state: interop.Enum<typeof UIControlState>): void;

  imageForSearchBarIconState(icon: interop.Enum<typeof UISearchBarIcon>, state: interop.Enum<typeof UIControlState>): UIImage;

  setScopeBarButtonBackgroundImageForState(backgroundImage: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  scopeBarButtonBackgroundImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  setScopeBarButtonDividerImageForLeftSegmentStateRightSegmentState(dividerImage: UIImage | null, leftState: interop.Enum<typeof UIControlState>, rightState: interop.Enum<typeof UIControlState>): void;

  scopeBarButtonDividerImageForLeftSegmentStateRightSegmentState(leftState: interop.Enum<typeof UIControlState>, rightState: interop.Enum<typeof UIControlState>): UIImage;

  setScopeBarButtonTitleTextAttributesForState(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, state: interop.Enum<typeof UIControlState>): void;

  scopeBarButtonTitleTextAttributesForState(state: interop.Enum<typeof UIControlState>): NSDictionary;

  searchFieldBackgroundPositionAdjustment: UIOffset;

  searchTextPositionAdjustment: UIOffset;

  setPositionAdjustmentForSearchBarIcon(adjustment: UIOffset, icon: interop.Enum<typeof UISearchBarIcon>): void;

  positionAdjustmentForSearchBarIcon(icon: interop.Enum<typeof UISearchBarIcon>): UIOffset;

  isLookToDictateEnabled: boolean;

  readonly barPosition: interop.Enum<typeof UIBarPosition>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  autocapitalizationType: interop.Enum<typeof UITextAutocapitalizationType>;

  autocorrectionType: interop.Enum<typeof UITextAutocorrectionType>;

  spellCheckingType: interop.Enum<typeof UITextSpellCheckingType>;

  smartQuotesType: interop.Enum<typeof UITextSmartQuotesType>;

  smartDashesType: interop.Enum<typeof UITextSmartDashesType>;

  smartInsertDeleteType: interop.Enum<typeof UITextSmartInsertDeleteType>;

  inlinePredictionType: interop.Enum<typeof UITextInlinePredictionType>;

  keyboardType: interop.Enum<typeof UIKeyboardType>;

  keyboardAppearance: interop.Enum<typeof UIKeyboardAppearance>;

  returnKeyType: interop.Enum<typeof UIReturnKeyType>;

  enablesReturnKeyAutomatically: boolean;

  isSecureTextEntry: boolean;

  textContentType: string;

  passwordRules: UITextInputPasswordRules;
}

declare class UIDocument extends NSObject implements NSFilePresenter, NSProgressReporting {
  initWithFileURL(url: NSURL): this;

  readonly fileURL: NSURL;

  readonly localizedName: string;

  readonly fileType: string;

  fileModificationDate: NSDate;

  readonly documentState: interop.Enum<typeof UIDocumentState>;

  readonly progress: NSProgress;

  openWithCompletionHandler(completionHandler: (p1: boolean) => void | null): void;

  closeWithCompletionHandler(completionHandler: (p1: boolean) => void | null): void;

  loadFromContentsOfTypeError(contents: interop.Object, typeName: string | null, outError: interop.PointerConvertible): boolean;

  contentsForTypeError(typeName: string, outError: interop.PointerConvertible): interop.Object;

  disableEditing(): void;

  enableEditing(): void;

  undoManager: NSUndoManager;

  readonly hasUnsavedChanges: boolean;

  updateChangeCount(change: interop.Enum<typeof UIDocumentChangeKind>): void;

  changeCountTokenForSaveOperation(saveOperation: interop.Enum<typeof UIDocumentSaveOperation>): interop.Object;

  updateChangeCountWithTokenForSaveOperation(changeCountToken: interop.Object, saveOperation: interop.Enum<typeof UIDocumentSaveOperation>): void;

  saveToURLForSaveOperationCompletionHandler(url: NSURL, saveOperation: interop.Enum<typeof UIDocumentSaveOperation>, completionHandler: (p1: boolean) => void | null): void;

  autosaveWithCompletionHandler(completionHandler: (p1: boolean) => void | null): void;

  readonly savingFileType: string;

  fileNameExtensionForTypeSaveOperation(typeName: string | null, saveOperation: interop.Enum<typeof UIDocumentSaveOperation>): string;

  writeContentsAndAttributesSafelyToURLForSaveOperationError(contents: interop.Object, additionalFileAttributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, url: NSURL, saveOperation: interop.Enum<typeof UIDocumentSaveOperation>, outError: interop.PointerConvertible): boolean;

  writeContentsToURLForSaveOperationOriginalContentsURLError(contents: interop.Object, url: NSURL, saveOperation: interop.Enum<typeof UIDocumentSaveOperation>, originalContentsURL: NSURL | null, outError: interop.PointerConvertible): boolean;

  fileAttributesToWriteToURLForSaveOperationError(url: NSURL, saveOperation: interop.Enum<typeof UIDocumentSaveOperation>, outError: interop.PointerConvertible): NSDictionary;

  readFromURLError(url: NSURL, outError: interop.PointerConvertible): boolean;

  performAsynchronousFileAccessUsingBlock(block: () => void): void;

  handleErrorUserInteractionPermitted(error: NSError, userInteractionPermitted: boolean): void;

  finishedHandlingErrorRecovered(error: NSError, recovered: boolean): void;

  userInteractionNoLongerPermittedForError(error: NSError): void;

  revertToContentsOfURLCompletionHandler(url: NSURL, completionHandler: (p1: boolean) => void | null): void;

  userActivity: NSUserActivity;

  updateUserActivityState(userActivity: NSUserActivity): void;

  restoreUserActivityState(userActivity: NSUserActivity): void;

  readonly presentedItemURL: NSURL;

  readonly presentedItemOperationQueue: NSOperationQueue;

  relinquishPresentedItemToReader(reader: (p1: () => void) => void | null): void;

  relinquishPresentedItemToWriter(writer: (p1: () => void) => void | null): void;

  savePresentedItemChangesWithCompletionHandler(completionHandler: (p1: NSError) => void | null): void;

  accommodatePresentedItemDeletionWithCompletionHandler(completionHandler: (p1: NSError) => void | null): void;

  accommodatePresentedItemEvictionWithCompletionHandler(completionHandler: (p1: NSError) => void | null): void;

  presentedItemDidMoveToURL(newURL: NSURL): void;

  presentedItemDidChange(): void;

  presentedItemDidChangeUbiquityAttributes(attributes: NSSet): void;

  readonly observedPresentedItemUbiquityAttributes: NSSet;

  presentedItemDidGainVersion(version: NSFileVersion): void;

  presentedItemDidLoseVersion(version: NSFileVersion): void;

  presentedItemDidResolveConflictVersion(version: NSFileVersion): void;

  accommodatePresentedSubitemDeletionAtURLCompletionHandler(url: NSURL, completionHandler: (p1: NSError) => void | null): void;

  presentedSubitemDidAppearAtURL(url: NSURL): void;

  presentedSubitemAtURLDidMoveToURL(oldURL: NSURL, newURL: NSURL): void;

  presentedSubitemDidChangeAtURL(url: NSURL): void;

  presentedSubitemAtURLDidGainVersion(url: NSURL, version: NSFileVersion): void;

  presentedSubitemAtURLDidLoseVersion(url: NSURL, version: NSFileVersion): void;

  presentedSubitemAtURLDidResolveConflictVersion(url: NSURL, version: NSFileVersion): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIWindowSceneGeometryPreferences extends NSObject {
}

declare class UIPopoverBackgroundView extends UIView implements UIPopoverBackgroundViewMethods {
  arrowOffset: number;

  arrowDirection: interop.Enum<typeof UIPopoverArrowDirection>;

  static readonly wantsDefaultContentAppearance: boolean;

  static arrowBase(): number;

  static contentViewInsets(): UIEdgeInsets;

  static arrowHeight(): number;
}

declare class UIBlurEffect extends UIVisualEffect {
  static effectWithStyle(style: interop.Enum<typeof UIBlurEffectStyle>): UIBlurEffect;
}

declare class UIListContentConfiguration extends NSObject implements UIContentConfiguration, NSSecureCoding {
  static cellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static subtitleCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static valueCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static plainHeaderConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static plainFooterConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static groupedHeaderConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static groupedFooterConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static prominentInsetGroupedHeaderConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static extraProminentInsetGroupedHeaderConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static sidebarCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static sidebarSubtitleCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static accompaniedSidebarCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static accompaniedSidebarSubtitleCellConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static sidebarHeaderConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  image: UIImage;

  readonly imageProperties: UIListContentImageProperties;

  text: string;

  attributedText: NSAttributedString;

  readonly textProperties: UIListContentTextProperties;

  secondaryText: string;

  secondaryAttributedText: NSAttributedString;

  readonly secondaryTextProperties: UIListContentTextProperties;

  axesPreservingSuperviewLayoutMargins: interop.Enum<typeof UIAxis>;

  directionalLayoutMargins: NSDirectionalEdgeInsets;

  prefersSideBySideTextAndSecondaryText: boolean;

  imageToTextPadding: number;

  textToSecondaryTextHorizontalPadding: number;

  textToSecondaryTextVerticalPadding: number;

  makeContentView(): UIView;

  updatedConfigurationForState(state: UIConfigurationState): this;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UICollectionViewDiffableDataSourceReorderingHandlers<SectionType = interop.Object, ItemType = interop.Object> extends NSObject implements NSCopying {
  canReorderItemHandler: (p1: interop.Object) => boolean;

  willReorderHandler: (p1: NSDiffableDataSourceTransaction) => void;

  didReorderHandler: (p1: NSDiffableDataSourceTransaction) => void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICollectionLayoutListConfiguration extends NSObject implements NSCopying {
  initWithAppearance(appearance: interop.Enum<typeof UICollectionLayoutListAppearance>): this;

  readonly appearance: interop.Enum<typeof UICollectionLayoutListAppearance>;

  showsSeparators: boolean;

  separatorConfiguration: UIListSeparatorConfiguration;

  itemSeparatorHandler: (p1: NSIndexPath, p2: UIListSeparatorConfiguration) => UIListSeparatorConfiguration;

  backgroundColor: UIColor;

  leadingSwipeActionsConfigurationProvider: (p1: NSIndexPath) => UISwipeActionsConfiguration;

  trailingSwipeActionsConfigurationProvider: (p1: NSIndexPath) => UISwipeActionsConfiguration;

  headerMode: interop.Enum<typeof UICollectionLayoutListHeaderMode>;

  footerMode: interop.Enum<typeof UICollectionLayoutListFooterMode>;

  headerTopPadding: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICollectionViewDiffableDataSource<SectionIdentifierType = interop.Object, ItemIdentifierType = interop.Object> extends NSObject implements UICollectionViewDataSource {
  initWithCollectionViewCellProvider(collectionView: UICollectionView, cellProvider: (p1: UICollectionView, p2: NSIndexPath, p3: interop.Object) => UICollectionViewCell): this;

  supplementaryViewProvider: (p1: UICollectionView, p2: string, p3: NSIndexPath) => UICollectionReusableView;

  snapshot(): NSDiffableDataSourceSnapshot;

  applySnapshotAnimatingDifferences(snapshot: NSDiffableDataSourceSnapshot, animatingDifferences: boolean): void;

  applySnapshotAnimatingDifferencesCompletion(snapshot: NSDiffableDataSourceSnapshot, animatingDifferences: boolean, completion: () => void | null): void;

  applySnapshotUsingReloadData(snapshot: NSDiffableDataSourceSnapshot): void;

  applySnapshotUsingReloadDataCompletion(snapshot: NSDiffableDataSourceSnapshot, completion: () => void | null): void;

  sectionIdentifierForIndex(index: number): SectionIdentifierType;

  indexForSectionIdentifier(identifier: SectionIdentifierType): number;

  itemIdentifierForIndexPath(indexPath: NSIndexPath): ItemIdentifierType;

  indexPathForItemIdentifier(identifier: ItemIdentifierType): NSIndexPath;

  reorderingHandlers: UICollectionViewDiffableDataSourceReorderingHandlers;

  applySnapshotToSectionAnimatingDifferences(snapshot: NSDiffableDataSourceSectionSnapshot, sectionIdentifier: SectionIdentifierType, animatingDifferences: boolean): void;

  applySnapshotToSectionAnimatingDifferencesCompletion(snapshot: NSDiffableDataSourceSectionSnapshot, sectionIdentifier: SectionIdentifierType, animatingDifferences: boolean, completion: () => void | null): void;

  snapshotForSection(section: SectionIdentifierType): NSDiffableDataSourceSectionSnapshot;

  sectionSnapshotHandlers: UICollectionViewDiffableDataSourceSectionSnapshotHandlers;

  collectionViewNumberOfItemsInSection(collectionView: UICollectionView, section: number): number;

  collectionViewCellForItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): UICollectionViewCell;

  numberOfSectionsInCollectionView(collectionView: UICollectionView): number;

  collectionViewViewForSupplementaryElementOfKindAtIndexPath(collectionView: UICollectionView, kind: string, indexPath: NSIndexPath): UICollectionReusableView;

  collectionViewCanMoveItemAtIndexPath(collectionView: UICollectionView, indexPath: NSIndexPath): boolean;

  collectionViewMoveItemAtIndexPathToIndexPath(collectionView: UICollectionView, sourceIndexPath: NSIndexPath, destinationIndexPath: NSIndexPath): void;

  indexTitlesForCollectionView(collectionView: UICollectionView): NSArray;

  collectionViewIndexPathForIndexTitleAtIndex(collectionView: UICollectionView, title: string, index: number): NSIndexPath;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSTextParagraph extends NSTextElement {
  initWithAttributedString(attributedString: NSAttributedString | null): this;

  readonly attributedString: NSAttributedString;

  readonly paragraphContentRange: NSTextRange;

  readonly paragraphSeparatorRange: NSTextRange;
}

declare class UISearchDisplayController extends NSObject {
  initWithSearchBarContentsController(searchBar: UISearchBar, viewController: UIViewController): this;

  delegate: UISearchDisplayDelegate;

  isActive: boolean;

  setActiveAnimated(visible: boolean, animated: boolean): void;

  readonly searchBar: UISearchBar;

  readonly searchContentsController: UIViewController;

  readonly searchResultsTableView: UITableView;

  searchResultsDataSource: UITableViewDataSource;

  searchResultsDelegate: UITableViewDelegate;

  searchResultsTitle: string;

  displaysSearchBarInNavigationBar: boolean;

  readonly navigationItem: UINavigationItem;
}

declare class NSDiffableDataSourceSectionTransaction<SectionIdentifierType = interop.Object, ItemIdentifierType = interop.Object> extends NSObject {
  readonly sectionIdentifier: SectionIdentifierType;

  readonly initialSnapshot: NSDiffableDataSourceSectionSnapshot;

  readonly finalSnapshot: NSDiffableDataSourceSectionSnapshot;

  readonly difference: NSOrderedCollectionDifference;
}

declare class NSDiffableDataSourceSectionSnapshot<ItemIdentifierType = interop.Object> extends NSObject implements NSCopying {
  init(): this;

  appendItems(items: NSArray<interop.Object> | Array<interop.Object>): void;

  appendItemsIntoParentItem(items: NSArray<interop.Object> | Array<interop.Object>, parentItem: ItemIdentifierType | null): void;

  insertItemsBeforeItem(items: NSArray<interop.Object> | Array<interop.Object>, beforeIdentifier: ItemIdentifierType): void;

  insertItemsAfterItem(items: NSArray<interop.Object> | Array<interop.Object>, afterIdentifier: ItemIdentifierType): void;

  deleteItems(items: NSArray<interop.Object> | Array<interop.Object>): void;

  deleteAllItems(): void;

  expandItems(items: NSArray<interop.Object> | Array<interop.Object>): void;

  collapseItems(items: NSArray<interop.Object> | Array<interop.Object>): void;

  replaceChildrenOfParentItemWithSnapshot(parentItem: ItemIdentifierType, snapshot: NSDiffableDataSourceSectionSnapshot): void;

  insertSnapshotBeforeItem(snapshot: NSDiffableDataSourceSectionSnapshot, item: ItemIdentifierType): void;

  insertSnapshotAfterItem(snapshot: NSDiffableDataSourceSectionSnapshot, item: ItemIdentifierType): ItemIdentifierType;

  isExpanded(item: ItemIdentifierType): boolean;

  isVisible(item: ItemIdentifierType): boolean;

  containsItem(item: ItemIdentifierType): boolean;

  levelOfItem(item: ItemIdentifierType): number;

  indexOfItem(item: ItemIdentifierType): number;

  expandedItems(): NSArray;

  parentOfChildItem(childItem: ItemIdentifierType): ItemIdentifierType;

  snapshotOfParentItem(parentItem: ItemIdentifierType): NSDiffableDataSourceSectionSnapshot;

  snapshotOfParentItemIncludingParentItem(parentItem: ItemIdentifierType, includingParentItem: boolean): NSDiffableDataSourceSectionSnapshot;

  readonly items: NSArray;

  readonly rootItems: NSArray;

  readonly visibleItems: NSArray;

  visualDescription(): string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPencilHoverPose extends NSObject {
  readonly location: CGPoint;

  readonly zOffset: number;

  readonly azimuthAngle: number;

  readonly azimuthUnitVector: CGVector;

  readonly altitudeAngle: number;

  readonly rollAngle: number;
}

declare class UITableViewPlaceholder extends NSObject {
  initWithInsertionIndexPathReuseIdentifierRowHeight(insertionIndexPath: NSIndexPath, reuseIdentifier: string, rowHeight: number): this;

  cellUpdateHandler: (p1: UITableViewCell) => void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UITableView extends UIScrollView implements NSCoding, UIDataSourceTranslating {
  initWithFrameStyle(frame: CGRect, style: interop.Enum<typeof UITableViewStyle>): this;

  initWithCoder(coder: NSCoder): this;

  readonly style: interop.Enum<typeof UITableViewStyle>;

  dataSource: UITableViewDataSource;

  // @ts-ignore MemberDecl.tsIgnore
  delegate: UITableViewDelegate;

  prefetchDataSource: UITableViewDataSourcePrefetching;

  isPrefetchingEnabled: boolean;

  dragDelegate: UITableViewDragDelegate;

  dropDelegate: UITableViewDropDelegate;

  rowHeight: number;

  sectionHeaderHeight: number;

  sectionFooterHeight: number;

  estimatedRowHeight: number;

  estimatedSectionHeaderHeight: number;

  estimatedSectionFooterHeight: number;

  fillerRowHeight: number;

  sectionHeaderTopPadding: number;

  separatorInset: UIEdgeInsets;

  separatorInsetReference: interop.Enum<typeof UITableViewSeparatorInsetReference>;

  selfSizingInvalidation: interop.Enum<typeof UITableViewSelfSizingInvalidation>;

  backgroundView: UIView;

  readonly contextMenuInteraction: UIContextMenuInteraction;

  readonly numberOfSections: number;

  numberOfRowsInSection(section: number): number;

  rectForSection(section: number): CGRect;

  rectForHeaderInSection(section: number): CGRect;

  rectForFooterInSection(section: number): CGRect;

  rectForRowAtIndexPath(indexPath: NSIndexPath): CGRect;

  indexPathForRowAtPoint(point: CGPoint): NSIndexPath;

  indexPathForCell(cell: UITableViewCell): NSIndexPath;

  indexPathsForRowsInRect(rect: CGRect): NSArray;

  cellForRowAtIndexPath(indexPath: NSIndexPath): UITableViewCell;

  readonly visibleCells: NSArray;

  readonly indexPathsForVisibleRows: NSArray;

  headerViewForSection(section: number): UITableViewHeaderFooterView;

  footerViewForSection(section: number): UITableViewHeaderFooterView;

  scrollToRowAtIndexPathAtScrollPositionAnimated(indexPath: NSIndexPath, scrollPosition: interop.Enum<typeof UITableViewScrollPosition>, animated: boolean): void;

  scrollToNearestSelectedRowAtScrollPositionAnimated(scrollPosition: interop.Enum<typeof UITableViewScrollPosition>, animated: boolean): void;

  performBatchUpdatesCompletion(updates: () => void | null, completion: (p1: boolean) => void | null): void;

  beginUpdates(): void;

  endUpdates(): void;

  insertSectionsWithRowAnimation(sections: NSIndexSet, animation: interop.Enum<typeof UITableViewRowAnimation>): void;

  deleteSectionsWithRowAnimation(sections: NSIndexSet, animation: interop.Enum<typeof UITableViewRowAnimation>): void;

  moveSectionToSection(section: number, newSection: number): void;

  reloadSectionsWithRowAnimation(sections: NSIndexSet, animation: interop.Enum<typeof UITableViewRowAnimation>): void;

  insertRowsAtIndexPathsWithRowAnimation(indexPaths: NSArray<interop.Object> | Array<interop.Object>, animation: interop.Enum<typeof UITableViewRowAnimation>): void;

  deleteRowsAtIndexPathsWithRowAnimation(indexPaths: NSArray<interop.Object> | Array<interop.Object>, animation: interop.Enum<typeof UITableViewRowAnimation>): void;

  moveRowAtIndexPathToIndexPath(indexPath: NSIndexPath, newIndexPath: NSIndexPath): void;

  reloadRowsAtIndexPathsWithRowAnimation(indexPaths: NSArray<interop.Object> | Array<interop.Object>, animation: interop.Enum<typeof UITableViewRowAnimation>): void;

  reconfigureRowsAtIndexPaths(indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  readonly hasUncommittedUpdates: boolean;

  reloadData(): void;

  reloadSectionIndexTitles(): void;

  isEditing: boolean;

  setEditingAnimated(editing: boolean, animated: boolean): void;

  allowsSelection: boolean;

  allowsSelectionDuringEditing: boolean;

  allowsMultipleSelection: boolean;

  allowsMultipleSelectionDuringEditing: boolean;

  readonly indexPathForSelectedRow: NSIndexPath;

  readonly indexPathsForSelectedRows: NSArray;

  selectRowAtIndexPathAnimatedScrollPosition(indexPath: NSIndexPath | null, animated: boolean, scrollPosition: interop.Enum<typeof UITableViewScrollPosition>): void;

  deselectRowAtIndexPathAnimated(indexPath: NSIndexPath, animated: boolean): void;

  sectionIndexMinimumDisplayRowCount: number;

  sectionIndexColor: UIColor;

  sectionIndexBackgroundColor: UIColor;

  sectionIndexTrackingBackgroundColor: UIColor;

  separatorStyle: interop.Enum<typeof UITableViewCellSeparatorStyle>;

  separatorColor: UIColor;

  separatorEffect: UIVisualEffect;

  cellLayoutMarginsFollowReadableWidth: boolean;

  insetsContentViewsToSafeArea: boolean;

  tableHeaderView: UIView;

  tableFooterView: UIView;

  dequeueReusableCellWithIdentifier(identifier: string): UITableViewCell;

  dequeueReusableCellWithIdentifierForIndexPath(identifier: string, indexPath: NSIndexPath): UITableViewCell;

  dequeueReusableHeaderFooterViewWithIdentifier(identifier: string): UITableViewHeaderFooterView;

  registerNibForCellReuseIdentifier(nib: UINib | null, identifier: string): void;

  registerClassForCellReuseIdentifier(cellClass: interop.Object | null, identifier: string): void;

  registerNibForHeaderFooterViewReuseIdentifier(nib: UINib | null, identifier: string): void;

  registerClassForHeaderFooterViewReuseIdentifier(aClass: interop.Object | null, identifier: string): void;

  remembersLastFocusedIndexPath: boolean;

  selectionFollowsFocus: boolean;

  allowsFocus: boolean;

  allowsFocusDuringEditing: boolean;

  dragInteractionEnabled: boolean;

  readonly hasActiveDrag: boolean;

  readonly hasActiveDrop: boolean;

  encodeWithCoder(coder: NSCoder): void;

  presentationSectionIndexForDataSourceSectionIndex(dataSourceSectionIndex: number): number;

  dataSourceSectionIndexForPresentationSectionIndex(presentationSectionIndex: number): number;

  presentationIndexPathForDataSourceIndexPath(dataSourceIndexPath: NSIndexPath | null): NSIndexPath;

  dataSourceIndexPathForPresentationIndexPath(presentationIndexPath: NSIndexPath | null): NSIndexPath;

  performUsingPresentationValues(actionsToTranslate: () => void): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITraitUserInterfaceLevel extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UITableViewRowAction extends NSObject implements NSCopying {
  static rowActionWithStyleTitleHandler<This extends abstract new (...args: any) => any>(this: This, style: interop.Enum<typeof UITableViewRowActionStyle>, title: string | null, handler: (p1: UITableViewRowAction, p2: NSIndexPath) => void): InstanceType<This>;

  readonly style: interop.Enum<typeof UITableViewRowActionStyle>;

  title: string;

  backgroundColor: UIColor;

  backgroundEffect: UIVisualEffect;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSTextLineFragment extends NSObject implements NSSecureCoding {
  initWithAttributedStringRange(attributedString: NSAttributedString, range: _NSRange): this;

  initWithCoder(aDecoder: NSCoder): this;

  initWithStringAttributesRange(string: string, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, range: _NSRange): this;

  readonly attributedString: NSAttributedString;

  readonly characterRange: _NSRange;

  readonly typographicBounds: CGRect;

  readonly glyphOrigin: CGPoint;

  drawAtPointInContext(point: CGPoint, context: interop.PointerConvertible): void;

  locationForCharacterAtIndex(index: number): CGPoint;

  characterIndexForPoint(point: CGPoint): number;

  fractionOfDistanceThroughGlyphForPoint(point: CGPoint): number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSDiffableDataSourceSnapshot<SectionIdentifierType = interop.Object, ItemIdentifierType = interop.Object> extends NSObject implements NSCopying {
  readonly numberOfItems: number;

  readonly numberOfSections: number;

  readonly sectionIdentifiers: NSArray;

  readonly itemIdentifiers: NSArray;

  readonly reloadedSectionIdentifiers: NSArray;

  readonly reloadedItemIdentifiers: NSArray;

  readonly reconfiguredItemIdentifiers: NSArray;

  numberOfItemsInSection(sectionIdentifier: SectionIdentifierType): number;

  itemIdentifiersInSectionWithIdentifier(sectionIdentifier: SectionIdentifierType): NSArray;

  sectionIdentifierForSectionContainingItemIdentifier(itemIdentifier: ItemIdentifierType): SectionIdentifierType;

  indexOfItemIdentifier(itemIdentifier: ItemIdentifierType): number;

  indexOfSectionIdentifier(sectionIdentifier: SectionIdentifierType): number;

  appendItemsWithIdentifiers(identifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  appendItemsWithIdentifiersIntoSectionWithIdentifier(identifiers: NSArray<interop.Object> | Array<interop.Object>, sectionIdentifier: SectionIdentifierType): void;

  insertItemsWithIdentifiersBeforeItemWithIdentifier(identifiers: NSArray<interop.Object> | Array<interop.Object>, itemIdentifier: ItemIdentifierType): void;

  insertItemsWithIdentifiersAfterItemWithIdentifier(identifiers: NSArray<interop.Object> | Array<interop.Object>, itemIdentifier: ItemIdentifierType): void;

  deleteItemsWithIdentifiers(identifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  deleteAllItems(): void;

  moveItemWithIdentifierBeforeItemWithIdentifier(fromIdentifier: ItemIdentifierType, toIdentifier: ItemIdentifierType): void;

  moveItemWithIdentifierAfterItemWithIdentifier(fromIdentifier: ItemIdentifierType, toIdentifier: ItemIdentifierType): void;

  reloadItemsWithIdentifiers(identifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  reconfigureItemsWithIdentifiers(identifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  appendSectionsWithIdentifiers(sectionIdentifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  insertSectionsWithIdentifiersBeforeSectionWithIdentifier(sectionIdentifiers: NSArray<interop.Object> | Array<interop.Object>, toSectionIdentifier: SectionIdentifierType): void;

  insertSectionsWithIdentifiersAfterSectionWithIdentifier(sectionIdentifiers: NSArray<interop.Object> | Array<interop.Object>, toSectionIdentifier: SectionIdentifierType): void;

  deleteSectionsWithIdentifiers(sectionIdentifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  moveSectionWithIdentifierBeforeSectionWithIdentifier(fromSectionIdentifier: SectionIdentifierType, toSectionIdentifier: SectionIdentifierType): void;

  moveSectionWithIdentifierAfterSectionWithIdentifier(fromSectionIdentifier: SectionIdentifierType, toSectionIdentifier: SectionIdentifierType): void;

  reloadSectionsWithIdentifiers(sectionIdentifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITraitUserInterfaceIdiom extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIPointerLockState extends NSObject {
  readonly isLocked: boolean;
}

declare class UIWindowScene extends UIScene {
  readonly screen: UIScreen;

  readonly interfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>;

  readonly coordinateSpace: UICoordinateSpace;

  readonly traitCollection: UITraitCollection;

  requestGeometryUpdateWithPreferencesErrorHandler(geometryPreferences: UIWindowSceneGeometryPreferences, errorHandler: (p1: NSError) => void | null): void;

  readonly effectiveGeometry: UIWindowSceneGeometry;

  readonly sizeRestrictions: UISceneSizeRestrictions;

  readonly windows: NSArray;

  readonly keyWindow: UIWindow;

  activityItemsConfigurationSource: UIActivityItemsConfigurationProviding;

  readonly windowingBehaviors: UISceneWindowingBehaviors;

  readonly isFullScreen: boolean;

  readonly traitOverrides: UITraitOverrides;

  readonly focusSystem: UIFocusSystem;

  readonly statusBarManager: UIStatusBarManager;

  readonly screenshotService: UIScreenshotService;
}

declare class UIScreenshotService extends NSObject {
  delegate: UIScreenshotServiceDelegate;

  readonly windowScene: UIWindowScene;
}

declare class UIContextualAction extends NSObject {
  static contextualActionWithStyleTitleHandler<This extends abstract new (...args: any) => any>(this: This, style: interop.Enum<typeof UIContextualActionStyle>, title: string | null, handler: (p1: UIContextualAction, p2: UIView, p3: (p1: boolean) => void) => void): InstanceType<This>;

  readonly style: interop.Enum<typeof UIContextualActionStyle>;

  readonly handler: (p1: UIContextualAction, p2: UIView, p3: (p1: boolean) => void) => void;

  title: string;

  backgroundColor: UIColor;

  image: UIImage;
}

declare class UIWindowScenePlacement extends NSObject implements NSCopying {
  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIGestureRecognizer extends NSObject {
  initWithTargetAction(target: interop.Object | null, action: string | null): this;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  addTargetAction(target: interop.Object, action: string): void;

  removeTargetAction(target: interop.Object | null, action: string | null): void;

  readonly state: interop.Enum<typeof UIGestureRecognizerState>;

  delegate: UIGestureRecognizerDelegate;

  isEnabled: boolean;

  readonly view: UIView;

  cancelsTouchesInView: boolean;

  delaysTouchesBegan: boolean;

  delaysTouchesEnded: boolean;

  get allowedTouchTypes(): NSArray;
  set allowedTouchTypes(value: NSArray<interop.Object> | Array<interop.Object>);

  get allowedPressTypes(): NSArray;
  set allowedPressTypes(value: NSArray<interop.Object> | Array<interop.Object>);

  requiresExclusiveTouchType: boolean;

  requireGestureRecognizerToFail(otherGestureRecognizer: UIGestureRecognizer): void;

  locationInView(view: UIView | null): CGPoint;

  readonly numberOfTouches: number;

  locationOfTouchInView(touchIndex: number, view: UIView | null): CGPoint;

  name: string;

  readonly modifierFlags: interop.Enum<typeof UIKeyModifierFlags>;

  readonly buttonMask: interop.Enum<typeof UIEventButtonMask>;

  ignoreTouchForEvent(touch: UITouch, event: UIEvent): void;

  ignorePressForEvent(button: UIPress, event: UIPressesEvent): void;

  reset(): void;

  canPreventGestureRecognizer(preventedGestureRecognizer: UIGestureRecognizer): boolean;

  canBePreventedByGestureRecognizer(preventingGestureRecognizer: UIGestureRecognizer): boolean;

  shouldRequireFailureOfGestureRecognizer(otherGestureRecognizer: UIGestureRecognizer): boolean;

  shouldBeRequiredToFailByGestureRecognizer(otherGestureRecognizer: UIGestureRecognizer): boolean;

  shouldReceiveEvent(event: UIEvent): boolean;

  touchesBeganWithEvent(touches: NSSet, event: UIEvent): void;

  touchesMovedWithEvent(touches: NSSet, event: UIEvent): void;

  touchesEndedWithEvent(touches: NSSet, event: UIEvent): void;

  touchesCancelledWithEvent(touches: NSSet, event: UIEvent): void;

  touchesEstimatedPropertiesUpdated(touches: NSSet): void;

  pressesBeganWithEvent(presses: NSSet, event: UIPressesEvent): void;

  pressesChangedWithEvent(presses: NSSet, event: UIPressesEvent): void;

  pressesEndedWithEvent(presses: NSSet, event: UIPressesEvent): void;

  pressesCancelledWithEvent(presses: NSSet, event: UIPressesEvent): void;
}

declare class UICellAccessoryLabel extends UICellAccessory {
  initWithText(text: string): this;

  readonly text: string;

  font: UIFont;

  adjustsFontForContentSizeCategory: boolean;

  initWithCoder(coder: NSCoder): this;
}

declare class UICellAccessoryPopUpMenu extends UICellAccessory {
  initWithMenu(menu: UIMenu): this;

  readonly menu: UIMenu;

  selectedElementDidChangeHandler: (p1: UIMenu) => void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSParagraphStyle extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  static readonly defaultParagraphStyle: NSParagraphStyle;

  static defaultWritingDirectionForLanguage(languageName: string | null): interop.Enum<typeof NSWritingDirection>;

  readonly lineSpacing: number;

  readonly paragraphSpacing: number;

  readonly alignment: interop.Enum<typeof NSTextAlignment>;

  readonly headIndent: number;

  readonly tailIndent: number;

  readonly firstLineHeadIndent: number;

  readonly minimumLineHeight: number;

  readonly maximumLineHeight: number;

  readonly lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  readonly baseWritingDirection: interop.Enum<typeof NSWritingDirection>;

  readonly lineHeightMultiple: number;

  readonly paragraphSpacingBefore: number;

  readonly hyphenationFactor: number;

  readonly usesDefaultHyphenation: boolean;

  readonly tabStops: NSArray;

  readonly defaultTabInterval: number;

  readonly textLists: NSArray;

  readonly allowsDefaultTighteningForTruncation: boolean;

  readonly lineBreakStrategy: interop.Enum<typeof NSLineBreakStrategy>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSTextList extends NSObject implements NSSecureCoding, NSCopying {
  initWithMarkerFormatOptionsStartingItemNumber(markerFormat: string, options: interop.Enum<typeof NSTextListOptions>, startingItemNumber: number): this;

  initWithMarkerFormatOptions(markerFormat: string, options: number): this;

  initWithCoder(coder: NSCoder): this;

  readonly markerFormat: string;

  readonly listOptions: interop.Enum<typeof NSTextListOptions>;

  startingItemNumber: number;

  readonly isOrdered: boolean;

  markerForItemNumber(itemNumber: number): string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICellAccessoryMultiselect extends UICellAccessory {
  backgroundColor: UIColor;
}

declare class UIBandSelectionInteraction extends NSObject implements UIInteraction {
  isEnabled: boolean;

  readonly state: interop.Enum<typeof UIBandSelectionInteractionState>;

  readonly selectionRect: CGRect;

  readonly initialModifierFlags: interop.Enum<typeof UIKeyModifierFlags>;

  shouldBeginHandler: (p1: UIBandSelectionInteraction, p2: CGPoint) => boolean;

  initWithSelectionHandler(selectionHandler: (p1: UIBandSelectionInteraction) => void): this;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UICellAccessoryInsert extends UICellAccessory {
  backgroundColor: UIColor;

  actionHandler: () => void;
}

declare class UIEditMenuConfiguration extends NSObject {
  readonly identifier: NSCopying;

  readonly sourcePoint: CGPoint;

  preferredArrowDirection: interop.Enum<typeof UIEditMenuArrowDirection>;

  static configurationWithIdentifierSourcePoint<This extends abstract new (...args: any) => any>(this: This, identifier: NSCopying | null, sourcePoint: CGPoint): InstanceType<This>;
}

declare class UICellAccessoryCheckmark extends UICellAccessory {
}

declare class UIUserNotificationAction extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  readonly identifier: string;

  readonly title: string;

  readonly behavior: interop.Enum<typeof UIUserNotificationActionBehavior>;

  readonly parameters: NSDictionary;

  readonly activationMode: interop.Enum<typeof UIUserNotificationActivationMode>;

  readonly isAuthenticationRequired: boolean;

  readonly isDestructive: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIWindow extends UIView {
  initWithWindowScene(windowScene: UIWindowScene): this;

  windowScene: UIWindowScene;

  canResizeToFitContent: boolean;

  screen: UIScreen;

  windowLevel: number;

  readonly isKeyWindow: boolean;

  readonly canBecomeKeyWindow: boolean;

  becomeKeyWindow(): void;

  resignKeyWindow(): void;

  makeKeyWindow(): void;

  makeKeyAndVisible(): void;

  rootViewController: UIViewController;

  sendEvent(event: UIEvent): void;

  convertPointToWindow(point: CGPoint, window: UIWindow | null): CGPoint;

  convertPointFromWindow(point: CGPoint, window: UIWindow | null): CGPoint;

  convertRectToWindow(rect: CGRect, window: UIWindow | null): CGRect;

  convertRectFromWindow(rect: CGRect, window: UIWindow | null): CGRect;

  readonly safeAreaAspectFitLayoutGuide: UILayoutGuide;
}

declare class UICellAccessoryDetail extends UICellAccessory {
  actionHandler: () => void;
}

declare class UIImageReader extends NSObject {
  static readonly defaultReader: UIImageReader;

  static readerWithConfiguration<This extends abstract new (...args: any) => any>(this: This, configuration: UIImageReaderConfiguration): InstanceType<This>;

  readonly configuration: UIImageReaderConfiguration;

  imageWithContentsOfFileURL(url: NSURL): UIImage;

  imageWithData(data: NSData): UIImage;

  imageWithContentsOfFileURLCompletion(url: NSURL, completion: (p1: UIImage) => void | null): void;

  imageWithDataCompletion(data: NSData, completion: (p1: UIImage) => void | null): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UICollectionView extends UIScrollView implements UIDataSourceTranslating {
  initWithFrameCollectionViewLayout(frame: CGRect, layout: UICollectionViewLayout): this;

  initWithCoder(coder: NSCoder): this;

  collectionViewLayout: UICollectionViewLayout;

  // @ts-ignore MemberDecl.tsIgnore
  delegate: UICollectionViewDelegate;

  dataSource: UICollectionViewDataSource;

  prefetchDataSource: UICollectionViewDataSourcePrefetching;

  isPrefetchingEnabled: boolean;

  dragDelegate: UICollectionViewDragDelegate;

  dropDelegate: UICollectionViewDropDelegate;

  dragInteractionEnabled: boolean;

  readonly contextMenuInteraction: UIContextMenuInteraction;

  reorderingCadence: interop.Enum<typeof UICollectionViewReorderingCadence>;

  selfSizingInvalidation: interop.Enum<typeof UICollectionViewSelfSizingInvalidation>;

  backgroundView: UIView;

  registerClassForCellWithReuseIdentifier(cellClass: interop.Object | null, identifier: string): void;

  registerNibForCellWithReuseIdentifier(nib: UINib | null, identifier: string): void;

  registerClassForSupplementaryViewOfKindWithReuseIdentifier(viewClass: interop.Object | null, elementKind: string, identifier: string): void;

  registerNibForSupplementaryViewOfKindWithReuseIdentifier(nib: UINib | null, kind: string, identifier: string): void;

  dequeueReusableCellWithReuseIdentifierForIndexPath(identifier: string, indexPath: NSIndexPath): UICollectionViewCell;

  dequeueReusableSupplementaryViewOfKindWithReuseIdentifierForIndexPath(elementKind: string, identifier: string, indexPath: NSIndexPath): UICollectionReusableView;

  dequeueConfiguredReusableCellWithRegistrationForIndexPathItem(registration: UICollectionViewCellRegistration, indexPath: NSIndexPath, item: interop.Object): UICollectionViewCell;

  dequeueConfiguredReusableSupplementaryViewWithRegistrationForIndexPath(registration: UICollectionViewSupplementaryRegistration, indexPath: NSIndexPath): UICollectionReusableView;

  allowsSelection: boolean;

  allowsMultipleSelection: boolean;

  readonly indexPathsForSelectedItems: NSArray;

  selectItemAtIndexPathAnimatedScrollPosition(indexPath: NSIndexPath | null, animated: boolean, scrollPosition: interop.Enum<typeof UICollectionViewScrollPosition>): void;

  deselectItemAtIndexPathAnimated(indexPath: NSIndexPath, animated: boolean): void;

  readonly hasUncommittedUpdates: boolean;

  reloadData(): void;

  setCollectionViewLayoutAnimated(layout: UICollectionViewLayout, animated: boolean): void;

  setCollectionViewLayoutAnimatedCompletion(layout: UICollectionViewLayout, animated: boolean, completion: (p1: boolean) => void | null): void;

  startInteractiveTransitionToCollectionViewLayoutCompletion(layout: UICollectionViewLayout, completion: (p1: boolean, p2: boolean) => void | null): UICollectionViewTransitionLayout;

  finishInteractiveTransition(): void;

  cancelInteractiveTransition(): void;

  readonly numberOfSections: number;

  numberOfItemsInSection(section: number): number;

  layoutAttributesForItemAtIndexPath(indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  layoutAttributesForSupplementaryElementOfKindAtIndexPath(kind: string, indexPath: NSIndexPath): UICollectionViewLayoutAttributes;

  indexPathForItemAtPoint(point: CGPoint): NSIndexPath;

  indexPathForCell(cell: UICollectionViewCell): NSIndexPath;

  cellForItemAtIndexPath(indexPath: NSIndexPath): UICollectionViewCell;

  readonly visibleCells: NSArray;

  readonly indexPathsForVisibleItems: NSArray;

  supplementaryViewForElementKindAtIndexPath(elementKind: string, indexPath: NSIndexPath): UICollectionReusableView;

  visibleSupplementaryViewsOfKind(elementKind: string): NSArray;

  indexPathsForVisibleSupplementaryElementsOfKind(elementKind: string): NSArray;

  scrollToItemAtIndexPathAtScrollPositionAnimated(indexPath: NSIndexPath, scrollPosition: interop.Enum<typeof UICollectionViewScrollPosition>, animated: boolean): void;

  insertSections(sections: NSIndexSet): void;

  deleteSections(sections: NSIndexSet): void;

  moveSectionToSection(section: number, newSection: number): void;

  reloadSections(sections: NSIndexSet): void;

  insertItemsAtIndexPaths(indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  deleteItemsAtIndexPaths(indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  moveItemAtIndexPathToIndexPath(indexPath: NSIndexPath, newIndexPath: NSIndexPath): void;

  reloadItemsAtIndexPaths(indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  reconfigureItemsAtIndexPaths(indexPaths: NSArray<interop.Object> | Array<interop.Object>): void;

  performBatchUpdatesCompletion(updates: () => void | null, completion: (p1: boolean) => void | null): void;

  beginInteractiveMovementForItemAtIndexPath(indexPath: NSIndexPath): boolean;

  updateInteractiveMovementTargetPosition(targetPosition: CGPoint): void;

  endInteractiveMovement(): void;

  cancelInteractiveMovement(): void;

  remembersLastFocusedIndexPath: boolean;

  selectionFollowsFocus: boolean;

  allowsFocus: boolean;

  allowsFocusDuringEditing: boolean;

  readonly hasActiveDrag: boolean;

  readonly hasActiveDrop: boolean;

  isEditing: boolean;

  allowsSelectionDuringEditing: boolean;

  allowsMultipleSelectionDuringEditing: boolean;

  presentationSectionIndexForDataSourceSectionIndex(dataSourceSectionIndex: number): number;

  dataSourceSectionIndexForPresentationSectionIndex(presentationSectionIndex: number): number;

  presentationIndexPathForDataSourceIndexPath(dataSourceIndexPath: NSIndexPath | null): NSIndexPath;

  dataSourceIndexPathForPresentationIndexPath(presentationIndexPath: NSIndexPath | null): NSIndexPath;

  performUsingPresentationValues(actionsToTranslate: () => void): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UICollectionViewLayoutAttributes extends NSObject implements NSCopying, UIDynamicItem {
  frame: CGRect;

  center: CGPoint;

  size: CGSize;

  transform3D: CATransform3D;

  bounds: CGRect;

  transform: CGAffineTransform;

  alpha: number;

  zIndex: number;

  isHidden: boolean;

  indexPath: NSIndexPath;

  readonly representedElementCategory: interop.Enum<typeof UICollectionElementCategory>;

  readonly representedElementKind: string;

  static layoutAttributesForCellWithIndexPath<This extends abstract new (...args: any) => any>(this: This, indexPath: NSIndexPath): InstanceType<This>;

  static layoutAttributesForSupplementaryViewOfKindWithIndexPath<This extends abstract new (...args: any) => any>(this: This, elementKind: string, indexPath: NSIndexPath): InstanceType<This>;

  static layoutAttributesForDecorationViewOfKindWithIndexPath<This extends abstract new (...args: any) => any>(this: This, decorationViewKind: string, indexPath: NSIndexPath): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  readonly collisionBoundsType: interop.Enum<typeof UIDynamicItemCollisionBoundsType>;

  readonly collisionBoundingPath: UIBezierPath;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UICollectionViewFlowLayoutInvalidationContext extends UICollectionViewLayoutInvalidationContext {
  invalidateFlowLayoutDelegateMetrics: boolean;

  invalidateFlowLayoutAttributes: boolean;
}

declare class UIKeyboardLayoutGuide extends UITrackingLayoutGuide {
  followsUndockedKeyboard: boolean;

  usesBottomSafeArea: boolean;

  keyboardDismissPadding: number;
}

declare class UIAccessibilityLocationDescriptor extends NSObject {
  initWithNameView(name: string, view: UIView): this;

  initWithNamePointInView(name: string, point: CGPoint, view: UIView): this;

  initWithAttributedNamePointInView(attributedName: NSAttributedString, point: CGPoint, view: UIView): this;

  readonly view: UIView | null;

  readonly point: CGPoint;

  readonly name: string;

  readonly attributedName: NSAttributedString;
}

declare class NSCollectionLayoutSize extends NSObject implements NSCopying {
  static sizeWithWidthDimensionHeightDimension<This extends abstract new (...args: any) => any>(this: This, width: NSCollectionLayoutDimension, height: NSCollectionLayoutDimension): InstanceType<This>;

  readonly widthDimension: NSCollectionLayoutDimension;

  readonly heightDimension: NSCollectionLayoutDimension;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSCollectionLayoutDimension extends NSObject implements NSCopying {
  static fractionalWidthDimension<This extends abstract new (...args: any) => any>(this: This, fractionalWidth: number): InstanceType<This>;

  static fractionalHeightDimension<This extends abstract new (...args: any) => any>(this: This, fractionalHeight: number): InstanceType<This>;

  static absoluteDimension<This extends abstract new (...args: any) => any>(this: This, absoluteDimension: number): InstanceType<This>;

  static estimatedDimension<This extends abstract new (...args: any) => any>(this: This, estimatedDimension: number): InstanceType<This>;

  static uniformAcrossSiblingsWithEstimate<This extends abstract new (...args: any) => any>(this: This, estimatedDimension: number): InstanceType<This>;

  readonly isFractionalWidth: boolean;

  readonly isFractionalHeight: boolean;

  readonly isAbsolute: boolean;

  readonly isEstimated: boolean;

  readonly isUniformAcrossSiblings: boolean;

  readonly dimension: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIContentUnavailableImageProperties extends NSObject implements NSCopying, NSSecureCoding {
  preferredSymbolConfiguration: UIImageSymbolConfiguration;

  tintColor: UIColor;

  cornerRadius: number;

  maximumSize: CGSize;

  accessibilityIgnoresInvertColors: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UITraitForceTouchCapability extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UITouch extends NSObject {
  readonly timestamp: number;

  readonly phase: interop.Enum<typeof UITouchPhase>;

  readonly tapCount: number;

  readonly type: interop.Enum<typeof UITouchType>;

  readonly majorRadius: number;

  readonly majorRadiusTolerance: number;

  readonly window: UIWindow;

  readonly view: UIView;

  readonly gestureRecognizers: NSArray;

  locationInView(view: UIView | null): CGPoint;

  previousLocationInView(view: UIView | null): CGPoint;

  preciseLocationInView(view: UIView | null): CGPoint;

  precisePreviousLocationInView(view: UIView | null): CGPoint;

  readonly force: number;

  readonly maximumPossibleForce: number;

  azimuthAngleInView(view: UIView | null): number;

  azimuthUnitVectorInView(view: UIView | null): CGVector;

  readonly altitudeAngle: number;

  readonly estimationUpdateIndex: NSNumber;

  readonly estimatedProperties: interop.Enum<typeof UITouchProperties>;

  readonly estimatedPropertiesExpectingUpdates: interop.Enum<typeof UITouchProperties>;

  readonly rollAngle: number;

  locationInNode(node: SKNode): CGPoint;

  previousLocationInNode(node: SKNode): CGPoint;
}

declare class UICollectionViewCompositionalLayout extends UICollectionViewLayout {
  initWithSection(section: NSCollectionLayoutSection): this;

  initWithSectionConfiguration(section: NSCollectionLayoutSection, configuration: UICollectionViewCompositionalLayoutConfiguration): this;

  initWithSectionProvider(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection): this;

  initWithSectionProviderConfiguration(sectionProvider: (p1: number, p2: NSCollectionLayoutEnvironment) => NSCollectionLayoutSection, configuration: UICollectionViewCompositionalLayoutConfiguration): this;

  configuration: UICollectionViewCompositionalLayoutConfiguration;

  static layoutWithListConfiguration<This extends abstract new (...args: any) => any>(this: This, configuration: UICollectionLayoutListConfiguration): InstanceType<This>;
}

declare class UIWebView extends UIView implements NSCoding, UIScrollViewDelegate {
  delegate: UIWebViewDelegate;

  readonly scrollView: UIScrollView;

  loadRequest(request: NSURLRequest): void;

  loadHTMLStringBaseURL(string: string, baseURL: NSURL | null): void;

  loadDataMIMETypeTextEncodingNameBaseURL(data: NSData, MIMEType: string, textEncodingName: string, baseURL: NSURL): void;

  readonly request: NSURLRequest;

  reload(): void;

  stopLoading(): void;

  goBack(): void;

  goForward(): void;

  readonly canGoBack: boolean;

  readonly canGoForward: boolean;

  readonly isLoading: boolean;

  stringByEvaluatingJavaScriptFromString(script: string): string;

  scalesPageToFit: boolean;

  detectsPhoneNumbers: boolean;

  dataDetectorTypes: interop.Enum<typeof UIDataDetectorTypes>;

  allowsInlineMediaPlayback: boolean;

  mediaPlaybackRequiresUserAction: boolean;

  mediaPlaybackAllowsAirPlay: boolean;

  suppressesIncrementalRendering: boolean;

  keyboardDisplayRequiresUserAction: boolean;

  paginationMode: interop.Enum<typeof UIWebPaginationMode>;

  paginationBreakingMode: interop.Enum<typeof UIWebPaginationBreakingMode>;

  pageLength: number;

  gapBetweenPages: number;

  readonly pageCount: number;

  allowsPictureInPictureMediaPlayback: boolean;

  allowsLinkPreview: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  scrollViewDidScroll(scrollView: UIScrollView): void;

  scrollViewDidZoom(scrollView: UIScrollView): void;

  scrollViewWillBeginDragging(scrollView: UIScrollView): void;

  scrollViewWillEndDraggingWithVelocityTargetContentOffset(scrollView: UIScrollView, velocity: CGPoint, targetContentOffset: interop.PointerConvertible): void;

  scrollViewDidEndDraggingWillDecelerate(scrollView: UIScrollView, decelerate: boolean): void;

  scrollViewWillBeginDecelerating(scrollView: UIScrollView): void;

  scrollViewDidEndDecelerating(scrollView: UIScrollView): void;

  scrollViewDidEndScrollingAnimation(scrollView: UIScrollView): void;

  viewForZoomingInScrollView(scrollView: UIScrollView): UIView;

  scrollViewWillBeginZoomingWithView(scrollView: UIScrollView, view: UIView | null): void;

  scrollViewDidEndZoomingWithViewAtScale(scrollView: UIScrollView, view: UIView | null, scale: number): void;

  scrollViewShouldScrollToTop(scrollView: UIScrollView): boolean;

  scrollViewDidScrollToTop(scrollView: UIScrollView): void;

  scrollViewDidChangeAdjustedContentInset(scrollView: UIScrollView): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITraitPreferredContentSizeCategory extends NSObject implements UIObjectTraitDefinition {
  static readonly defaultValue: NSObject;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UITraitLayoutDirection extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UICollectionViewCompositionalLayoutConfiguration extends NSObject implements NSCopying {
  scrollDirection: interop.Enum<typeof UICollectionViewScrollDirection>;

  interSectionSpacing: number;

  get boundarySupplementaryItems(): NSArray;
  set boundarySupplementaryItems(value: NSArray<interop.Object> | Array<interop.Object>);

  contentInsetsReference: interop.Enum<typeof UIContentInsetsReference>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICollectionViewFlowLayout extends UICollectionViewLayout {
  minimumLineSpacing: number;

  minimumInteritemSpacing: number;

  itemSize: CGSize;

  estimatedItemSize: CGSize;

  scrollDirection: interop.Enum<typeof UICollectionViewScrollDirection>;

  headerReferenceSize: CGSize;

  footerReferenceSize: CGSize;

  sectionInset: UIEdgeInsets;

  sectionInsetReference: interop.Enum<typeof UICollectionViewFlowLayoutSectionInsetReference>;

  sectionHeadersPinToVisibleBounds: boolean;

  sectionFootersPinToVisibleBounds: boolean;
}

declare class UICollectionReusableView extends UIView {
  readonly reuseIdentifier: string;

  prepareForReuse(): void;

  applyLayoutAttributes(layoutAttributes: UICollectionViewLayoutAttributes): void;

  willTransitionFromLayoutToLayout(oldLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout): void;

  didTransitionFromLayoutToLayout(oldLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout): void;

  preferredLayoutAttributesFittingAttributes(layoutAttributes: UICollectionViewLayoutAttributes): UICollectionViewLayoutAttributes;
}

declare class UICollectionViewPlaceholder extends NSObject {
  initWithInsertionIndexPathReuseIdentifier(insertionIndexPath: NSIndexPath, reuseIdentifier: string): this;

  cellUpdateHandler: (p1: UICollectionViewCell) => void;
}

declare class UIListContentTextProperties extends NSObject implements NSCopying, NSSecureCoding {
  font: UIFont;

  color: UIColor;

  colorTransformer: (p1: UIColor) => UIColor;

  resolvedColor(): UIColor;

  alignment: interop.Enum<typeof UIListContentTextAlignment>;

  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  numberOfLines: number;

  adjustsFontSizeToFitWidth: boolean;

  minimumScaleFactor: number;

  allowsDefaultTighteningForTruncation: boolean;

  adjustsFontForContentSizeCategory: boolean;

  showsExpansionTextWhenTruncated: boolean;

  transform: interop.Enum<typeof UIListContentTextTransform>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UICollectionViewDropProposal extends UIDropProposal {
  initWithDropOperationIntent(operation: interop.Enum<typeof UIDropOperation>, intent: interop.Enum<typeof UICollectionViewDropIntent>): this;

  readonly intent: interop.Enum<typeof UICollectionViewDropIntent>;
}

declare class UIDocumentBrowserTransitionController extends NSObject implements UIViewControllerAnimatedTransitioning {
  loadingProgress: NSProgress;

  targetView: UIView;

  transitionDuration(transitionContext: UIViewControllerContextTransitioning | null): number;

  animateTransition(transitionContext: UIViewControllerContextTransitioning): void;

  interruptibleAnimatorForTransition(transitionContext: UIViewControllerContextTransitioning): UIViewImplicitlyAnimating;

  animationEnded(transitionCompleted: boolean): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIBarButtonItem extends UIBarItem implements NSCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  initWithImageStyleTargetAction(image: UIImage | null, style: interop.Enum<typeof UIBarButtonItemStyle>, target: interop.Object | null, action: string | null): this;

  initWithImageLandscapeImagePhoneStyleTargetAction(image: UIImage | null, landscapeImagePhone: UIImage | null, style: interop.Enum<typeof UIBarButtonItemStyle>, target: interop.Object | null, action: string | null): this;

  initWithTitleStyleTargetAction(title: string | null, style: interop.Enum<typeof UIBarButtonItemStyle>, target: interop.Object | null, action: string | null): this;

  initWithBarButtonSystemItemTargetAction(systemItem: interop.Enum<typeof UIBarButtonSystemItem>, target: interop.Object | null, action: string | null): this;

  initWithCustomView(customView: UIView): this;

  initWithBarButtonSystemItemPrimaryAction(systemItem: interop.Enum<typeof UIBarButtonSystemItem>, primaryAction: UIAction | null): this;

  initWithPrimaryAction(primaryAction: UIAction | null): this;

  initWithBarButtonSystemItemMenu(systemItem: interop.Enum<typeof UIBarButtonSystemItem>, menu: UIMenu | null): this;

  initWithTitleMenu(title: string | null, menu: UIMenu | null): this;

  initWithImageMenu(image: UIImage | null, menu: UIMenu | null): this;

  initWithPrimaryActionMenu(primaryAction: UIAction | null, menu: UIMenu | null): this;

  initWithBarButtonSystemItemPrimaryActionMenu(systemItem: interop.Enum<typeof UIBarButtonSystemItem>, primaryAction: UIAction | null, menu: UIMenu | null): this;

  initWithTitleImageTargetActionMenu(title: string | null, image: UIImage | null, target: interop.Object | null, action: string | null, menu: UIMenu | null): this;

  static fixedSpaceItemOfWidth<This extends abstract new (...args: any) => any>(this: This, width: number): InstanceType<This>;

  static flexibleSpaceItem<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  style: interop.Enum<typeof UIBarButtonItemStyle>;

  width: number;

  possibleTitles: NSSet;

  customView: UIView;

  action: string;

  target: interop.Object;

  primaryAction: UIAction;

  menu: UIMenu;

  preferredMenuElementOrder: interop.Enum<typeof UIContextMenuConfigurationElementOrder>;

  changesSelectionAsPrimaryAction: boolean;

  isSelected: boolean;

  isHidden: boolean;

  isSymbolAnimationEnabled: boolean;

  menuRepresentation: UIMenuElement;

  creatingFixedGroup(): UIBarButtonItemGroup;

  creatingMovableGroupWithCustomizationIdentifier(customizationIdentifier: string): UIBarButtonItemGroup;

  creatingOptionalGroupWithCustomizationIdentifierInDefaultCustomization(customizationIdentifier: string, inDefaultCustomization: boolean): UIBarButtonItemGroup;

  setBackgroundImageForStateBarMetrics(backgroundImage: UIImage | null, state: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForStateBarMetrics(state: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setBackgroundImageForStateStyleBarMetrics(backgroundImage: UIImage | null, state: interop.Enum<typeof UIControlState>, style: interop.Enum<typeof UIBarButtonItemStyle>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundImageForStateStyleBarMetrics(state: interop.Enum<typeof UIControlState>, style: interop.Enum<typeof UIBarButtonItemStyle>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  tintColor: UIColor;

  setBackgroundVerticalPositionAdjustmentForBarMetrics(adjustment: number, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backgroundVerticalPositionAdjustmentForBarMetrics(barMetrics: interop.Enum<typeof UIBarMetrics>): number;

  setTitlePositionAdjustmentForBarMetrics(adjustment: UIOffset, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  titlePositionAdjustmentForBarMetrics(barMetrics: interop.Enum<typeof UIBarMetrics>): UIOffset;

  setBackButtonBackgroundImageForStateBarMetrics(backgroundImage: UIImage | null, state: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backButtonBackgroundImageForStateBarMetrics(state: interop.Enum<typeof UIControlState>, barMetrics: interop.Enum<typeof UIBarMetrics>): UIImage;

  setBackButtonTitlePositionAdjustmentForBarMetrics(adjustment: UIOffset, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backButtonTitlePositionAdjustmentForBarMetrics(barMetrics: interop.Enum<typeof UIBarMetrics>): UIOffset;

  setBackButtonBackgroundVerticalPositionAdjustmentForBarMetrics(adjustment: number, barMetrics: interop.Enum<typeof UIBarMetrics>): void;

  backButtonBackgroundVerticalPositionAdjustmentForBarMetrics(barMetrics: interop.Enum<typeof UIBarMetrics>): number;

  addSymbolEffect(symbolEffect: NSSymbolEffect): void;

  addSymbolEffectOptions(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions): void;

  addSymbolEffectOptionsAnimated(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions, animated: boolean): void;

  removeSymbolEffectOfType(symbolEffect: NSSymbolEffect): void;

  removeSymbolEffectOfTypeOptions(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions): void;

  removeSymbolEffectOfTypeOptionsAnimated(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions, animated: boolean): void;

  removeAllSymbolEffects(): void;

  removeAllSymbolEffectsWithOptions(options: NSSymbolEffectOptions): void;

  removeAllSymbolEffectsWithOptionsAnimated(options: NSSymbolEffectOptions, animated: boolean): void;

  setSymbolImageWithContentTransition(symbolImage: UIImage, transition: NSSymbolContentTransition): void;

  setSymbolImageWithContentTransitionOptions(symbolImage: UIImage, transition: NSSymbolContentTransition, options: NSSymbolEffectOptions): void;

  readonly buttonGroup: UIBarButtonItemGroup;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIDictationPhrase extends NSObject {
  readonly text: string;

  readonly alternativeInterpretations: NSArray;
}

declare class UIButtonConfiguration extends NSObject implements NSCopying, NSSecureCoding {
  static plainButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static tintedButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static grayButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static filledButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static borderlessButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static borderedButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static borderedTintedButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static borderedProminentButtonConfiguration<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  updatedConfigurationForButton(button: UIButton): this;

  background: UIBackgroundConfiguration;

  cornerStyle: interop.Enum<typeof UIButtonConfigurationCornerStyle>;

  buttonSize: interop.Enum<typeof UIButtonConfigurationSize>;

  macIdiomStyle: interop.Enum<typeof UIButtonConfigurationMacIdiomStyle>;

  baseForegroundColor: UIColor;

  baseBackgroundColor: UIColor;

  image: UIImage;

  imageColorTransformer: (p1: UIColor) => UIColor;

  preferredSymbolConfigurationForImage: UIImageSymbolConfiguration;

  showsActivityIndicator: boolean;

  activityIndicatorColorTransformer: (p1: UIColor) => UIColor;

  title: string;

  attributedTitle: NSAttributedString;

  titleTextAttributesTransformer: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => NSDictionary;

  titleLineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  subtitle: string;

  attributedSubtitle: NSAttributedString;

  subtitleTextAttributesTransformer: (p1: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>) => NSDictionary;

  subtitleLineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  indicator: interop.Enum<typeof UIButtonConfigurationIndicator>;

  indicatorColorTransformer: (p1: UIColor) => UIColor;

  contentInsets: NSDirectionalEdgeInsets;

  setDefaultContentInsets(): void;

  imagePlacement: interop.Enum<typeof NSDirectionalRectEdge>;

  imagePadding: number;

  titlePadding: number;

  titleAlignment: interop.Enum<typeof UIButtonConfigurationTitleAlignment>;

  automaticallyUpdateForSelection: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIImageView extends UIView {
  initWithImage(image: UIImage | null): this;

  initWithImageHighlightedImage(image: UIImage | null, highlightedImage: UIImage | null): this;

  image: UIImage;

  highlightedImage: UIImage;

  preferredSymbolConfiguration: UIImageSymbolConfiguration;

  isUserInteractionEnabled: boolean;

  isHighlighted: boolean;

  get animationImages(): NSArray;
  set animationImages(value: NSArray<interop.Object> | Array<interop.Object>);

  get highlightedAnimationImages(): NSArray;
  set highlightedAnimationImages(value: NSArray<interop.Object> | Array<interop.Object>);

  animationDuration: number;

  animationRepeatCount: number;

  tintColor: UIColor;

  startAnimating(): void;

  stopAnimating(): void;

  readonly isAnimating: boolean;

  preferredImageDynamicRange: interop.Enum<typeof UIImageDynamicRange>;

  readonly imageDynamicRange: interop.Enum<typeof UIImageDynamicRange>;

  addSymbolEffect(symbolEffect: NSSymbolEffect): void;

  addSymbolEffectOptions(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions): void;

  addSymbolEffectOptionsAnimated(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions, animated: boolean): void;

  addSymbolEffectOptionsAnimatedCompletion(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions, animated: boolean, completionHandler: (p1: UISymbolEffectCompletionContext) => void | null): void;

  removeSymbolEffectOfType(symbolEffect: NSSymbolEffect): void;

  removeSymbolEffectOfTypeOptions(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions): void;

  removeSymbolEffectOfTypeOptionsAnimated(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions, animated: boolean): void;

  removeSymbolEffectOfTypeOptionsAnimatedCompletion(symbolEffect: NSSymbolEffect, options: NSSymbolEffectOptions, animated: boolean, completionHandler: (p1: UISymbolEffectCompletionContext) => void | null): void;

  removeAllSymbolEffects(): void;

  removeAllSymbolEffectsWithOptions(options: NSSymbolEffectOptions): void;

  removeAllSymbolEffectsWithOptionsAnimated(options: NSSymbolEffectOptions, animated: boolean): void;

  setSymbolImageWithContentTransition(symbolImage: UIImage, transition: NSSymbolContentTransition): void;

  setSymbolImageWithContentTransitionOptions(symbolImage: UIImage, transition: NSSymbolContentTransition, options: NSSymbolEffectOptions): void;

  setSymbolImageWithContentTransitionOptionsCompletion(symbolImage: UIImage, transition: NSSymbolContentTransition, options: NSSymbolEffectOptions, completionHandler: (p1: UISymbolEffectCompletionContext) => void | null): void;
}

declare class UISymbolEffectCompletionContext extends NSObject {
  readonly isFinished: boolean;

  readonly sender: interop.Object;

  readonly effect: NSSymbolEffect;

  readonly contentTransition: NSSymbolContentTransition;
}

declare class UIAlertAction extends NSObject implements NSCopying {
  static actionWithTitleStyleHandler<This extends abstract new (...args: any) => any>(this: This, title: string | null, style: interop.Enum<typeof UIAlertActionStyle>, handler: (p1: UIAlertAction) => void | null): InstanceType<This>;

  readonly title: string;

  readonly style: interop.Enum<typeof UIAlertActionStyle>;

  isEnabled: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPointerLiftEffect extends UIPointerEffect {
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIStandardTextCursorView extends UIView implements UITextCursorView {
  isBlinking: boolean;

  resetBlinkAnimation(): void;

  convertPointToCoordinateSpace(point: CGPoint, coordinateSpace: UICoordinateSpace): CGPoint;

  convertPointFromCoordinateSpace(point: CGPoint, coordinateSpace: UICoordinateSpace): CGPoint;

  convertRectToCoordinateSpace(rect: CGRect, coordinateSpace: UICoordinateSpace): CGRect;

  convertRectFromCoordinateSpace(rect: CGRect, coordinateSpace: UICoordinateSpace): CGRect;

  // @ts-ignore MemberDecl.tsIgnore
  readonly bounds: CGRect;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIPreviewAction extends NSObject implements NSCopying, UIPreviewActionItem {
  readonly handler: (p1: UIPreviewActionItem, p2: UIViewController) => void;

  static actionWithTitleStyleHandler<This extends abstract new (...args: any) => any>(this: This, title: string, style: interop.Enum<typeof UIPreviewActionStyle>, handler: (p1: UIPreviewAction, p2: UIViewController) => void): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  readonly title: string;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIApplication extends UIResponder {
  static readonly sharedApplication: UIApplication;

  delegate: UIApplicationDelegate;

  beginIgnoringInteractionEvents(): void;

  endIgnoringInteractionEvents(): void;

  readonly isIgnoringInteractionEvents: boolean;

  isIdleTimerDisabled: boolean;

  openURL(url: NSURL): boolean;

  canOpenURL(url: NSURL): boolean;

  openURLOptionsCompletionHandler(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, completion: (p1: boolean) => void | null): void;

  sendEvent(event: UIEvent): void;

  readonly keyWindow: UIWindow;

  readonly windows: NSArray;

  sendActionToFromForEvent(action: string, target: interop.Object | null, sender: interop.Object | null, event: UIEvent | null): boolean;

  isNetworkActivityIndicatorVisible: boolean;

  readonly statusBarStyle: interop.Enum<typeof UIStatusBarStyle>;

  readonly isStatusBarHidden: boolean;

  readonly statusBarOrientation: interop.Enum<typeof UIInterfaceOrientation>;

  supportedInterfaceOrientationsForWindow(window: UIWindow | null): interop.Enum<typeof UIInterfaceOrientationMask>;

  readonly statusBarOrientationAnimationDuration: number;

  readonly statusBarFrame: CGRect;

  applicationIconBadgeNumber: number;

  applicationSupportsShakeToEdit: boolean;

  readonly applicationState: interop.Enum<typeof UIApplicationState>;

  readonly backgroundTimeRemaining: number;

  beginBackgroundTaskWithExpirationHandler(handler: () => void | null): number;

  beginBackgroundTaskWithNameExpirationHandler(taskName: string | null, handler: () => void | null): number;

  endBackgroundTask(identifier: number): void;

  setMinimumBackgroundFetchInterval(minimumBackgroundFetchInterval: number): void;

  readonly backgroundRefreshStatus: interop.Enum<typeof UIBackgroundRefreshStatus>;

  readonly isProtectedDataAvailable: boolean;

  readonly userInterfaceLayoutDirection: interop.Enum<typeof UIUserInterfaceLayoutDirection>;

  readonly preferredContentSizeCategory: string;

  readonly connectedScenes: NSSet;

  readonly openSessions: NSSet;

  readonly supportsMultipleScenes: boolean;

  activateSceneSessionForRequestErrorHandler(request: UISceneSessionActivationRequest, errorHandler: (p1: NSError) => void | null): void;

  requestSceneSessionActivationUserActivityOptionsErrorHandler(sceneSession: UISceneSession | null, userActivity: NSUserActivity | null, options: UISceneActivationRequestOptions | null, errorHandler: (p1: NSError) => void | null): void;

  requestSceneSessionDestructionOptionsErrorHandler(sceneSession: UISceneSession, options: UISceneDestructionRequestOptions | null, errorHandler: (p1: NSError) => void | null): void;

  requestSceneSessionRefresh(sceneSession: UISceneSession): void;

  registerForRemoteNotifications(): void;

  unregisterForRemoteNotifications(): void;

  readonly isRegisteredForRemoteNotifications: boolean;

  registerForRemoteNotificationTypes(types: interop.Enum<typeof UIRemoteNotificationType>): void;

  enabledRemoteNotificationTypes(): interop.Enum<typeof UIRemoteNotificationType>;

  presentLocalNotificationNow(notification: UILocalNotification): void;

  scheduleLocalNotification(notification: UILocalNotification): void;

  cancelLocalNotification(notification: UILocalNotification): void;

  cancelAllLocalNotifications(): void;

  get scheduledLocalNotifications(): NSArray;
  set scheduledLocalNotifications(value: NSArray<interop.Object> | Array<interop.Object>);

  registerUserNotificationSettings(notificationSettings: UIUserNotificationSettings): void;

  readonly currentUserNotificationSettings: UIUserNotificationSettings;

  beginReceivingRemoteControlEvents(): void;

  endReceivingRemoteControlEvents(): void;

  setNewsstandIconImage(image: UIImage | null): void;

  get shortcutItems(): NSArray;
  set shortcutItems(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly supportsAlternateIcons: boolean;

  setAlternateIconNameCompletionHandler(alternateIconName: string | null, completionHandler: (p1: NSError) => void | null): void;

  readonly alternateIconName: string;

  extendStateRestoration(): void;

  completeStateRestoration(): void;

  ignoreSnapshotOnNextApplicationLaunch(): void;

  static registerObjectForStateRestorationRestorationIdentifier(object: UIStateRestoring, restorationIdentifier: string): void;

  isProximitySensingEnabled: boolean;

  setStatusBarHiddenAnimated(hidden: boolean, animated: boolean): void;

  setStatusBarOrientationAnimated(interfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>, animated: boolean): void;

  setStatusBarStyleAnimated(statusBarStyle: interop.Enum<typeof UIStatusBarStyle>, animated: boolean): void;

  setStatusBarHiddenWithAnimation(hidden: boolean, animation: interop.Enum<typeof UIStatusBarAnimation>): void;

  setKeepAliveTimeoutHandler(timeout: number, keepAliveHandler: () => void | null): boolean;

  clearKeepAliveTimeout(): void;
}

declare class UIToolTipInteraction extends NSObject implements UIInteraction {
  delegate: UIToolTipInteractionDelegate;

  isEnabled: boolean;

  defaultToolTip: string;

  init(): this;

  initWithDefaultToolTip(defaultToolTip: string): this;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITraitCollection extends NSObject implements NSCopying, NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  containsTraitsInCollection(trait: UITraitCollection | null): boolean;

  static traitCollectionWithTraitsFromCollections(traitCollections: NSArray<interop.Object> | Array<interop.Object>): UITraitCollection;

  static traitCollectionWithUserInterfaceIdiom(idiom: interop.Enum<typeof UIUserInterfaceIdiom>): UITraitCollection;

  readonly userInterfaceIdiom: interop.Enum<typeof UIUserInterfaceIdiom>;

  static traitCollectionWithUserInterfaceStyle(userInterfaceStyle: interop.Enum<typeof UIUserInterfaceStyle>): UITraitCollection;

  readonly userInterfaceStyle: interop.Enum<typeof UIUserInterfaceStyle>;

  static traitCollectionWithLayoutDirection(layoutDirection: interop.Enum<typeof UITraitEnvironmentLayoutDirection>): UITraitCollection;

  readonly layoutDirection: interop.Enum<typeof UITraitEnvironmentLayoutDirection>;

  static traitCollectionWithDisplayScale(scale: number): UITraitCollection;

  readonly displayScale: number;

  static traitCollectionWithHorizontalSizeClass(horizontalSizeClass: interop.Enum<typeof UIUserInterfaceSizeClass>): UITraitCollection;

  readonly horizontalSizeClass: interop.Enum<typeof UIUserInterfaceSizeClass>;

  static traitCollectionWithVerticalSizeClass(verticalSizeClass: interop.Enum<typeof UIUserInterfaceSizeClass>): UITraitCollection;

  readonly verticalSizeClass: interop.Enum<typeof UIUserInterfaceSizeClass>;

  static traitCollectionWithForceTouchCapability(capability: interop.Enum<typeof UIForceTouchCapability>): UITraitCollection;

  readonly forceTouchCapability: interop.Enum<typeof UIForceTouchCapability>;

  static traitCollectionWithPreferredContentSizeCategory(preferredContentSizeCategory: string): UITraitCollection;

  readonly preferredContentSizeCategory: string;

  static traitCollectionWithDisplayGamut(displayGamut: interop.Enum<typeof UIDisplayGamut>): UITraitCollection;

  readonly displayGamut: interop.Enum<typeof UIDisplayGamut>;

  static traitCollectionWithAccessibilityContrast(accessibilityContrast: interop.Enum<typeof UIAccessibilityContrast>): UITraitCollection;

  readonly accessibilityContrast: interop.Enum<typeof UIAccessibilityContrast>;

  static traitCollectionWithUserInterfaceLevel(userInterfaceLevel: interop.Enum<typeof UIUserInterfaceLevel>): UITraitCollection;

  readonly userInterfaceLevel: interop.Enum<typeof UIUserInterfaceLevel>;

  static traitCollectionWithLegibilityWeight(legibilityWeight: interop.Enum<typeof UILegibilityWeight>): UITraitCollection;

  readonly legibilityWeight: interop.Enum<typeof UILegibilityWeight>;

  static traitCollectionWithActiveAppearance(userInterfaceActiveAppearance: interop.Enum<typeof UIUserInterfaceActiveAppearance>): UITraitCollection;

  readonly activeAppearance: interop.Enum<typeof UIUserInterfaceActiveAppearance>;

  static traitCollectionWithToolbarItemPresentationSize(toolbarItemPresentationSize: interop.Enum<typeof UINSToolbarItemPresentationSize>): UITraitCollection;

  readonly toolbarItemPresentationSize: interop.Enum<typeof UINSToolbarItemPresentationSize>;

  static traitCollectionWithImageDynamicRange(imageDynamicRange: interop.Enum<typeof UIImageDynamicRange>): UITraitCollection;

  readonly imageDynamicRange: interop.Enum<typeof UIImageDynamicRange>;

  static traitCollectionWithTypesettingLanguage(language: string): UITraitCollection;

  readonly typesettingLanguage: string;

  static traitCollectionWithSceneCaptureState(sceneCaptureState: interop.Enum<typeof UISceneCaptureState>): UITraitCollection;

  readonly sceneCaptureState: interop.Enum<typeof UISceneCaptureState>;

  static traitCollectionWithTraits(mutations: (p1: UIMutableTraits) => void): UITraitCollection;

  traitCollectionByModifyingTraits(mutations: (p1: UIMutableTraits) => void): UITraitCollection;

  static traitCollectionWithCGFloatValueForTrait(value: number, trait: UICGFloatTraitDefinition): UITraitCollection;

  traitCollectionByReplacingCGFloatValueForTrait(value: number, trait: UICGFloatTraitDefinition): UITraitCollection;

  valueForCGFloatTrait(trait: UICGFloatTraitDefinition): number;

  static traitCollectionWithNSIntegerValueForTrait(value: number, trait: UINSIntegerTraitDefinition): UITraitCollection;

  traitCollectionByReplacingNSIntegerValueForTrait(value: number, trait: UINSIntegerTraitDefinition): UITraitCollection;

  valueForNSIntegerTrait(trait: UINSIntegerTraitDefinition): number;

  static traitCollectionWithObjectForTrait(object: NSObject | null, trait: UIObjectTraitDefinition): UITraitCollection;

  traitCollectionByReplacingObjectForTrait(object: NSObject | null, trait: UIObjectTraitDefinition): UITraitCollection;

  objectForTrait(trait: UIObjectTraitDefinition): NSObject;

  changedTraitsFromTraitCollection(traitCollection: UITraitCollection | null): NSSet;

  static readonly systemTraitsAffectingColorAppearance: NSArray;

  static readonly systemTraitsAffectingImageLookup: NSArray;

  static currentTraitCollection: UITraitCollection;

  performAsCurrentTraitCollection(actions: () => void): void;

  hasDifferentColorAppearanceComparedToTraitCollection(traitCollection: UITraitCollection | null): boolean;

  readonly imageConfiguration: UIImageConfiguration;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIAlertView extends UIView {
  initWithTitleMessageDelegateCancelButtonTitleOtherButtonTitles(title: string | null, message: string | null, delegate: interop.Object | null, cancelButtonTitle: string | null, otherButtonTitles: string | null): this;

  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  delegate: interop.Object;

  title: string;

  message: string;

  addButtonWithTitle(title: string | null): number;

  buttonTitleAtIndex(buttonIndex: number): string;

  readonly numberOfButtons: number;

  cancelButtonIndex: number;

  readonly firstOtherButtonIndex: number;

  readonly isVisible: boolean;

  show(): void;

  dismissWithClickedButtonIndexAnimated(buttonIndex: number, animated: boolean): void;

  alertViewStyle: interop.Enum<typeof UIAlertViewStyle>;

  textFieldAtIndex(textFieldIndex: number): UITextField;
}

declare class UIPasteConfiguration extends NSObject implements NSSecureCoding, NSCopying {
  get acceptableTypeIdentifiers(): NSArray;
  set acceptableTypeIdentifiers(value: NSArray<interop.Object> | Array<interop.Object>);

  init(): this;

  initWithAcceptableTypeIdentifiers(acceptableTypeIdentifiers: NSArray<interop.Object> | Array<interop.Object>): this;

  addAcceptableTypeIdentifiers(acceptableTypeIdentifiers: NSArray<interop.Object> | Array<interop.Object>): void;

  initWithTypeIdentifiersForAcceptingClass(aClass: NSItemProviderReading): this;

  addTypeIdentifiersForAcceptingClass(aClass: NSItemProviderReading): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIDocumentBrowserViewController extends UIViewController implements NSCoding {
  initForOpeningFilesWithContentTypes(allowedContentTypes: NSArray<interop.Object> | Array<interop.Object> | null): this;

  initForOpeningContentTypes(contentTypes: NSArray<interop.Object> | Array<interop.Object> | null): this;

  delegate: UIDocumentBrowserViewControllerDelegate;

  allowsDocumentCreation: boolean;

  allowsPickingMultipleItems: boolean;

  readonly allowedContentTypes: NSArray;

  readonly recentDocumentsContentTypes: NSArray;

  readonly contentTypesForRecentDocuments: NSArray;

  shouldShowFileExtensions: boolean;

  get additionalLeadingNavigationBarButtonItems(): NSArray;
  set additionalLeadingNavigationBarButtonItems(value: NSArray<interop.Object> | Array<interop.Object>);

  get additionalTrailingNavigationBarButtonItems(): NSArray;
  set additionalTrailingNavigationBarButtonItems(value: NSArray<interop.Object> | Array<interop.Object>);

  revealDocumentAtURLImportIfNeededCompletion(url: NSURL, importIfNeeded: boolean, completion: (p1: NSURL, p2: NSError) => void | null): void;

  importDocumentAtURLNextToDocumentAtURLModeCompletionHandler(documentURL: NSURL, neighbourURL: NSURL, importMode: interop.Enum<typeof UIDocumentBrowserImportMode>, completion: (p1: NSURL, p2: NSError) => void | null): void;

  renameDocumentAtURLProposedNameCompletionHandler(documentURL: NSURL, proposedName: string, completionHandler: (p1: NSURL, p2: NSError) => void | null): void;

  transitionControllerForDocumentAtURL(documentURL: NSURL): UIDocumentBrowserTransitionController;

  transitionControllerForDocumentURL(documentURL: NSURL): UIDocumentBrowserTransitionController;

  get customActions(): NSArray;
  set customActions(value: NSArray<interop.Object> | Array<interop.Object>);

  browserUserInterfaceStyle: interop.Enum<typeof UIDocumentBrowserUserInterfaceStyle>;

  localizedCreateDocumentActionTitle: string;

  defaultDocumentAspectRatio: number;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSLayoutManager extends NSObject implements NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  textStorage: NSTextStorage;

  readonly textContainers: NSArray;

  addTextContainer(container: NSTextContainer): void;

  insertTextContainerAtIndex(container: NSTextContainer, index: number): void;

  removeTextContainerAtIndex(index: number): void;

  textContainerChangedGeometry(container: NSTextContainer): void;

  delegate: NSLayoutManagerDelegate;

  showsInvisibleCharacters: boolean;

  showsControlCharacters: boolean;

  usesFontLeading: boolean;

  allowsNonContiguousLayout: boolean;

  readonly hasNonContiguousLayout: boolean;

  limitsLayoutForSuspiciousContents: boolean;

  usesDefaultHyphenation: boolean;

  invalidateGlyphsForCharacterRangeChangeInLengthActualCharacterRange(charRange: _NSRange, delta: number, actualCharRange: interop.PointerConvertible): void;

  invalidateLayoutForCharacterRangeActualCharacterRange(charRange: _NSRange, actualCharRange: interop.PointerConvertible): void;

  invalidateDisplayForCharacterRange(charRange: _NSRange): void;

  invalidateDisplayForGlyphRange(glyphRange: _NSRange): void;

  processEditingForTextStorageEditedRangeChangeInLengthInvalidatedRange(textStorage: NSTextStorage, editMask: interop.Enum<typeof NSTextStorageEditActions>, newCharRange: _NSRange, delta: number, invalidatedCharRange: _NSRange): void;

  ensureGlyphsForCharacterRange(charRange: _NSRange): void;

  ensureGlyphsForGlyphRange(glyphRange: _NSRange): void;

  ensureLayoutForCharacterRange(charRange: _NSRange): void;

  ensureLayoutForGlyphRange(glyphRange: _NSRange): void;

  ensureLayoutForTextContainer(container: NSTextContainer): void;

  ensureLayoutForBoundingRectInTextContainer(bounds: CGRect, container: NSTextContainer): void;

  setGlyphsPropertiesCharacterIndexesFontForGlyphRange(glyphs: interop.PointerConvertible, props: interop.PointerConvertible, charIndexes: interop.PointerConvertible, aFont: UIFont, glyphRange: _NSRange): void;

  readonly numberOfGlyphs: number;

  CGGlyphAtIndexIsValidIndex(glyphIndex: number, isValidIndex: interop.PointerConvertible): number;

  CGGlyphAtIndex(glyphIndex: number): number;

  isValidGlyphIndex(glyphIndex: number): boolean;

  propertyForGlyphAtIndex(glyphIndex: number): interop.Enum<typeof NSGlyphProperty>;

  characterIndexForGlyphAtIndex(glyphIndex: number): number;

  glyphIndexForCharacterAtIndex(charIndex: number): number;

  getGlyphsInRangeGlyphsPropertiesCharacterIndexesBidiLevels(glyphRange: _NSRange, glyphBuffer: interop.PointerConvertible, props: interop.PointerConvertible, charIndexBuffer: interop.PointerConvertible, bidiLevelBuffer: interop.PointerConvertible): number;

  setTextContainerForGlyphRange(container: NSTextContainer, glyphRange: _NSRange): void;

  setLineFragmentRectForGlyphRangeUsedRect(fragmentRect: CGRect, glyphRange: _NSRange, usedRect: CGRect): void;

  setExtraLineFragmentRectUsedRectTextContainer(fragmentRect: CGRect, usedRect: CGRect, container: NSTextContainer): void;

  setLocationForStartOfGlyphRange(location: CGPoint, glyphRange: _NSRange): void;

  setNotShownAttributeForGlyphAtIndex(flag: boolean, glyphIndex: number): void;

  setDrawsOutsideLineFragmentForGlyphAtIndex(flag: boolean, glyphIndex: number): void;

  setAttachmentSizeForGlyphRange(attachmentSize: CGSize, glyphRange: _NSRange): void;

  getFirstUnlaidCharacterIndexGlyphIndex(charIndex: interop.PointerConvertible, glyphIndex: interop.PointerConvertible): void;

  firstUnlaidCharacterIndex(): number;

  firstUnlaidGlyphIndex(): number;

  textContainerForGlyphAtIndexEffectiveRange(glyphIndex: number, effectiveGlyphRange: interop.PointerConvertible): NSTextContainer;

  textContainerForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(glyphIndex: number, effectiveGlyphRange: interop.PointerConvertible, flag: boolean): NSTextContainer;

  usedRectForTextContainer(container: NSTextContainer): CGRect;

  lineFragmentRectForGlyphAtIndexEffectiveRange(glyphIndex: number, effectiveGlyphRange: interop.PointerConvertible): CGRect;

  lineFragmentRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(glyphIndex: number, effectiveGlyphRange: interop.PointerConvertible, flag: boolean): CGRect;

  lineFragmentUsedRectForGlyphAtIndexEffectiveRange(glyphIndex: number, effectiveGlyphRange: interop.PointerConvertible): CGRect;

  lineFragmentUsedRectForGlyphAtIndexEffectiveRangeWithoutAdditionalLayout(glyphIndex: number, effectiveGlyphRange: interop.PointerConvertible, flag: boolean): CGRect;

  readonly extraLineFragmentRect: CGRect;

  readonly extraLineFragmentUsedRect: CGRect;

  readonly extraLineFragmentTextContainer: NSTextContainer;

  locationForGlyphAtIndex(glyphIndex: number): CGPoint;

  notShownAttributeForGlyphAtIndex(glyphIndex: number): boolean;

  drawsOutsideLineFragmentForGlyphAtIndex(glyphIndex: number): boolean;

  attachmentSizeForGlyphAtIndex(glyphIndex: number): CGSize;

  truncatedGlyphRangeInLineFragmentForGlyphAtIndex(glyphIndex: number): _NSRange;

  glyphRangeForCharacterRangeActualCharacterRange(charRange: _NSRange, actualCharRange: interop.PointerConvertible): _NSRange;

  characterRangeForGlyphRangeActualGlyphRange(glyphRange: _NSRange, actualGlyphRange: interop.PointerConvertible): _NSRange;

  glyphRangeForTextContainer(container: NSTextContainer): _NSRange;

  rangeOfNominallySpacedGlyphsContainingIndex(glyphIndex: number): _NSRange;

  boundingRectForGlyphRangeInTextContainer(glyphRange: _NSRange, container: NSTextContainer): CGRect;

  glyphRangeForBoundingRectInTextContainer(bounds: CGRect, container: NSTextContainer): _NSRange;

  glyphRangeForBoundingRectWithoutAdditionalLayoutInTextContainer(bounds: CGRect, container: NSTextContainer): _NSRange;

  glyphIndexForPointInTextContainerFractionOfDistanceThroughGlyph(point: CGPoint, container: NSTextContainer, partialFraction: interop.PointerConvertible): number;

  glyphIndexForPointInTextContainer(point: CGPoint, container: NSTextContainer): number;

  fractionOfDistanceThroughGlyphForPointInTextContainer(point: CGPoint, container: NSTextContainer): number;

  characterIndexForPointInTextContainerFractionOfDistanceBetweenInsertionPoints(point: CGPoint, container: NSTextContainer, partialFraction: interop.PointerConvertible): number;

  getLineFragmentInsertionPointsForCharacterAtIndexAlternatePositionsInDisplayOrderPositionsCharacterIndexes(charIndex: number, aFlag: boolean, dFlag: boolean, positions: interop.PointerConvertible, charIndexes: interop.PointerConvertible): number;

  enumerateLineFragmentsForGlyphRangeUsingBlock(glyphRange: _NSRange, block: (p1: CGRect, p2: CGRect, p3: NSTextContainer, p4: _NSRange, p5: interop.PointerConvertible) => void): void;

  enumerateEnclosingRectsForGlyphRangeWithinSelectedGlyphRangeInTextContainerUsingBlock(glyphRange: _NSRange, selectedRange: _NSRange, textContainer: NSTextContainer, block: (p1: CGRect, p2: interop.PointerConvertible) => void): void;

  drawBackgroundForGlyphRangeAtPoint(glyphsToShow: _NSRange, origin: CGPoint): void;

  drawGlyphsForGlyphRangeAtPoint(glyphsToShow: _NSRange, origin: CGPoint): void;

  showCGGlyphsPositionsCountFontTextMatrixAttributesInContext(glyphs: interop.PointerConvertible, positions: interop.PointerConvertible, glyphCount: number, font: UIFont, textMatrix: CGAffineTransform, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, CGContext: interop.PointerConvertible): void;

  fillBackgroundRectArrayCountForCharacterRangeColor(rectArray: interop.PointerConvertible, rectCount: number, charRange: _NSRange, color: UIColor): void;

  drawUnderlineForGlyphRangeUnderlineTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: _NSRange, underlineVal: interop.Enum<typeof NSUnderlineStyle>, baselineOffset: number, lineRect: CGRect, lineGlyphRange: _NSRange, containerOrigin: CGPoint): void;

  underlineGlyphRangeUnderlineTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: _NSRange, underlineVal: interop.Enum<typeof NSUnderlineStyle>, lineRect: CGRect, lineGlyphRange: _NSRange, containerOrigin: CGPoint): void;

  drawStrikethroughForGlyphRangeStrikethroughTypeBaselineOffsetLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: _NSRange, strikethroughVal: interop.Enum<typeof NSUnderlineStyle>, baselineOffset: number, lineRect: CGRect, lineGlyphRange: _NSRange, containerOrigin: CGPoint): void;

  strikethroughGlyphRangeStrikethroughTypeLineFragmentRectLineFragmentGlyphRangeContainerOrigin(glyphRange: _NSRange, strikethroughVal: interop.Enum<typeof NSUnderlineStyle>, lineRect: CGRect, lineGlyphRange: _NSRange, containerOrigin: CGPoint): void;

  glyphAtIndexIsValidIndex(glyphIndex: number, isValidIndex: interop.PointerConvertible): number;

  glyphAtIndex(glyphIndex: number): number;

  hyphenationFactor: number;

  showCGGlyphsPositionsCountFontMatrixAttributesInContext(glyphs: interop.PointerConvertible, positions: interop.PointerConvertible, glyphCount: number, font: UIFont, textMatrix: CGAffineTransform, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, graphicsContext: interop.PointerConvertible): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIDropProposal extends NSObject implements NSCopying {
  initWithDropOperation(operation: interop.Enum<typeof UIDropOperation>): this;

  readonly operation: interop.Enum<typeof UIDropOperation>;

  isPrecise: boolean;

  prefersFullSizePreview: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPointerShape extends NSObject implements NSCopying {
  static shapeWithPath<This extends abstract new (...args: any) => any>(this: This, path: UIBezierPath): InstanceType<This>;

  static shapeWithRoundedRect<This extends abstract new (...args: any) => any>(this: This, rect: CGRect): InstanceType<This>;

  static shapeWithRoundedRectCornerRadius<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, cornerRadius: number): InstanceType<This>;

  static beamWithPreferredLengthAxis<This extends abstract new (...args: any) => any>(this: This, length: number, axis: interop.Enum<typeof UIAxis>): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSTextStorage extends NSMutableAttributedString implements NSSecureCoding {
  readonly layoutManagers: NSArray;

  addLayoutManager(aLayoutManager: NSLayoutManager): void;

  removeLayoutManager(aLayoutManager: NSLayoutManager): void;

  readonly editedMask: interop.Enum<typeof NSTextStorageEditActions>;

  readonly editedRange: _NSRange;

  readonly changeInLength: number;

  delegate: NSTextStorageDelegate;

  editedRangeChangeInLength(editedMask: interop.Enum<typeof NSTextStorageEditActions>, editedRange: _NSRange, delta: number): void;

  processEditing(): void;

  readonly fixesAttributesLazily: boolean;

  invalidateAttributesInRange(range: _NSRange): void;

  ensureAttributesAreFixedInRange(range: _NSRange): void;

  textStorageObserver: NSTextStorageObserving;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIAcceleration extends NSObject {
  readonly timestamp: number;

  readonly x: number;

  readonly y: number;

  readonly z: number;
}

declare class UIBarItem extends NSObject implements NSCoding, UIAppearance {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  isEnabled: boolean;

  title: string;

  image: UIImage;

  landscapeImagePhone: UIImage;

  largeContentSizeImage: UIImage;

  imageInsets: UIEdgeInsets;

  landscapeImagePhoneInsets: UIEdgeInsets;

  largeContentSizeImageInsets: UIEdgeInsets;

  tag: number;

  setTitleTextAttributesForState(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, state: interop.Enum<typeof UIControlState>): void;

  titleTextAttributesForState(state: interop.Enum<typeof UIControlState>): NSDictionary;

  encodeWithCoder(coder: NSCoder): void;

  static appearance<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static appearanceWhenContainedIn<This extends abstract new (...args: any) => any>(this: This, ContainerClass: UIAppearanceContainer | null): InstanceType<This>;

  static appearanceWhenContainedInInstancesOfClasses<This extends abstract new (...args: any) => any>(this: This, containerTypes: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static appearanceForTraitCollection<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection): InstanceType<This>;

  static appearanceForTraitCollectionWhenContainedIn<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection, ContainerClass: UIAppearanceContainer | null): InstanceType<This>;

  static appearanceForTraitCollectionWhenContainedInInstancesOfClasses<This extends abstract new (...args: any) => any>(this: This, trait: UITraitCollection, containerTypes: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIAccessibilityCustomRotorSearchPredicate extends NSObject {
  currentItem: UIAccessibilityCustomRotorItemResult;

  searchDirection: interop.Enum<typeof UIAccessibilityCustomRotorDirection>;
}

declare class UIWindowSceneGeometryPreferencesIOS extends UIWindowSceneGeometryPreferences {
  init(): this;

  initWithInterfaceOrientations(interfaceOrientations: interop.Enum<typeof UIInterfaceOrientationMask>): this;

  interfaceOrientations: interop.Enum<typeof UIInterfaceOrientationMask>;
}

declare class UIOpenURLContext extends NSObject {
  readonly URL: NSURL;

  readonly options: UISceneOpenURLOptions;
}

declare class UIAccessibilityCustomAction extends NSObject {
  initWithNameTargetSelector(name: string, target: interop.Object | null, selector: string): this;

  initWithAttributedNameTargetSelector(attributedName: NSAttributedString, target: interop.Object | null, selector: string): this;

  initWithNameImageTargetSelector(name: string, image: UIImage | null, target: interop.Object | null, selector: string): this;

  initWithAttributedNameImageTargetSelector(attributedName: NSAttributedString, image: UIImage | null, target: interop.Object | null, selector: string): this;

  initWithNameActionHandler(name: string, actionHandler: (p1: UIAccessibilityCustomAction) => boolean): this;

  initWithAttributedNameActionHandler(attributedName: NSAttributedString, actionHandler: (p1: UIAccessibilityCustomAction) => boolean): this;

  initWithNameImageActionHandler(name: string, image: UIImage | null, actionHandler: (p1: UIAccessibilityCustomAction) => boolean): this;

  initWithAttributedNameImageActionHandler(attributedName: NSAttributedString, image: UIImage | null, actionHandler: (p1: UIAccessibilityCustomAction) => boolean): this;

  name: string;

  image: UIImage;

  attributedName: NSAttributedString;

  target: interop.Object;

  selector: string;

  actionHandler: (p1: UIAccessibilityCustomAction) => boolean;
}

declare class UIBezierPath extends NSObject implements NSCopying, NSSecureCoding {
  static bezierPath<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static bezierPathWithRect<This extends abstract new (...args: any) => any>(this: This, rect: CGRect): InstanceType<This>;

  static bezierPathWithOvalInRect<This extends abstract new (...args: any) => any>(this: This, rect: CGRect): InstanceType<This>;

  static bezierPathWithRoundedRectCornerRadius<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, cornerRadius: number): InstanceType<This>;

  static bezierPathWithRoundedRectByRoundingCornersCornerRadii<This extends abstract new (...args: any) => any>(this: This, rect: CGRect, corners: interop.Enum<typeof UIRectCorner>, cornerRadii: CGSize): InstanceType<This>;

  static bezierPathWithArcCenterRadiusStartAngleEndAngleClockwise<This extends abstract new (...args: any) => any>(this: This, center: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): InstanceType<This>;

  static bezierPathWithCGPath<This extends abstract new (...args: any) => any>(this: This, CGPath: interop.PointerConvertible): InstanceType<This>;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  get CGPath(): interop.Pointer;
  set CGPath(value: interop.PointerConvertible);

  moveToPoint(point: CGPoint): void;

  addLineToPoint(point: CGPoint): void;

  addCurveToPointControlPoint1ControlPoint2(endPoint: CGPoint, controlPoint1: CGPoint, controlPoint2: CGPoint): void;

  addQuadCurveToPointControlPoint(endPoint: CGPoint, controlPoint: CGPoint): void;

  addArcWithCenterRadiusStartAngleEndAngleClockwise(center: CGPoint, radius: number, startAngle: number, endAngle: number, clockwise: boolean): void;

  closePath(): void;

  removeAllPoints(): void;

  appendPath(bezierPath: UIBezierPath): void;

  bezierPathByReversingPath(): UIBezierPath;

  applyTransform(transform: CGAffineTransform): void;

  readonly isEmpty: boolean;

  readonly bounds: CGRect;

  readonly currentPoint: CGPoint;

  containsPoint(point: CGPoint): boolean;

  lineWidth: number;

  lineCapStyle: interop.Enum<typeof CGLineCap>;

  lineJoinStyle: interop.Enum<typeof CGLineJoin>;

  miterLimit: number;

  flatness: number;

  usesEvenOddFillRule: boolean;

  setLineDashCountPhase(pattern: interop.PointerConvertible, count: number, phase: number): void;

  getLineDashCountPhase(pattern: interop.PointerConvertible, count: interop.PointerConvertible, phase: interop.PointerConvertible): void;

  fill(): void;

  stroke(): void;

  fillWithBlendModeAlpha(blendMode: interop.Enum<typeof CGBlendMode>, alpha: number): void;

  strokeWithBlendModeAlpha(blendMode: interop.Enum<typeof CGBlendMode>, alpha: number): void;

  addClip(): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIAction extends UIMenuElement implements UIMenuLeaf {
  // @ts-ignore MemberDecl.tsIgnore
  title: string;

  // @ts-ignore MemberDecl.tsIgnore
  image: UIImage;

  discoverabilityTitle: string;

  readonly identifier: string;

  attributes: interop.Enum<typeof UIMenuElementAttributes>;

  state: interop.Enum<typeof UIMenuElementState>;

  readonly sender: interop.Object;

  static actionWithHandler<This extends abstract new (...args: any) => any>(this: This, handler: (p1: UIAction) => void): InstanceType<This>;

  static actionWithTitleImageIdentifierHandler<This extends abstract new (...args: any) => any>(this: This, title: string, image: UIImage | null, identifier: string | null, handler: (p1: UIAction) => void): InstanceType<This>;

  static captureTextFromCameraActionForResponderIdentifier<This extends abstract new (...args: any) => any>(this: This, responder: UIResponder, identifier: string | null): InstanceType<This>;

  selectedImage: UIImage;

  readonly presentationSourceItem: UIPopoverPresentationControllerSourceItem;

  performWithSenderTarget(sender: interop.Object | null, target: interop.Object | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIButton extends UIControl implements NSCoding {
  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  initWithFramePrimaryAction(frame: CGRect, primaryAction: UIAction | null): this;

  static buttonWithType<This extends abstract new (...args: any) => any>(this: This, buttonType: interop.Enum<typeof UIButtonType>): InstanceType<This>;

  static systemButtonWithImageTargetAction<This extends abstract new (...args: any) => any>(this: This, image: UIImage, target: interop.Object | null, action: string | null): InstanceType<This>;

  static systemButtonWithPrimaryAction<This extends abstract new (...args: any) => any>(this: This, primaryAction: UIAction | null): InstanceType<This>;

  static buttonWithTypePrimaryAction<This extends abstract new (...args: any) => any>(this: This, buttonType: interop.Enum<typeof UIButtonType>, primaryAction: UIAction | null): InstanceType<This>;

  static buttonWithConfigurationPrimaryAction<This extends abstract new (...args: any) => any>(this: This, configuration: UIButtonConfiguration, primaryAction: UIAction | null): InstanceType<This>;

  configuration: UIButtonConfiguration;

  setNeedsUpdateConfiguration(): void;

  updateConfiguration(): void;

  configurationUpdateHandler: (p1: UIButton) => void;

  automaticallyUpdatesConfiguration: boolean;

  tintColor: UIColor;

  readonly buttonType: interop.Enum<typeof UIButtonType>;

  readonly isHovered: boolean;

  readonly isHeld: boolean;

  role: interop.Enum<typeof UIButtonRole>;

  isPointerInteractionEnabled: boolean;

  pointerStyleProvider: (p1: UIButton, p2: UIPointerEffect, p3: UIPointerShape) => UIPointerStyle;

  menu: UIMenu;

  preferredMenuElementOrder: interop.Enum<typeof UIContextMenuConfigurationElementOrder>;

  changesSelectionAsPrimaryAction: boolean;

  setTitleForState(title: string | null, state: interop.Enum<typeof UIControlState>): void;

  setTitleColorForState(color: UIColor | null, state: interop.Enum<typeof UIControlState>): void;

  setTitleShadowColorForState(color: UIColor | null, state: interop.Enum<typeof UIControlState>): void;

  setImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  setBackgroundImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  setPreferredSymbolConfigurationForImageInState(configuration: UIImageSymbolConfiguration | null, state: interop.Enum<typeof UIControlState>): void;

  setAttributedTitleForState(title: NSAttributedString | null, state: interop.Enum<typeof UIControlState>): void;

  titleForState(state: interop.Enum<typeof UIControlState>): string;

  titleColorForState(state: interop.Enum<typeof UIControlState>): UIColor;

  titleShadowColorForState(state: interop.Enum<typeof UIControlState>): UIColor;

  imageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  backgroundImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  preferredSymbolConfigurationForImageInState(state: interop.Enum<typeof UIControlState>): UIImageSymbolConfiguration;

  attributedTitleForState(state: interop.Enum<typeof UIControlState>): NSAttributedString;

  readonly currentTitle: string;

  readonly currentTitleColor: UIColor;

  readonly currentTitleShadowColor: UIColor;

  readonly currentImage: UIImage;

  readonly currentBackgroundImage: UIImage;

  readonly currentPreferredSymbolConfiguration: UIImageSymbolConfiguration;

  readonly currentAttributedTitle: NSAttributedString;

  readonly titleLabel: UILabel;

  readonly imageView: UIImageView;

  readonly subtitleLabel: UILabel;

  font: UIFont;

  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  titleShadowOffset: CGSize;

  contentEdgeInsets: UIEdgeInsets;

  titleEdgeInsets: UIEdgeInsets;

  imageEdgeInsets: UIEdgeInsets;

  reversesTitleShadowWhenHighlighted: boolean;

  adjustsImageWhenHighlighted: boolean;

  adjustsImageWhenDisabled: boolean;

  showsTouchWhenHighlighted: boolean;

  backgroundRectForBounds(bounds: CGRect): CGRect;

  contentRectForBounds(bounds: CGRect): CGRect;

  titleRectForContentRect(contentRect: CGRect): CGRect;

  imageRectForContentRect(contentRect: CGRect): CGRect;

  readonly behavioralStyle: interop.Enum<typeof UIBehavioralStyle>;

  preferredBehavioralStyle: interop.Enum<typeof UIBehavioralStyle>;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIFocusUpdateContext extends NSObject {
  readonly previouslyFocusedItem: UIFocusItem;

  readonly nextFocusedItem: UIFocusItem;

  readonly previouslyFocusedView: UIView;

  readonly nextFocusedView: UIView;

  readonly focusHeading: interop.Enum<typeof UIFocusHeading>;
}

declare class UISwitch extends UIControl implements NSCoding {
  onTintColor: UIColor;

  thumbTintColor: UIColor;

  onImage: UIImage;

  offImage: UIImage;

  title: string;

  readonly style: interop.Enum<typeof UISwitchStyle>;

  preferredStyle: interop.Enum<typeof UISwitchStyle>;

  isOn: boolean;

  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  setOnAnimated(on: boolean, animated: boolean): void;

  encodeWithCoder(coder: NSCoder): void;
}

declare class NSCollectionLayoutBoundarySupplementaryItem extends NSCollectionLayoutSupplementaryItem implements NSCopying {
  static boundarySupplementaryItemWithLayoutSizeElementKindAlignment<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: interop.Enum<typeof NSRectAlignment>): InstanceType<This>;

  static boundarySupplementaryItemWithLayoutSizeElementKindAlignmentAbsoluteOffset<This extends abstract new (...args: any) => any>(this: This, layoutSize: NSCollectionLayoutSize, elementKind: string, alignment: interop.Enum<typeof NSRectAlignment>, absoluteOffset: CGPoint): InstanceType<This>;

  extendsBoundary: boolean;

  pinToVisibleBounds: boolean;

  readonly alignment: interop.Enum<typeof NSRectAlignment>;

  readonly offset: CGPoint;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIListContentView extends UIView implements UIContentView {
  initWithConfiguration(configuration: UIListContentConfiguration): this;

  initWithCoder(coder: NSCoder): this;

  configuration: UIListContentConfiguration;

  readonly textLayoutGuide: UILayoutGuide;

  readonly secondaryTextLayoutGuide: UILayoutGuide;

  readonly imageLayoutGuide: UILayoutGuide;

  supportsConfiguration(configuration: UIContentConfiguration): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIApplicationShortcutIcon extends NSObject implements NSCopying {
  static iconWithType<This extends abstract new (...args: any) => any>(this: This, type: interop.Enum<typeof UIApplicationShortcutIconType>): InstanceType<This>;

  static iconWithTemplateImageName<This extends abstract new (...args: any) => any>(this: This, templateImageName: string): InstanceType<This>;

  static iconWithSystemImageName<This extends abstract new (...args: any) => any>(this: This, systemImageName: string): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITableViewDropProposal extends UIDropProposal {
  initWithDropOperationIntent(operation: interop.Enum<typeof UIDropOperation>, intent: interop.Enum<typeof UITableViewDropIntent>): this;

  readonly intent: interop.Enum<typeof UITableViewDropIntent>;
}

declare class UITraitToolbarItemPresentationSize extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIActivityItemsConfiguration extends NSObject implements UIActivityItemsConfigurationReading {
  localObject: interop.Object;

  get supportedInteractions(): NSArray;
  set supportedInteractions(value: NSArray<interop.Object> | Array<interop.Object>);

  metadataProvider: (p1: string) => interop.Object | null;

  perItemMetadataProvider: (p1: number, p2: string) => interop.Object | null;

  previewProvider: (p1: number, p2: string, p3: CGSize) => NSItemProvider | null;

  applicationActivitiesProvider: () => NSArray;

  static activityItemsConfigurationWithObjects<This extends abstract new (...args: any) => any>(this: This, objects: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static activityItemsConfigurationWithItemProviders<This extends abstract new (...args: any) => any>(this: This, itemProviders: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithObjects(objects: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithItemProviders(itemProviders: NSArray<interop.Object> | Array<interop.Object>): this;

  readonly itemProvidersForActivityItemsConfiguration: NSArray;

  activityItemsConfigurationSupportsInteraction(interaction: string): boolean;

  activityItemsConfigurationMetadataForKey(key: string): interop.Object;

  activityItemsConfigurationMetadataForItemAtIndexKey(index: number, key: string): interop.Object;

  activityItemsConfigurationPreviewForItemAtIndexIntentSuggestedSize(index: number, intent: string, suggestedSize: CGSize): NSItemProvider;

  readonly applicationActivitiesForActivityItemsConfiguration: NSArray;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITraitLegibilityWeight extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIAccessibilityCustomRotorItemResult extends NSObject {
  initWithTargetElementTargetRange(targetElement: NSObject, targetRange: UITextRange | null): this;

  targetElement: NSObject | null;

  targetRange: UITextRange;
}

declare class UIDragPreviewTarget extends UIPreviewTarget {
}

declare class UITextInputMode extends NSObject implements NSSecureCoding {
  readonly primaryLanguage: string;

  static currentInputMode(): UITextInputMode;

  static readonly activeInputModes: NSArray;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UITraitSceneCaptureState extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIMarkupTextPrintFormatter extends UIPrintFormatter {
  initWithMarkupText(markupText: string): this;

  markupText: string;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIKeyCommand extends UICommand {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  // @ts-ignore MemberDecl.tsIgnore
  title: string;

  // @ts-ignore MemberDecl.tsIgnore
  image: UIImage;

  discoverabilityTitle: string;

  readonly action: string;

  readonly input: string;

  readonly modifierFlags: interop.Enum<typeof UIKeyModifierFlags>;

  readonly propertyList: interop.Object;

  attributes: interop.Enum<typeof UIMenuElementAttributes>;

  state: interop.Enum<typeof UIMenuElementState>;

  readonly alternates: NSArray;

  wantsPriorityOverSystemBehavior: boolean;

  allowsAutomaticLocalization: boolean;

  allowsAutomaticMirroring: boolean;

  static commandWithTitleImageActionInputModifierFlagsPropertyList<This extends abstract new (...args: any) => any>(this: This, title: string, image: UIImage | null, action: string, input: string, modifierFlags: interop.Enum<typeof UIKeyModifierFlags>, propertyList: interop.Object | null): InstanceType<This>;

  static commandWithTitleImageActionInputModifierFlagsPropertyListAlternates<This extends abstract new (...args: any) => any>(this: This, title: string, image: UIImage | null, action: string, input: string, modifierFlags: interop.Enum<typeof UIKeyModifierFlags>, propertyList: interop.Object | null, alternates: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static keyCommandWithInputModifierFlagsAction<This extends abstract new (...args: any) => any>(this: This, input: string, modifierFlags: interop.Enum<typeof UIKeyModifierFlags>, action: string): InstanceType<This>;

  static keyCommandWithInputModifierFlagsActionDiscoverabilityTitle<This extends abstract new (...args: any) => any>(this: This, input: string, modifierFlags: interop.Enum<typeof UIKeyModifierFlags>, action: string, discoverabilityTitle: string): InstanceType<This>;
}

declare class NSTextContentManager extends NSObject implements NSTextElementProvider, NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  delegate: NSTextContentManagerDelegate;

  readonly textLayoutManagers: NSArray;

  addTextLayoutManager(textLayoutManager: NSTextLayoutManager): void;

  removeTextLayoutManager(textLayoutManager: NSTextLayoutManager): void;

  primaryTextLayoutManager: NSTextLayoutManager;

  synchronizeTextLayoutManagers(completionHandler: (p1: NSError) => void | null): void;

  textElementsForRange(range: NSTextRange): NSArray;

  readonly hasEditingTransaction: boolean;

  performEditingTransactionUsingBlock(transaction: () => void): void;

  recordEditActionInRangeNewTextRange(originalTextRange: NSTextRange, newTextRange: NSTextRange): void;

  automaticallySynchronizesTextLayoutManagers: boolean;

  automaticallySynchronizesToBackingStore: boolean;

  readonly documentRange: NSTextRange;

  enumerateTextElementsFromLocationOptionsUsingBlock(textLocation: NSTextLocation | null, options: interop.Enum<typeof NSTextContentManagerEnumerationOptions>, block: (p1: NSTextElement) => boolean): NSTextLocation;

  replaceContentsInRangeWithTextElements(range: NSTextRange, textElements: NSArray<interop.Object> | Array<interop.Object> | null): void;

  synchronizeToBackingStore(completionHandler: (p1: NSError) => void | null): void;

  locationFromLocationWithOffset(location: NSTextLocation, offset: number): NSTextLocation;

  offsetFromLocationToLocation(from: NSTextLocation, to: NSTextLocation): number;

  adjustedRangeFromRangeForEditingTextSelection(textRange: NSTextRange, forEditingTextSelection: boolean): NSTextRange;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIMenu extends UIMenuElement {
  readonly identifier: string;

  readonly options: interop.Enum<typeof UIMenuOptions>;

  preferredElementSize: interop.Enum<typeof UIMenuElementSize>;

  readonly children: NSArray;

  readonly selectedElements: NSArray;

  displayPreferences: UIMenuDisplayPreferences;

  static menuWithChildren(children: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  static menuWithTitleChildren(title: string, children: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  static menuWithTitleImageIdentifierOptionsChildren(title: string, image: UIImage | null, identifier: string | null, options: interop.Enum<typeof UIMenuOptions>, children: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  initWithCoder(coder: NSCoder): this;

  menuByReplacingChildren(newChildren: NSArray<interop.Object> | Array<interop.Object>): UIMenu;
}

declare class UIActivity extends NSObject {
  static readonly activityCategory: interop.Enum<typeof UIActivityCategory>;

  readonly activityType: string;

  readonly activityTitle: string;

  readonly activityImage: UIImage;

  canPerformWithActivityItems(activityItems: NSArray<interop.Object> | Array<interop.Object>): boolean;

  prepareWithActivityItems(activityItems: NSArray<interop.Object> | Array<interop.Object>): void;

  readonly activityViewController: UIViewController;

  performActivity(): void;

  activityDidFinish(completed: boolean): void;
}

declare class UIStepper extends UIControl {
  isContinuous: boolean;

  autorepeat: boolean;

  wraps: boolean;

  value: number;

  minimumValue: number;

  maximumValue: number;

  stepValue: number;

  setBackgroundImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  backgroundImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  setDividerImageForLeftSegmentStateRightSegmentState(image: UIImage | null, leftState: interop.Enum<typeof UIControlState>, rightState: interop.Enum<typeof UIControlState>): void;

  dividerImageForLeftSegmentStateRightSegmentState(state: interop.Enum<typeof UIControlState>, state_: interop.Enum<typeof UIControlState>): UIImage;

  setIncrementImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  incrementImageForState(state: interop.Enum<typeof UIControlState>): UIImage;

  setDecrementImageForState(image: UIImage | null, state: interop.Enum<typeof UIControlState>): void;

  decrementImageForState(state: interop.Enum<typeof UIControlState>): UIImage;
}

declare class UIEvent extends NSObject {
  readonly type: interop.Enum<typeof UIEventType>;

  readonly subtype: interop.Enum<typeof UIEventSubtype>;

  readonly timestamp: number;

  readonly modifierFlags: interop.Enum<typeof UIKeyModifierFlags>;

  readonly buttonMask: interop.Enum<typeof UIEventButtonMask>;

  readonly allTouches: NSSet;

  touchesForWindow(window: UIWindow): NSSet;

  touchesForView(view: UIView): NSSet;

  touchesForGestureRecognizer(gesture: UIGestureRecognizer): NSSet;

  coalescedTouchesForTouch(touch: UITouch): NSArray;

  predictedTouchesForTouch(touch: UITouch): NSArray;
}

declare class UICalendarView extends UIView {
  delegate: UICalendarViewDelegate;

  selectionBehavior: UICalendarSelection;

  locale: NSLocale;

  calendar: NSCalendar;

  timeZone: NSTimeZone;

  fontDesign: string;

  availableDateRange: NSDateInterval;

  visibleDateComponents: NSDateComponents;

  setVisibleDateComponentsAnimated(dateComponents: NSDateComponents, animated: boolean): void;

  wantsDateDecorations: boolean;

  reloadDecorationsForDateComponentsAnimated(dates: NSArray<interop.Object> | Array<interop.Object>, animated: boolean): void;
}

declare class UIMenuElement extends NSObject implements NSCopying, NSSecureCoding {
  readonly title: string;

  subtitle: string;

  readonly image: UIImage;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UICollectionViewFocusUpdateContext extends UIFocusUpdateContext {
  readonly previouslyFocusedIndexPath: NSIndexPath;

  readonly nextFocusedIndexPath: NSIndexPath;
}

declare class NSStringDrawingContext extends NSObject {
  minimumScaleFactor: number;

  readonly actualScaleFactor: number;

  readonly totalBounds: CGRect;

  minimumTrackingAdjustment: number;

  readonly actualTrackingAdjustment: number;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIMutableUserNotificationAction extends UIUserNotificationAction {
  // @ts-ignore MemberDecl.tsIgnore
  identifier: string;

  // @ts-ignore MemberDecl.tsIgnore
  title: string;

  // @ts-ignore MemberDecl.tsIgnore
  behavior: interop.Enum<typeof UIUserNotificationActionBehavior>;

  // @ts-ignore MemberDecl.tsIgnore
  get parameters(): NSDictionary;
  // @ts-ignore MemberDecl.tsIgnore
  set parameters(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  // @ts-ignore MemberDecl.tsIgnore
  activationMode: interop.Enum<typeof UIUserNotificationActivationMode>;

  // @ts-ignore MemberDecl.tsIgnore
  isAuthenticationRequired: boolean;

  // @ts-ignore MemberDecl.tsIgnore
  isDestructive: boolean;
}

declare class UIListSeparatorConfiguration extends NSObject implements NSCopying, NSSecureCoding {
  initWithListAppearance(listAppearance: interop.Enum<typeof UICollectionLayoutListAppearance>): this;

  topSeparatorVisibility: interop.Enum<typeof UIListSeparatorVisibility>;

  bottomSeparatorVisibility: interop.Enum<typeof UIListSeparatorVisibility>;

  topSeparatorInsets: NSDirectionalEdgeInsets;

  bottomSeparatorInsets: NSDirectionalEdgeInsets;

  color: UIColor;

  multipleSelectionColor: UIColor;

  visualEffect: UIVisualEffect;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIColorPickerViewController extends UIViewController {
  delegate: UIColorPickerViewControllerDelegate;

  selectedColor: UIColor;

  supportsAlpha: boolean;

  init(): this;
}

declare class NSCollectionLayoutAnchor extends NSObject implements NSCopying {
  static layoutAnchorWithEdges<This extends abstract new (...args: any) => any>(this: This, edges: interop.Enum<typeof NSDirectionalRectEdge>): InstanceType<This>;

  static layoutAnchorWithEdgesAbsoluteOffset<This extends abstract new (...args: any) => any>(this: This, edges: interop.Enum<typeof NSDirectionalRectEdge>, absoluteOffset: CGPoint): InstanceType<This>;

  static layoutAnchorWithEdgesFractionalOffset<This extends abstract new (...args: any) => any>(this: This, edges: interop.Enum<typeof NSDirectionalRectEdge>, fractionalOffset: CGPoint): InstanceType<This>;

  readonly edges: interop.Enum<typeof NSDirectionalRectEdge>;

  readonly offset: CGPoint;

  readonly isAbsoluteOffset: boolean;

  readonly isFractionalOffset: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UINavigationBarAppearance extends UIBarAppearance {
  get titleTextAttributes(): NSDictionary;
  set titleTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  titlePositionAdjustment: UIOffset;

  get largeTitleTextAttributes(): NSDictionary;
  set largeTitleTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  buttonAppearance: UIBarButtonItemAppearance;

  doneButtonAppearance: UIBarButtonItemAppearance;

  backButtonAppearance: UIBarButtonItemAppearance;

  readonly backIndicatorImage: UIImage;

  readonly backIndicatorTransitionMaskImage: UIImage;

  setBackIndicatorImageTransitionMaskImage(backIndicatorImage: UIImage | null, backIndicatorTransitionMaskImage: UIImage | null): void;
}

declare class NSTextTab extends NSObject implements NSCopying, NSCoding, NSSecureCoding {
  static columnTerminatorsForLocale(aLocale: NSLocale | null): NSCharacterSet;

  initWithTextAlignmentLocationOptions(alignment: interop.Enum<typeof NSTextAlignment>, loc: number, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  readonly alignment: interop.Enum<typeof NSTextAlignment>;

  readonly location: number;

  readonly options: NSDictionary;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  static readonly supportsSecureCoding: boolean;
}

declare class UIImageSymbolConfiguration extends UIImageConfiguration {
  static readonly unspecifiedConfiguration: UIImageSymbolConfiguration;

  static configurationWithScale<This extends abstract new (...args: any) => any>(this: This, scale: interop.Enum<typeof UIImageSymbolScale>): InstanceType<This>;

  static configurationWithPointSize<This extends abstract new (...args: any) => any>(this: This, pointSize: number): InstanceType<This>;

  static configurationWithWeight<This extends abstract new (...args: any) => any>(this: This, weight: interop.Enum<typeof UIImageSymbolWeight>): InstanceType<This>;

  static configurationWithPointSizeWeight<This extends abstract new (...args: any) => any>(this: This, pointSize: number, weight: interop.Enum<typeof UIImageSymbolWeight>): InstanceType<This>;

  static configurationWithPointSizeWeightScale<This extends abstract new (...args: any) => any>(this: This, pointSize: number, weight: interop.Enum<typeof UIImageSymbolWeight>, scale: interop.Enum<typeof UIImageSymbolScale>): InstanceType<This>;

  static configurationWithTextStyle<This extends abstract new (...args: any) => any>(this: This, textStyle: string): InstanceType<This>;

  static configurationWithTextStyleScale<This extends abstract new (...args: any) => any>(this: This, textStyle: string, scale: interop.Enum<typeof UIImageSymbolScale>): InstanceType<This>;

  static configurationWithFont<This extends abstract new (...args: any) => any>(this: This, font: UIFont): InstanceType<This>;

  static configurationWithFontScale<This extends abstract new (...args: any) => any>(this: This, font: UIFont, scale: interop.Enum<typeof UIImageSymbolScale>): InstanceType<This>;

  static configurationWithHierarchicalColor<This extends abstract new (...args: any) => any>(this: This, hierarchicalColor: UIColor): InstanceType<This>;

  static configurationWithPaletteColors<This extends abstract new (...args: any) => any>(this: This, paletteColors: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static configurationPreferringMulticolor<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static configurationPreferringMonochrome<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  configurationWithoutTextStyle(): this;

  configurationWithoutScale(): this;

  configurationWithoutWeight(): this;

  configurationWithoutPointSizeAndWeight(): this;

  isEqualToConfiguration(otherConfiguration: UIImageSymbolConfiguration | null): boolean;
}

declare class UIImage extends NSObject implements NSSecureCoding {
  static systemImageNamed(name: string): UIImage;

  static systemImageNamedWithConfiguration(name: string, configuration: UIImageConfiguration | null): UIImage;

  static systemImageNamedCompatibleWithTraitCollection(name: string, traitCollection: UITraitCollection | null): UIImage;

  static systemImageNamedVariableValueWithConfiguration(name: string, value: number, configuration: UIImageConfiguration | null): UIImage;

  static imageNamed(name: string): UIImage;

  static imageNamedInBundleWithConfiguration(name: string, bundle: NSBundle | null, configuration: UIImageConfiguration | null): UIImage;

  static imageNamedInBundleCompatibleWithTraitCollection(name: string, bundle: NSBundle | null, traitCollection: UITraitCollection | null): UIImage;

  static imageNamedInBundleVariableValueWithConfiguration(name: string, bundle: NSBundle | null, value: number, configuration: UIImageConfiguration | null): UIImage;

  static imageWithContentsOfFile(path: string): UIImage;

  static imageWithData(data: NSData): UIImage;

  static imageWithDataScale(data: NSData, scale: number): UIImage;

  static imageWithCGImage(cgImage: interop.PointerConvertible): UIImage;

  static imageWithCGImageScaleOrientation(cgImage: interop.PointerConvertible, scale: number, orientation: interop.Enum<typeof UIImageOrientation>): UIImage;

  static imageWithCIImage(ciImage: CIImage): UIImage;

  static imageWithCIImageScaleOrientation(ciImage: CIImage, scale: number, orientation: interop.Enum<typeof UIImageOrientation>): UIImage;

  initWithContentsOfFile(path: string): this;

  initWithData(data: NSData): this;

  initWithDataScale(data: NSData, scale: number): this;

  initWithCGImage(cgImage: interop.PointerConvertible): this;

  initWithCGImageScaleOrientation(cgImage: interop.PointerConvertible, scale: number, orientation: interop.Enum<typeof UIImageOrientation>): this;

  initWithCIImage(ciImage: CIImage): this;

  initWithCIImageScaleOrientation(ciImage: CIImage, scale: number, orientation: interop.Enum<typeof UIImageOrientation>): this;

  readonly size: CGSize;

  readonly CGImage: interop.Pointer;

  readonly CIImage: CIImage;

  readonly imageOrientation: interop.Enum<typeof UIImageOrientation>;

  readonly scale: number;

  readonly isSymbolImage: boolean;

  static animatedImageNamedDuration(name: string, duration: number): UIImage;

  static animatedResizableImageNamedCapInsetsDuration(name: string, capInsets: UIEdgeInsets, duration: number): UIImage;

  static animatedResizableImageNamedCapInsetsResizingModeDuration(name: string, capInsets: UIEdgeInsets, resizingMode: interop.Enum<typeof UIImageResizingMode>, duration: number): UIImage;

  static animatedImageWithImagesDuration(images: NSArray<interop.Object> | Array<interop.Object>, duration: number): UIImage;

  readonly images: NSArray;

  readonly duration: number;

  drawAtPoint(point: CGPoint): void;

  drawAtPointBlendModeAlpha(point: CGPoint, blendMode: interop.Enum<typeof CGBlendMode>, alpha: number): void;

  drawInRect(rect: CGRect): void;

  drawInRectBlendModeAlpha(rect: CGRect, blendMode: interop.Enum<typeof CGBlendMode>, alpha: number): void;

  drawAsPatternInRect(rect: CGRect): void;

  resizableImageWithCapInsets(capInsets: UIEdgeInsets): UIImage;

  resizableImageWithCapInsetsResizingMode(capInsets: UIEdgeInsets, resizingMode: interop.Enum<typeof UIImageResizingMode>): UIImage;

  readonly capInsets: UIEdgeInsets;

  readonly resizingMode: interop.Enum<typeof UIImageResizingMode>;

  imageWithAlignmentRectInsets(alignmentInsets: UIEdgeInsets): UIImage;

  readonly alignmentRectInsets: UIEdgeInsets;

  imageWithRenderingMode(renderingMode: interop.Enum<typeof UIImageRenderingMode>): UIImage;

  readonly renderingMode: interop.Enum<typeof UIImageRenderingMode>;

  readonly imageRendererFormat: UIGraphicsImageRendererFormat;

  readonly traitCollection: UITraitCollection;

  readonly imageAsset: UIImageAsset;

  imageFlippedForRightToLeftLayoutDirection(): UIImage;

  readonly flipsForRightToLeftLayoutDirection: boolean;

  imageWithHorizontallyFlippedOrientation(): UIImage;

  readonly baselineOffsetFromBottom: number;

  readonly hasBaseline: boolean;

  imageWithBaselineOffsetFromBottom(baselineOffset: number): UIImage;

  imageWithoutBaseline(): UIImage;

  readonly configuration: UIImageConfiguration;

  imageWithConfiguration(configuration: UIImageConfiguration): UIImage;

  readonly symbolConfiguration: UIImageSymbolConfiguration;

  imageByApplyingSymbolConfiguration(configuration: UIImageSymbolConfiguration): UIImage;

  imageWithTintColor(color: UIColor): UIImage;

  imageWithTintColorRenderingMode(color: UIColor, renderingMode: interop.Enum<typeof UIImageRenderingMode>): UIImage;

  imageByPreparingForDisplay(): UIImage;

  prepareForDisplayWithCompletionHandler(completionHandler: (p1: UIImage) => void | null): void;

  imageByPreparingThumbnailOfSize(size: CGSize): UIImage;

  prepareThumbnailOfSizeCompletionHandler(size: CGSize, completionHandler: (p1: UIImage) => void | null): void;

  readonly isHighDynamicRange: boolean;

  imageRestrictedToStandardDynamicRange(): UIImage;

  static readonly actionsImage: UIImage;

  static readonly addImage: UIImage;

  static readonly removeImage: UIImage;

  static readonly checkmarkImage: UIImage;

  static readonly strokedCheckmarkImage: UIImage;

  stretchableImageWithLeftCapWidthTopCapHeight(leftCapWidth: number, topCapHeight: number): UIImage;

  readonly leftCapWidth: number;

  readonly topCapHeight: number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UICloudSharingController extends UIViewController {
  initWithPreparationHandler(preparationHandler: (p1: UICloudSharingController, p2: (p1: CKShare, p2: CKContainer, p3: NSError) => void) => void | null): this;

  initWithShareContainer(share: CKShare, container: CKContainer): this;

  delegate: UICloudSharingControllerDelegate | null;

  readonly share: CKShare;

  availablePermissions: interop.Enum<typeof UICloudSharingPermissionOptions>;

  activityItemSource(): UIActivityItemSource;
}

declare class NSTextAttachment extends NSObject implements NSTextAttachmentLayout, NSTextAttachmentContainer, NSSecureCoding {
  initWithDataOfType(contentData: NSData | null, uti: string | null): this;

  contents: NSData;

  fileType: string;

  image: UIImage;

  bounds: CGRect;

  fileWrapper: NSFileWrapper;

  lineLayoutPadding: number;

  static textAttachmentViewProviderClassForFileType(fileType: string): interop.Object;

  static registerTextAttachmentViewProviderClassForFileType(textAttachmentViewProviderClass: interop.Object, fileType: string): void;

  allowsTextAttachmentView: boolean;

  readonly usesTextAttachmentView: boolean;

  static textAttachmentWithImage(image: UIImage): NSTextAttachment;

  imageForBoundsAttributesLocationTextContainer(bounds: CGRect, attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, location: NSTextLocation, textContainer: NSTextContainer | null): UIImage;

  attachmentBoundsForAttributesLocationTextContainerProposedLineFragmentPosition(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, location: NSTextLocation, textContainer: NSTextContainer | null, proposedLineFragment: CGRect, position: CGPoint): CGRect;

  viewProviderForParentViewLocationTextContainer(parentView: UIView | null, location: NSTextLocation, textContainer: NSTextContainer | null): NSTextAttachmentViewProvider;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  imageForBoundsTextContainerCharacterIndex(imageBounds: CGRect, textContainer: NSTextContainer | null, charIndex: number): UIImage;

  attachmentBoundsForTextContainerProposedLineFragmentGlyphPositionCharacterIndex(textContainer: NSTextContainer | null, lineFrag: CGRect, position: CGPoint, charIndex: number): CGRect;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UILayoutGuide extends NSObject implements NSCoding {
  readonly layoutFrame: CGRect;

  owningView: UIView;

  identifier: string;

  readonly leadingAnchor: NSLayoutXAxisAnchor;

  readonly trailingAnchor: NSLayoutXAxisAnchor;

  readonly leftAnchor: NSLayoutXAxisAnchor;

  readonly rightAnchor: NSLayoutXAxisAnchor;

  readonly topAnchor: NSLayoutYAxisAnchor;

  readonly bottomAnchor: NSLayoutYAxisAnchor;

  readonly widthAnchor: NSLayoutDimension;

  readonly heightAnchor: NSLayoutDimension;

  readonly centerXAnchor: NSLayoutXAxisAnchor;

  readonly centerYAnchor: NSLayoutYAxisAnchor;

  constraintsAffectingLayoutForAxis(axis: interop.Enum<typeof UILayoutConstraintAxis>): NSArray;

  readonly hasAmbiguousLayout: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIFontDescriptor extends NSObject implements NSCopying, NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  readonly postscriptName: string;

  readonly pointSize: number;

  readonly matrix: CGAffineTransform;

  readonly symbolicTraits: interop.Enum<typeof UIFontDescriptorSymbolicTraits>;

  objectForKey(anAttribute: string): interop.Object;

  readonly fontAttributes: NSDictionary;

  matchingFontDescriptorsWithMandatoryKeys(mandatoryKeys: NSSet | null): NSArray;

  static fontDescriptorWithFontAttributes(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): UIFontDescriptor;

  static fontDescriptorWithNameSize(fontName: string, size: number): UIFontDescriptor;

  static fontDescriptorWithNameMatrix(fontName: string, matrix: CGAffineTransform): UIFontDescriptor;

  static preferredFontDescriptorWithTextStyle(style: string): UIFontDescriptor;

  static preferredFontDescriptorWithTextStyleCompatibleWithTraitCollection(style: string, traitCollection: UITraitCollection | null): UIFontDescriptor;

  initWithFontAttributes(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): this;

  fontDescriptorByAddingAttributes(attributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): UIFontDescriptor;

  fontDescriptorWithSize(newPointSize: number): UIFontDescriptor;

  fontDescriptorWithMatrix(matrix: CGAffineTransform): UIFontDescriptor;

  fontDescriptorWithFace(newFace: string): UIFontDescriptor;

  fontDescriptorWithFamily(newFamily: string): UIFontDescriptor;

  fontDescriptorWithSymbolicTraits(symbolicTraits: interop.Enum<typeof UIFontDescriptorSymbolicTraits>): UIFontDescriptor;

  fontDescriptorWithDesign(design: string): UIFontDescriptor;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UILocalNotification extends NSObject implements NSCopying, NSCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  fireDate: NSDate;

  timeZone: NSTimeZone;

  repeatInterval: interop.Enum<typeof NSCalendarUnit>;

  repeatCalendar: NSCalendar;

  region: CLRegion;

  regionTriggersOnce: boolean;

  alertBody: string;

  hasAction: boolean;

  alertAction: string;

  alertLaunchImage: string;

  alertTitle: string;

  soundName: string;

  applicationIconBadgeNumber: number;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  category: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UITextField extends UIControl implements UITextInput, NSCoding, UIContentSizeCategoryAdjusting, UILetterformAwareAdjusting {
  text: string;

  attributedText: NSAttributedString;

  textColor: UIColor;

  font: UIFont;

  textAlignment: interop.Enum<typeof NSTextAlignment>;

  borderStyle: interop.Enum<typeof UITextBorderStyle>;

  get defaultTextAttributes(): NSDictionary;
  set defaultTextAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  placeholder: string;

  attributedPlaceholder: NSAttributedString;

  clearsOnBeginEditing: boolean;

  adjustsFontSizeToFitWidth: boolean;

  minimumFontSize: number;

  delegate: UITextFieldDelegate;

  background: UIImage;

  disabledBackground: UIImage;

  readonly isEditing: boolean;

  allowsEditingTextAttributes: boolean;

  get typingAttributes(): NSDictionary;
  set typingAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  clearButtonMode: interop.Enum<typeof UITextFieldViewMode>;

  leftView: UIView;

  leftViewMode: interop.Enum<typeof UITextFieldViewMode>;

  rightView: UIView;

  rightViewMode: interop.Enum<typeof UITextFieldViewMode>;

  borderRectForBounds(bounds: CGRect): CGRect;

  textRectForBounds(bounds: CGRect): CGRect;

  placeholderRectForBounds(bounds: CGRect): CGRect;

  editingRectForBounds(bounds: CGRect): CGRect;

  clearButtonRectForBounds(bounds: CGRect): CGRect;

  leftViewRectForBounds(bounds: CGRect): CGRect;

  rightViewRectForBounds(bounds: CGRect): CGRect;

  drawTextInRect(rect: CGRect): void;

  drawPlaceholderInRect(rect: CGRect): void;

  // @ts-ignore MemberDecl.tsIgnore
  inputView: UIView;

  // @ts-ignore MemberDecl.tsIgnore
  inputAccessoryView: UIView;

  clearsOnInsertion: boolean;

  interactionState: interop.Object;

  textInRange(range: UITextRange): string;

  replaceRangeWithText(range: UITextRange, text: string): void;

  selectedTextRange: UITextRange;

  readonly markedTextRange: UITextRange;

  get markedTextStyle(): NSDictionary;
  set markedTextStyle(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  setMarkedTextSelectedRange(markedText: string | null, selectedRange: _NSRange): void;

  unmarkText(): void;

  readonly beginningOfDocument: UITextPosition;

  readonly endOfDocument: UITextPosition;

  textRangeFromPositionToPosition(fromPosition: UITextPosition, toPosition: UITextPosition): UITextRange;

  positionFromPositionOffset(position: UITextPosition, offset: number): UITextPosition;

  positionFromPositionInDirectionOffset(position: UITextPosition, direction: interop.Enum<typeof UITextLayoutDirection>, offset: number): UITextPosition;

  comparePositionToPosition(position: UITextPosition, other: UITextPosition): interop.Enum<typeof NSComparisonResult>;

  offsetFromPositionToPosition(from: UITextPosition, toPosition: UITextPosition): number;

  inputDelegate: UITextInputDelegate;

  readonly tokenizer: UITextInputTokenizer;

  positionWithinRangeFarthestInDirection(range: UITextRange, direction: interop.Enum<typeof UITextLayoutDirection>): UITextPosition;

  characterRangeByExtendingPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextLayoutDirection>): UITextRange;

  baseWritingDirectionForPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextStorageDirection>): interop.Enum<typeof NSWritingDirection>;

  setBaseWritingDirectionForRange(writingDirection: interop.Enum<typeof NSWritingDirection>, range: UITextRange): void;

  firstRectForRange(range: UITextRange): CGRect;

  caretRectForPosition(position: UITextPosition): CGRect;

  selectionRectsForRange(range: UITextRange): NSArray;

  closestPositionToPoint(point: CGPoint): UITextPosition;

  closestPositionToPointWithinRange(point: CGPoint, range: UITextRange): UITextPosition;

  characterRangeAtPoint(point: CGPoint): UITextRange;

  shouldChangeTextInRangeReplacementText(range: UITextRange, text: string): boolean;

  textStylingAtPositionInDirection(position: UITextPosition, direction: interop.Enum<typeof UITextStorageDirection>): NSDictionary;

  positionWithinRangeAtCharacterOffset(range: UITextRange, offset: number): UITextPosition;

  characterOffsetOfPositionWithinRange(position: UITextPosition, range: UITextRange): number;

  readonly textInputView: UIView;

  selectionAffinity: interop.Enum<typeof UITextStorageDirection>;

  insertDictationResult(dictationResult: NSArray<interop.Object> | Array<interop.Object>): void;

  dictationRecordingDidEnd(): void;

  dictationRecognitionFailed(): void;

  readonly insertDictationResultPlaceholder: interop.Object;

  frameForDictationResultPlaceholder(placeholder: interop.Object): CGRect;

  removeDictationResultPlaceholderWillInsertResult(placeholder: interop.Object, willInsertResult: boolean): void;

  insertTextAlternativesStyle(text: string, alternatives: NSArray<interop.Object> | Array<interop.Object>, style: interop.Enum<typeof UITextAlternativeStyle>): void;

  setAttributedMarkedTextSelectedRange(markedText: NSAttributedString | null, selectedRange: _NSRange): void;

  insertTextPlaceholderWithSize(size: CGSize): UITextPlaceholder;

  removeTextPlaceholder(textPlaceholder: UITextPlaceholder): void;

  beginFloatingCursorAtPoint(point: CGPoint): void;

  updateFloatingCursorAtPoint(point: CGPoint): void;

  endFloatingCursor(): void;

  caretTransformForPosition(position: UITextPosition): CGAffineTransform;

  editMenuForTextRangeSuggestedActions(textRange: UITextRange, suggestedActions: NSArray<interop.Object> | Array<interop.Object>): UIMenu;

  willPresentEditMenuWithAnimator(animator: UIEditMenuInteractionAnimating): void;

  willDismissEditMenuWithAnimator(animator: UIEditMenuInteractionAnimating): void;

  readonly hasText: boolean;

  insertText(text: string): void;

  deleteBackward(): void;

  autocapitalizationType: interop.Enum<typeof UITextAutocapitalizationType>;

  autocorrectionType: interop.Enum<typeof UITextAutocorrectionType>;

  spellCheckingType: interop.Enum<typeof UITextSpellCheckingType>;

  smartQuotesType: interop.Enum<typeof UITextSmartQuotesType>;

  smartDashesType: interop.Enum<typeof UITextSmartDashesType>;

  smartInsertDeleteType: interop.Enum<typeof UITextSmartInsertDeleteType>;

  inlinePredictionType: interop.Enum<typeof UITextInlinePredictionType>;

  keyboardType: interop.Enum<typeof UIKeyboardType>;

  keyboardAppearance: interop.Enum<typeof UIKeyboardAppearance>;

  returnKeyType: interop.Enum<typeof UIReturnKeyType>;

  enablesReturnKeyAutomatically: boolean;

  isSecureTextEntry: boolean;

  textContentType: string;

  passwordRules: UITextInputPasswordRules;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  adjustsFontForContentSizeCategory: boolean;

  sizingRule: interop.Enum<typeof UILetterformAwareSizingRule>;
}

declare class UIPickerView extends UIView implements NSCoding {
  dataSource: UIPickerViewDataSource;

  delegate: UIPickerViewDelegate;

  showsSelectionIndicator: boolean;

  readonly numberOfComponents: number;

  numberOfRowsInComponent(component: number): number;

  rowSizeForComponent(component: number): CGSize;

  viewForRowForComponent(row: number, component: number): UIView;

  reloadAllComponents(): void;

  reloadComponent(component: number): void;

  selectRowInComponentAnimated(row: number, component: number, animated: boolean): void;

  selectedRowInComponent(component: number): number;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIGraphicsPDFRenderer extends UIGraphicsRenderer {
  // @ts-ignore MemberDecl.tsIgnore
  initWithBoundsFormat(bounds: CGRect, format: UIGraphicsPDFRendererFormat): this;

  writePDFToURLWithActionsError(url: NSURL, actions: (p1: UIGraphicsPDFRendererContext) => void, error: interop.PointerConvertible): boolean;

  PDFDataWithActions(actions: (p1: UIGraphicsPDFRendererContext) => void): NSData;
}

declare class UISpringTimingParameters extends NSObject implements UITimingCurveProvider {
  readonly initialVelocity: CGVector;

  init(): this;

  initWithCoder(coder: NSCoder): this;

  initWithDampingRatioInitialVelocity(ratio: number, velocity: CGVector): this;

  initWithMassStiffnessDampingInitialVelocity(mass: number, stiffness: number, damping: number, velocity: CGVector): this;

  initWithDampingRatio(ratio: number): this;

  initWithDurationBounceInitialVelocity(duration: number, bounce: number, velocity: CGVector): this;

  initWithDurationBounce(duration: number, bounce: number): this;

  readonly timingCurveType: interop.Enum<typeof UITimingCurveType>;

  readonly cubicTimingParameters: UICubicTimingParameters;

  readonly springTimingParameters: UISpringTimingParameters;

  encodeWithCoder(coder: NSCoder): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPressesEvent extends UIEvent {
  readonly allPresses: NSSet;

  pressesForGestureRecognizer(gesture: UIGestureRecognizer): NSSet;
}

declare class UICollisionBehavior extends UIDynamicBehavior {
  initWithItems(items: NSArray<interop.Object> | Array<interop.Object>): this;

  addItem(item: UIDynamicItem): void;

  removeItem(item: UIDynamicItem): void;

  readonly items: NSArray;

  collisionMode: interop.Enum<typeof UICollisionBehaviorMode>;

  translatesReferenceBoundsIntoBoundary: boolean;

  setTranslatesReferenceBoundsIntoBoundaryWithInsets(insets: UIEdgeInsets): void;

  addBoundaryWithIdentifierForPath(identifier: NSCopying, bezierPath: UIBezierPath): void;

  addBoundaryWithIdentifierFromPointToPoint(identifier: NSCopying, p1: CGPoint, p2: CGPoint): void;

  boundaryWithIdentifier(identifier: NSCopying): UIBezierPath;

  removeBoundaryWithIdentifier(identifier: NSCopying): void;

  readonly boundaryIdentifiers: NSArray;

  removeAllBoundaries(): void;

  collisionDelegate: UICollisionBehaviorDelegate;
}

declare class UITextItem extends NSObject {
  readonly contentType: interop.Enum<typeof UITextItemContentType>;

  readonly range: _NSRange;

  readonly link: NSURL;

  readonly textAttachment: NSTextAttachment;

  readonly tagIdentifier: string;
}

declare class UITraitAccessibilityContrast extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UISplitViewController extends UIViewController {
  initWithCoder(coder: NSCoder): this;

  initWithNibNameBundle(nibNameOrNil: string | null, nibBundleOrNil: NSBundle | null): this;

  initWithStyle(style: interop.Enum<typeof UISplitViewControllerStyle>): this;

  readonly style: interop.Enum<typeof UISplitViewControllerStyle>;

  delegate: UISplitViewControllerDelegate;

  showsSecondaryOnlyButton: boolean;

  preferredSplitBehavior: interop.Enum<typeof UISplitViewControllerSplitBehavior>;

  readonly splitBehavior: interop.Enum<typeof UISplitViewControllerSplitBehavior>;

  setViewControllerForColumn(vc: UIViewController | null, column: interop.Enum<typeof UISplitViewControllerColumn>): void;

  viewControllerForColumn(column: interop.Enum<typeof UISplitViewControllerColumn>): UIViewController;

  hideColumn(column: interop.Enum<typeof UISplitViewControllerColumn>): void;

  showColumn(column: interop.Enum<typeof UISplitViewControllerColumn>): void;

  get viewControllers(): NSArray;
  set viewControllers(value: NSArray<interop.Object> | Array<interop.Object>);

  presentsWithGesture: boolean;

  readonly isCollapsed: boolean;

  preferredDisplayMode: interop.Enum<typeof UISplitViewControllerDisplayMode>;

  readonly displayMode: interop.Enum<typeof UISplitViewControllerDisplayMode>;

  readonly displayModeButtonItem: UIBarButtonItem;

  displayModeButtonVisibility: interop.Enum<typeof UISplitViewControllerDisplayModeButtonVisibility>;

  preferredPrimaryColumnWidthFraction: number;

  preferredPrimaryColumnWidth: number;

  minimumPrimaryColumnWidth: number;

  maximumPrimaryColumnWidth: number;

  readonly primaryColumnWidth: number;

  preferredSupplementaryColumnWidthFraction: number;

  preferredSupplementaryColumnWidth: number;

  minimumSupplementaryColumnWidth: number;

  maximumSupplementaryColumnWidth: number;

  readonly supplementaryColumnWidth: number;

  primaryEdge: interop.Enum<typeof UISplitViewControllerPrimaryEdge>;

  showViewControllerSender(vc: UIViewController, sender: interop.Object | null): void;

  showDetailViewControllerSender(vc: UIViewController, sender: interop.Object | null): void;

  primaryBackgroundStyle: interop.Enum<typeof UISplitViewControllerBackgroundStyle>;
}

declare class UIHoverGestureRecognizer extends UIGestureRecognizer {
  readonly zOffset: number;

  azimuthAngleInView(view: UIView | null): number;

  azimuthUnitVectorInView(view: UIView | null): CGVector;

  readonly altitudeAngle: number;

  readonly rollAngle: number;
}

declare class UIMotionEffect extends NSObject implements NSCopying, NSCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  keyPathsAndRelativeValuesForViewerOffset(viewerOffset: UIOffset): NSDictionary;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UISceneOpenExternalURLOptions extends NSObject {
  universalLinksOnly: boolean;

  eventAttribution: UIEventAttribution;
}

declare class UILexicon extends NSObject implements NSCopying {
  readonly entries: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITabBarItem extends UIBarItem {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  initWithTitleImageTag(title: string | null, image: UIImage | null, tag: number): this;

  initWithTitleImageSelectedImage(title: string | null, image: UIImage | null, selectedImage: UIImage | null): this;

  initWithTabBarSystemItemTag(systemItem: interop.Enum<typeof UITabBarSystemItem>, tag: number): this;

  selectedImage: UIImage;

  badgeValue: string;

  setFinishedSelectedImageWithFinishedUnselectedImage(selectedImage: UIImage | null, unselectedImage: UIImage | null): void;

  finishedSelectedImage(): UIImage;

  finishedUnselectedImage(): UIImage;

  titlePositionAdjustment: UIOffset;

  badgeColor: UIColor;

  setBadgeTextAttributesForState(textAttributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, state: interop.Enum<typeof UIControlState>): void;

  badgeTextAttributesForState(state: interop.Enum<typeof UIControlState>): NSDictionary;

  standardAppearance: UITabBarAppearance;

  scrollEdgeAppearance: UITabBarAppearance;
}

declare class UITextSearchOptions extends NSObject {
  readonly wordMatchMethod: interop.Enum<typeof UITextSearchMatchMethod>;

  readonly stringCompareOptions: interop.Enum<typeof NSStringCompareOptions>;
}

declare class UIKey extends NSObject implements NSCopying, NSCoding {
  readonly characters: string;

  readonly charactersIgnoringModifiers: string;

  readonly modifierFlags: interop.Enum<typeof UIKeyModifierFlags>;

  readonly keyCode: interop.Enum<typeof UIKeyboardHIDUsage>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UIBarButtonItemAppearance extends NSObject implements NSCopying, NSSecureCoding {
  init(): this;

  initWithStyle(style: interop.Enum<typeof UIBarButtonItemStyle>): this;

  initWithCoder(coder: NSCoder): this;

  // @ts-ignore MemberDecl.tsIgnore
  copy(): this;

  configureWithDefaultForStyle(style: interop.Enum<typeof UIBarButtonItemStyle>): void;

  readonly normal: UIBarButtonItemStateAppearance;

  readonly highlighted: UIBarButtonItemStateAppearance;

  readonly disabled: UIBarButtonItemStateAppearance;

  readonly focused: UIBarButtonItemStateAppearance;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIUserNotificationCategory extends NSObject implements NSCopying, NSMutableCopying, NSSecureCoding {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  readonly identifier: string;

  actionsForContext(context: interop.Enum<typeof UIUserNotificationActionContext>): NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  mutableCopyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIImageReaderConfiguration extends NSObject implements NSCopying {
  prefersHighDynamicRange: boolean;

  preparesImagesForDisplay: boolean;

  preferredThumbnailSize: CGSize;

  pixelsPerInch: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIDevice extends NSObject {
  static readonly currentDevice: UIDevice;

  readonly name: string;

  readonly model: string;

  readonly localizedModel: string;

  readonly systemName: string;

  readonly systemVersion: string;

  readonly orientation: interop.Enum<typeof UIDeviceOrientation>;

  readonly identifierForVendor: NSUUID;

  readonly isGeneratingDeviceOrientationNotifications: boolean;

  beginGeneratingDeviceOrientationNotifications(): void;

  endGeneratingDeviceOrientationNotifications(): void;

  isBatteryMonitoringEnabled: boolean;

  readonly batteryState: interop.Enum<typeof UIDeviceBatteryState>;

  readonly batteryLevel: number;

  isProximityMonitoringEnabled: boolean;

  readonly proximityState: boolean;

  readonly isMultitaskingSupported: boolean;

  readonly userInterfaceIdiom: interop.Enum<typeof UIUserInterfaceIdiom>;

  playInputClick(): void;
}

declare class UIHoverLiftEffect extends NSObject implements UIHoverEffect {
  static effect<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIPencilInteraction extends NSObject implements UIInteraction {
  static readonly preferredTapAction: interop.Enum<typeof UIPencilPreferredAction>;

  static readonly preferredSqueezeAction: interop.Enum<typeof UIPencilPreferredAction>;

  static readonly prefersPencilOnlyDrawing: boolean;

  static readonly prefersHoverToolPreview: boolean;

  initWithDelegate(delegate: UIPencilInteractionDelegate): this;

  delegate: UIPencilInteractionDelegate;

  isEnabled: boolean;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSTextRange extends NSObject {
  initWithLocationEndLocation(location: NSTextLocation, endLocation: NSTextLocation | null): this;

  initWithLocation(location: NSTextLocation): this;

  readonly isEmpty: boolean;

  readonly location: NSTextLocation;

  readonly endLocation: NSTextLocation;

  isEqualToTextRange(textRange: NSTextRange): boolean;

  containsLocation(location: NSTextLocation): boolean;

  containsRange(textRange: NSTextRange): boolean;

  intersectsWithTextRange(textRange: NSTextRange): boolean;

  textRangeByIntersectingWithTextRange(textRange: NSTextRange): this;

  textRangeByFormingUnionWithTextRange(textRange: NSTextRange): this;
}

declare class UIPinchGestureRecognizer extends UIGestureRecognizer {
  scale: number;

  readonly velocity: number;
}

declare class UIImageConfiguration extends NSObject implements NSCopying, NSSecureCoding {
  readonly traitCollection: UITraitCollection;

  configurationWithTraitCollection(traitCollection: UITraitCollection | null): this;

  static configurationWithTraitCollection<This extends abstract new (...args: any) => any>(this: This, traitCollection: UITraitCollection | null): InstanceType<This>;

  readonly locale: NSLocale;

  configurationWithLocale(locale: NSLocale | null): this;

  static configurationWithLocale<This extends abstract new (...args: any) => any>(this: This, locale: NSLocale | null): InstanceType<This>;

  configurationByApplyingConfiguration(otherConfiguration: UIImageConfiguration | null): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UITabBarItemAppearance extends NSObject implements NSCopying, NSSecureCoding {
  init(): this;

  initWithStyle(style: interop.Enum<typeof UITabBarItemAppearanceStyle>): this;

  initWithCoder(coder: NSCoder): this;

  // @ts-ignore MemberDecl.tsIgnore
  copy(): this;

  configureWithDefaultForStyle(style: interop.Enum<typeof UITabBarItemAppearanceStyle>): void;

  readonly normal: UITabBarItemStateAppearance;

  readonly selected: UITabBarItemStateAppearance;

  readonly disabled: UITabBarItemStateAppearance;

  readonly focused: UITabBarItemStateAppearance;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UICollectionViewTransitionLayout extends UICollectionViewLayout {
  transitionProgress: number;

  readonly currentLayout: UICollectionViewLayout;

  readonly nextLayout: UICollectionViewLayout;

  initWithCurrentLayoutNextLayout(currentLayout: UICollectionViewLayout, newLayout: UICollectionViewLayout): this;

  initWithCoder(coder: NSCoder): this;

  updateValueForAnimatedKey(value: number, key: string): void;

  valueForAnimatedKey(key: string): number;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSMutableParagraphStyle extends NSParagraphStyle {
  // @ts-ignore MemberDecl.tsIgnore
  lineSpacing: number;

  // @ts-ignore MemberDecl.tsIgnore
  paragraphSpacing: number;

  // @ts-ignore MemberDecl.tsIgnore
  alignment: interop.Enum<typeof NSTextAlignment>;

  // @ts-ignore MemberDecl.tsIgnore
  firstLineHeadIndent: number;

  // @ts-ignore MemberDecl.tsIgnore
  headIndent: number;

  // @ts-ignore MemberDecl.tsIgnore
  tailIndent: number;

  // @ts-ignore MemberDecl.tsIgnore
  lineBreakMode: interop.Enum<typeof NSLineBreakMode>;

  // @ts-ignore MemberDecl.tsIgnore
  minimumLineHeight: number;

  // @ts-ignore MemberDecl.tsIgnore
  maximumLineHeight: number;

  // @ts-ignore MemberDecl.tsIgnore
  baseWritingDirection: interop.Enum<typeof NSWritingDirection>;

  // @ts-ignore MemberDecl.tsIgnore
  lineHeightMultiple: number;

  // @ts-ignore MemberDecl.tsIgnore
  paragraphSpacingBefore: number;

  // @ts-ignore MemberDecl.tsIgnore
  hyphenationFactor: number;

  // @ts-ignore MemberDecl.tsIgnore
  usesDefaultHyphenation: boolean;

  // @ts-ignore MemberDecl.tsIgnore
  get tabStops(): NSArray;
  // @ts-ignore MemberDecl.tsIgnore
  set tabStops(value: NSArray<interop.Object> | Array<interop.Object>);

  // @ts-ignore MemberDecl.tsIgnore
  defaultTabInterval: number;

  // @ts-ignore MemberDecl.tsIgnore
  allowsDefaultTighteningForTruncation: boolean;

  // @ts-ignore MemberDecl.tsIgnore
  lineBreakStrategy: interop.Enum<typeof NSLineBreakStrategy>;

  // @ts-ignore MemberDecl.tsIgnore
  get textLists(): NSArray;
  // @ts-ignore MemberDecl.tsIgnore
  set textLists(value: NSArray<interop.Object> | Array<interop.Object>);

  addTabStop(anObject: NSTextTab): void;

  removeTabStop(anObject: NSTextTab): void;

  setParagraphStyle(obj: NSParagraphStyle): void;
}

declare class UICellAccessoryOutlineDisclosure extends UICellAccessory {
  style: interop.Enum<typeof UICellAccessoryOutlineDisclosureStyle>;

  actionHandler: () => void;
}

declare class UIFocusAnimationCoordinator extends NSObject {
  addCoordinatedAnimationsCompletion(animations: () => void | null, completion: () => void | null): void;

  addCoordinatedFocusingAnimationsCompletion(animations: (p1: UIFocusAnimationContext) => void | null, completion: () => void | null): void;

  addCoordinatedUnfocusingAnimationsCompletion(animations: (p1: UIFocusAnimationContext) => void | null, completion: () => void | null): void;
}

declare class UITextDropProposal extends UIDropProposal implements NSCopying {
  dropAction: interop.Enum<typeof UITextDropAction>;

  dropProgressMode: interop.Enum<typeof UITextDropProgressMode>;

  useFastSameViewOperations: boolean;

  dropPerformer: interop.Enum<typeof UITextDropPerformer>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIContextMenuConfiguration extends NSObject {
  readonly identifier: NSCopying;

  secondaryItemIdentifiers: NSSet;

  badgeCount: number;

  preferredMenuElementOrder: interop.Enum<typeof UIContextMenuConfigurationElementOrder>;

  static configurationWithIdentifierPreviewProviderActionProvider<This extends abstract new (...args: any) => any>(this: This, identifier: NSCopying | null, previewProvider: () => UIViewController | null, actionProvider: (p1: NSArray<interop.Object> | Array<interop.Object>) => UIMenu | null): InstanceType<This>;
}

declare class UITraitHorizontalSizeClass extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UIPrinter extends NSObject {
  static printerWithURL(url: NSURL): UIPrinter;

  readonly URL: NSURL;

  readonly displayName: string;

  readonly displayLocation: string;

  readonly supportedJobTypes: interop.Enum<typeof UIPrinterJobTypes>;

  readonly makeAndModel: string;

  readonly supportsColor: boolean;

  readonly supportsDuplex: boolean;

  contactPrinter(completionHandler: (p1: boolean) => void | null): void;
}

declare class NSTextViewportLayoutController extends NSObject {
  initWithTextLayoutManager(textLayoutManager: NSTextLayoutManager): this;

  delegate: NSTextViewportLayoutControllerDelegate;

  readonly textLayoutManager: NSTextLayoutManager | null;

  readonly viewportBounds: CGRect;

  readonly viewportRange: NSTextRange;

  layoutViewport(): void;

  relocateViewportToTextLocation(textLocation: NSTextLocation): number;

  adjustViewportByVerticalOffset(verticalOffset: number): void;
}

declare class UIViewConfigurationState extends NSObject implements UIConfigurationState {
  initWithTraitCollection(traitCollection: UITraitCollection): this;

  initWithCoder(coder: NSCoder): this;

  traitCollection: UITraitCollection;

  isDisabled: boolean;

  isHighlighted: boolean;

  isSelected: boolean;

  isFocused: boolean;

  isPinned: boolean;

  customStateForKey(key: string): interop.Object;

  setCustomStateForKey(customState: interop.Object | null, key: string): void;

  objectForKeyedSubscript(key: string): interop.Object;

  setObjectForKeyedSubscript(obj: interop.Object | null, key: string): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIStoryboardPopoverSegue extends UIStoryboardSegue {
  readonly popoverController: UIPopoverController;
}

declare class UICollectionViewDropPlaceholder extends UICollectionViewPlaceholder {
  previewParametersProvider: (p1: UICollectionViewCell) => UIDragPreviewParameters | null;
}

declare class UITraitUserInterfaceStyle extends NSObject implements UINSIntegerTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class NSCollectionLayoutSection extends NSObject implements NSCopying {
  static sectionWithGroup<This extends abstract new (...args: any) => any>(this: This, group: NSCollectionLayoutGroup): InstanceType<This>;

  contentInsets: NSDirectionalEdgeInsets;

  interGroupSpacing: number;

  contentInsetsReference: interop.Enum<typeof UIContentInsetsReference>;

  supplementaryContentInsetsReference: interop.Enum<typeof UIContentInsetsReference>;

  orthogonalScrollingBehavior: interop.Enum<typeof UICollectionLayoutSectionOrthogonalScrollingBehavior>;

  readonly orthogonalScrollingProperties: UICollectionLayoutSectionOrthogonalScrollingProperties;

  get boundarySupplementaryItems(): NSArray;
  set boundarySupplementaryItems(value: NSArray<interop.Object> | Array<interop.Object>);

  visibleItemsInvalidationHandler: (p1: NSArray<interop.Object> | Array<interop.Object>, p2: CGPoint, p3: NSCollectionLayoutEnvironment) => void;

  get decorationItems(): NSArray;
  set decorationItems(value: NSArray<interop.Object> | Array<interop.Object>);

  supplementariesFollowContentInsets: boolean;

  static sectionWithListConfigurationLayoutEnvironment<This extends abstract new (...args: any) => any>(this: This, configuration: UICollectionLayoutListConfiguration, layoutEnvironment: NSCollectionLayoutEnvironment): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType = interop.Object> extends NSObject implements NSCopying {
  shouldExpandItemHandler: (p1: interop.Object) => boolean;

  willExpandItemHandler: (p1: interop.Object) => void;

  shouldCollapseItemHandler: (p1: interop.Object) => boolean;

  willCollapseItemHandler: (p1: interop.Object) => void;

  snapshotForExpandingParentItemHandler: (p1: interop.Object, p2: NSDiffableDataSourceSectionSnapshot) => NSDiffableDataSourceSectionSnapshot;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIReferenceLibraryViewController extends UIViewController {
  static dictionaryHasDefinitionForTerm(term: string): boolean;

  initWithTerm(term: string): this;

  initWithCoder(coder: NSCoder): this;
}

declare class UIDatePicker extends UIControl implements NSCoding {
  datePickerMode: interop.Enum<typeof UIDatePickerMode>;

  locale: NSLocale;

  calendar: NSCalendar;

  timeZone: NSTimeZone;

  date: NSDate;

  minimumDate: NSDate;

  maximumDate: NSDate;

  countDownDuration: number;

  minuteInterval: number;

  setDateAnimated(date: NSDate, animated: boolean): void;

  preferredDatePickerStyle: interop.Enum<typeof UIDatePickerStyle>;

  readonly datePickerStyle: interop.Enum<typeof UIDatePickerStyle>;

  roundsToMinuteInterval: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIFontMetrics extends NSObject {
  static readonly defaultMetrics: UIFontMetrics;

  static metricsForTextStyle<This extends abstract new (...args: any) => any>(this: This, textStyle: string): InstanceType<This>;

  initForTextStyle(textStyle: string): this;

  scaledFontForFont(font: UIFont): UIFont;

  scaledFontForFontMaximumPointSize(font: UIFont, maximumPointSize: number): UIFont;

  scaledFontForFontCompatibleWithTraitCollection(font: UIFont, traitCollection: UITraitCollection | null): UIFont;

  scaledFontForFontMaximumPointSizeCompatibleWithTraitCollection(font: UIFont, maximumPointSize: number, traitCollection: UITraitCollection | null): UIFont;

  scaledValueForValue(value: number): number;

  scaledValueForValueCompatibleWithTraitCollection(value: number, traitCollection: UITraitCollection | null): number;
}

declare class NSLayoutXAxisAnchor extends NSLayoutAnchor {
  anchorWithOffsetToAnchor(otherAnchor: NSLayoutXAxisAnchor): NSLayoutDimension;

  constraintEqualToSystemSpacingAfterAnchorMultiplier(anchor: NSLayoutXAxisAnchor, multiplier: number): NSLayoutConstraint;

  constraintGreaterThanOrEqualToSystemSpacingAfterAnchorMultiplier(anchor: NSLayoutXAxisAnchor, multiplier: number): NSLayoutConstraint;

  constraintLessThanOrEqualToSystemSpacingAfterAnchorMultiplier(anchor: NSLayoutXAxisAnchor, multiplier: number): NSLayoutConstraint;
}

declare class UIScrollView extends UIView implements NSCoding, UIFocusItemScrollableContainer {
  contentOffset: CGPoint;

  contentSize: CGSize;

  contentInset: UIEdgeInsets;

  contentAlignmentPoint: CGPoint;

  readonly adjustedContentInset: UIEdgeInsets;

  adjustedContentInsetDidChange(): void;

  contentInsetAdjustmentBehavior: interop.Enum<typeof UIScrollViewContentInsetAdjustmentBehavior>;

  automaticallyAdjustsScrollIndicatorInsets: boolean;

  readonly contentLayoutGuide: UILayoutGuide;

  readonly frameLayoutGuide: UILayoutGuide;

  delegate: UIScrollViewDelegate;

  isDirectionalLockEnabled: boolean;

  bounces: boolean;

  bouncesHorizontally: boolean;

  bouncesVertically: boolean;

  alwaysBounceVertical: boolean;

  alwaysBounceHorizontal: boolean;

  isPagingEnabled: boolean;

  isScrollEnabled: boolean;

  transfersHorizontalScrollingToParent: boolean;

  transfersVerticalScrollingToParent: boolean;

  showsVerticalScrollIndicator: boolean;

  showsHorizontalScrollIndicator: boolean;

  indicatorStyle: interop.Enum<typeof UIScrollViewIndicatorStyle>;

  verticalScrollIndicatorInsets: UIEdgeInsets;

  horizontalScrollIndicatorInsets: UIEdgeInsets;

  scrollIndicatorInsets: UIEdgeInsets;

  decelerationRate: number;

  indexDisplayMode: interop.Enum<typeof UIScrollViewIndexDisplayMode>;

  setContentOffsetAnimated(contentOffset: CGPoint, animated: boolean): void;

  scrollRectToVisibleAnimated(rect: CGRect, animated: boolean): void;

  flashScrollIndicators(): void;

  withScrollIndicatorsShownForContentOffsetChanges(changes: () => void): void;

  readonly isTracking: boolean;

  readonly isDragging: boolean;

  readonly isDecelerating: boolean;

  readonly isScrollAnimating: boolean;

  delaysContentTouches: boolean;

  canCancelContentTouches: boolean;

  touchesShouldBeginWithEventInContentView(touches: NSSet, event: UIEvent | null, view: UIView): boolean;

  touchesShouldCancelInContentView(view: UIView): boolean;

  minimumZoomScale: number;

  maximumZoomScale: number;

  zoomScale: number;

  setZoomScaleAnimated(scale: number, animated: boolean): void;

  zoomToRectAnimated(rect: CGRect, animated: boolean): void;

  bouncesZoom: boolean;

  readonly isZooming: boolean;

  readonly isZoomBouncing: boolean;

  readonly isZoomAnimating: boolean;

  scrollsToTop: boolean;

  stopScrollingAndZooming(): void;

  readonly panGestureRecognizer: UIPanGestureRecognizer;

  readonly pinchGestureRecognizer: UIPinchGestureRecognizer;

  readonly directionalPressGestureRecognizer: UIGestureRecognizer;

  keyboardDismissMode: interop.Enum<typeof UIScrollViewKeyboardDismissMode>;

  refreshControl: UIRefreshControl;

  allowsKeyboardScrolling: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  readonly visibleSize: CGSize;

  readonly coordinateSpace: UICoordinateSpace;

  focusItemsInRect(rect: CGRect): NSArray;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UITraitTypesettingLanguage extends NSObject implements UIObjectTraitDefinition {
  static readonly defaultValue: NSObject;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

// @ts-ignore ClassDecl.tsIgnore
declare class UICommand extends UIMenuElement implements UIMenuLeaf {
  // @ts-ignore MemberDecl.tsIgnore
  title: string;

  // @ts-ignore MemberDecl.tsIgnore
  image: UIImage;

  discoverabilityTitle: string;

  readonly action: string;

  readonly propertyList: interop.Object;

  attributes: interop.Enum<typeof UIMenuElementAttributes>;

  state: interop.Enum<typeof UIMenuElementState>;

  readonly alternates: NSArray;

  static commandWithTitleImageActionPropertyList<This extends abstract new (...args: any) => any>(this: This, title: string, image: UIImage | null, action: string, propertyList: interop.Object | null): InstanceType<This>;

  static commandWithTitleImageActionPropertyListAlternates<This extends abstract new (...args: any) => any>(this: This, title: string, image: UIImage | null, action: string, propertyList: interop.Object | null, alternates: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  initWithCoder(coder: NSCoder): this;

  selectedImage: UIImage;

  readonly sender: interop.Object;

  readonly presentationSourceItem: UIPopoverPresentationControllerSourceItem;

  performWithSenderTarget(sender: interop.Object | null, target: interop.Object | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UILocalizedIndexedCollation extends NSObject {
  static currentCollation<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  readonly sectionTitles: NSArray;

  readonly sectionIndexTitles: NSArray;

  sectionForSectionIndexTitleAtIndex(indexTitleIndex: number): number;

  sectionForObjectCollationStringSelector(object: interop.Object, selector: string): number;

  sortedArrayFromArrayCollationStringSelector(array: NSArray<interop.Object> | Array<interop.Object>, selector: string): NSArray;
}

declare class UIFocusEffect extends NSObject implements NSCopying {
  static effect<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UITextPosition extends NSObject {
}

declare class UIFont extends NSObject implements NSCopying, NSSecureCoding {
  static preferredFontForTextStyle(style: string): UIFont;

  static preferredFontForTextStyleCompatibleWithTraitCollection(style: string, traitCollection: UITraitCollection | null): UIFont;

  static fontWithNameSize(fontName: string, fontSize: number): UIFont;

  static readonly familyNames: NSArray;

  static fontNamesForFamilyName(familyName: string): NSArray;

  static systemFontOfSize(fontSize: number): UIFont;

  static boldSystemFontOfSize(fontSize: number): UIFont;

  static italicSystemFontOfSize(fontSize: number): UIFont;

  static systemFontOfSizeWeight(fontSize: number, weight: number): UIFont;

  static monospacedDigitSystemFontOfSizeWeight(fontSize: number, weight: number): UIFont;

  static systemFontOfSizeWeightWidth(fontSize: number, weight: number, width: number): UIFont;

  static monospacedSystemFontOfSizeWeight(fontSize: number, weight: number): UIFont;

  readonly familyName: string;

  readonly fontName: string;

  readonly pointSize: number;

  readonly ascender: number;

  readonly descender: number;

  readonly capHeight: number;

  readonly xHeight: number;

  readonly lineHeight: number;

  readonly leading: number;

  fontWithSize(fontSize: number): UIFont;

  static fontWithDescriptorSize(descriptor: UIFontDescriptor, pointSize: number): UIFont;

  readonly fontDescriptor: UIFontDescriptor;

  static readonly labelFontSize: number;

  static readonly buttonFontSize: number;

  static readonly smallSystemFontSize: number;

  static readonly systemFontSize: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class UIContentUnavailableView extends UIView implements UIContentView {
  initWithConfiguration(configuration: UIContentUnavailableConfiguration): this;

  initWithCoder(coder: NSCoder): this;

  configuration: UIContentUnavailableConfiguration;

  isScrollEnabled: boolean;

  supportsConfiguration(configuration: UIContentConfiguration): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIViewController extends UIResponder implements NSCoding, UIAppearanceContainer, UITraitEnvironment, UIContentContainer, UIFocusEnvironment {
  initWithNibNameBundle(nibNameOrNil: string | null, nibBundleOrNil: NSBundle | null): this;

  initWithCoder(coder: NSCoder): this;

  view: UIView;

  loadView(): void;

  loadViewIfNeeded(): void;

  readonly viewIfLoaded: UIView;

  viewWillUnload(): void;

  viewDidUnload(): void;

  viewDidLoad(): void;

  readonly isViewLoaded: boolean;

  readonly nibName: string;

  readonly nibBundle: NSBundle;

  readonly storyboard: UIStoryboard;

  performSegueWithIdentifierSender(identifier: string, sender: interop.Object | null): void;

  shouldPerformSegueWithIdentifierSender(identifier: string, sender: interop.Object | null): boolean;

  prepareForSegueSender(segue: UIStoryboardSegue, sender: interop.Object | null): void;

  canPerformUnwindSegueActionFromViewControllerSender(action: string, fromViewController: UIViewController, sender: interop.Object | null): boolean;

  canPerformUnwindSegueActionFromViewControllerWithSender(action: string, fromViewController: UIViewController, sender: interop.Object): boolean;

  allowedChildViewControllersForUnwindingFromSource(source: UIStoryboardUnwindSegueSource): NSArray;

  childViewControllerContainingSegueSource(source: UIStoryboardUnwindSegueSource): UIViewController;

  viewControllerForUnwindSegueActionFromViewControllerWithSender(action: string, fromViewController: UIViewController, sender: interop.Object | null): UIViewController;

  unwindForSegueTowardsViewController(unwindSegue: UIStoryboardSegue, subsequentVC: UIViewController): void;

  segueForUnwindingToViewControllerFromViewControllerIdentifier(toViewController: UIViewController, fromViewController: UIViewController, identifier: string | null): UIStoryboardSegue;

  viewWillAppear(animated: boolean): void;

  viewIsAppearing(animated: boolean): void;

  viewDidAppear(animated: boolean): void;

  viewWillDisappear(animated: boolean): void;

  viewDidDisappear(animated: boolean): void;

  viewWillLayoutSubviews(): void;

  viewDidLayoutSubviews(): void;

  title: string;

  didReceiveMemoryWarning(): void;

  readonly parentViewController: UIViewController;

  readonly modalViewController: UIViewController;

  readonly presentedViewController: UIViewController;

  readonly presentingViewController: UIViewController;

  definesPresentationContext: boolean;

  providesPresentationContextTransitionStyle: boolean;

  restoresFocusAfterTransition: boolean;

  focusGroupIdentifier: string;

  interactionActivityTrackingBaseName: string;

  readonly isBeingPresented: boolean;

  readonly isBeingDismissed: boolean;

  readonly isMovingToParentViewController: boolean;

  readonly isMovingFromParentViewController: boolean;

  presentViewControllerAnimatedCompletion(viewControllerToPresent: UIViewController, flag: boolean, completion: () => void | null): void;

  dismissViewControllerAnimatedCompletion(flag: boolean, completion: () => void | null): void;

  presentModalViewControllerAnimated(modalViewController: UIViewController, animated: boolean): void;

  dismissModalViewControllerAnimated(animated: boolean): void;

  modalTransitionStyle: interop.Enum<typeof UIModalTransitionStyle>;

  modalPresentationStyle: interop.Enum<typeof UIModalPresentationStyle>;

  modalPresentationCapturesStatusBarAppearance: boolean;

  readonly disablesAutomaticKeyboardDismissal: boolean;

  wantsFullScreenLayout: boolean;

  edgesForExtendedLayout: interop.Enum<typeof UIRectEdge>;

  extendedLayoutIncludesOpaqueBars: boolean;

  automaticallyAdjustsScrollViewInsets: boolean;

  setContentScrollViewForEdge(scrollView: UIScrollView | null, edge: interop.Enum<typeof NSDirectionalRectEdge>): void;

  contentScrollViewForEdge(edge: interop.Enum<typeof NSDirectionalRectEdge>): UIScrollView;

  preferredContentSize: CGSize;

  readonly preferredStatusBarStyle: interop.Enum<typeof UIStatusBarStyle>;

  readonly prefersStatusBarHidden: boolean;

  readonly preferredStatusBarUpdateAnimation: interop.Enum<typeof UIStatusBarAnimation>;

  setNeedsStatusBarAppearanceUpdate(): void;

  targetViewControllerForActionSender(action: string, sender: interop.Object | null): UIViewController;

  showViewControllerSender(vc: UIViewController, sender: interop.Object | null): void;

  showDetailViewControllerSender(vc: UIViewController, sender: interop.Object | null): void;

  overrideUserInterfaceStyle: interop.Enum<typeof UIUserInterfaceStyle>;

  static attemptRotationToDeviceOrientation(): void;

  shouldAutorotateToInterfaceOrientation(toInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>): boolean;

  readonly shouldAutorotate: boolean;

  readonly supportedInterfaceOrientations: interop.Enum<typeof UIInterfaceOrientationMask>;

  readonly preferredInterfaceOrientationForPresentation: interop.Enum<typeof UIInterfaceOrientation>;

  setNeedsUpdateOfSupportedInterfaceOrientations(): void;

  rotatingHeaderView(): UIView;

  rotatingFooterView(): UIView;

  readonly interfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>;

  willRotateToInterfaceOrientationDuration(toInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>, duration: number): void;

  didRotateFromInterfaceOrientation(fromInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>): void;

  willAnimateRotationToInterfaceOrientationDuration(toInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>, duration: number): void;

  willAnimateFirstHalfOfRotationToInterfaceOrientationDuration(toInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>, duration: number): void;

  didAnimateFirstHalfOfRotationToInterfaceOrientation(toInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>): void;

  willAnimateSecondHalfOfRotationFromInterfaceOrientationDuration(fromInterfaceOrientation: interop.Enum<typeof UIInterfaceOrientation>, duration: number): void;

  isEditing: boolean;

  setEditingAnimated(editing: boolean, animated: boolean): void;

  readonly editButtonItem: UIBarButtonItem;

  readonly searchDisplayController: UISearchDisplayController;

  readonly childViewControllers: NSArray;

  addChildViewController(childController: UIViewController): void;

  removeFromParentViewController(): void;

  transitionFromViewControllerToViewControllerDurationOptionsAnimationsCompletion(fromViewController: UIViewController, toViewController: UIViewController, duration: number, options: interop.Enum<typeof UIViewAnimationOptions>, animations: () => void | null, completion: (p1: boolean) => void | null): void;

  beginAppearanceTransitionAnimated(isAppearing: boolean, animated: boolean): void;

  endAppearanceTransition(): void;

  readonly childViewControllerForStatusBarStyle: UIViewController;

  readonly childViewControllerForStatusBarHidden: UIViewController;

  setOverrideTraitCollectionForChildViewController(collection: UITraitCollection | null, childViewController: UIViewController): void;

  overrideTraitCollectionForChildViewController(childViewController: UIViewController): UITraitCollection;

  automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers(): boolean;

  shouldAutomaticallyForwardRotationMethods(): boolean;

  readonly shouldAutomaticallyForwardAppearanceMethods: boolean;

  willMoveToParentViewController(parent: UIViewController | null): void;

  didMoveToParentViewController(parent: UIViewController | null): void;

  restorationIdentifier: string;

  restorationClass: UIViewControllerRestoration;

  encodeRestorableStateWithCoder(coder: NSCoder): void;

  decodeRestorableStateWithCoder(coder: NSCoder): void;

  applicationFinishedRestoringState(): void;

  updateViewConstraints(): void;

  transitioningDelegate: UIViewControllerTransitioningDelegate;

  readonly topLayoutGuide: UILayoutSupport;

  readonly bottomLayoutGuide: UILayoutSupport;

  additionalSafeAreaInsets: UIEdgeInsets;

  readonly systemMinimumLayoutMargins: NSDirectionalEdgeInsets;

  viewRespectsSystemMinimumLayoutMargins: boolean;

  viewLayoutMarginsDidChange(): void;

  viewSafeAreaInsetsDidChange(): void;

  addKeyCommand(keyCommand: UIKeyCommand): void;

  removeKeyCommand(keyCommand: UIKeyCommand): void;

  readonly performsActionsWhilePresentingModally: boolean;

  readonly extensionContext: NSExtensionContext;

  readonly presentationController: UIPresentationController;

  readonly sheetPresentationController: UISheetPresentationController;

  readonly popoverPresentationController: UIPopoverPresentationController;

  readonly activePresentationController: UIPresentationController;

  isModalInPresentation: boolean;

  registerForPreviewingWithDelegateSourceView(delegate: UIViewControllerPreviewingDelegate, sourceView: UIView): UIViewControllerPreviewing;

  unregisterForPreviewingWithContext(previewing: UIViewControllerPreviewing): void;

  readonly childViewControllerForScreenEdgesDeferringSystemGestures: UIViewController;

  readonly preferredScreenEdgesDeferringSystemGestures: interop.Enum<typeof UIRectEdge>;

  setNeedsUpdateOfScreenEdgesDeferringSystemGestures(): void;

  readonly childViewControllerForHomeIndicatorAutoHidden: UIViewController;

  readonly prefersHomeIndicatorAutoHidden: boolean;

  setNeedsUpdateOfHomeIndicatorAutoHidden(): void;

  readonly childViewControllerForPointerLock: UIViewController;

  readonly prefersPointerLocked: boolean;

  setNeedsUpdateOfPrefersPointerLocked(): void;

  contentUnavailableConfiguration: UIContentConfiguration;

  readonly contentUnavailableConfigurationState: UIContentUnavailableConfigurationState;

  setNeedsUpdateContentUnavailableConfiguration(): void;

  updateContentUnavailableConfigurationUsingState(state: UIContentUnavailableConfigurationState): void;

  readonly previewActionItems: NSArray;

  readonly traitOverrides: UITraitOverrides;

  updateTraitsIfNeeded(): void;

  readonly navigationItem: UINavigationItem;

  hidesBottomBarWhenPushed: boolean;

  readonly navigationController: UINavigationController;

  get toolbarItems(): NSArray;
  set toolbarItems(value: NSArray<interop.Object> | Array<interop.Object>);

  setToolbarItemsAnimated(toolbarItems: NSArray<interop.Object> | Array<interop.Object> | null, animated: boolean): void;

  isModalInPopover: boolean;

  contentSizeForViewInPopover: CGSize;

  readonly transitionCoordinator: UIViewControllerTransitionCoordinator;

  readonly splitViewController: UISplitViewController;

  collapseSecondaryViewControllerForSplitViewController(secondaryViewController: UIViewController, splitViewController: UISplitViewController): void;

  separateSecondaryViewControllerForSplitViewController(splitViewController: UISplitViewController): UIViewController;

  tabBarItem: UITabBarItem;

  readonly tabBarController: UITabBarController;

  encodeWithCoder(coder: NSCoder): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  readonly traitCollection: UITraitCollection;

  traitCollectionDidChange(previousTraitCollection: UITraitCollection | null): void;

  preferredContentSizeDidChangeForChildContentContainer(container: UIContentContainer): void;

  systemLayoutFittingSizeDidChangeForChildContentContainer(container: UIContentContainer): void;

  sizeForChildContentContainerWithParentContainerSize(container: UIContentContainer, parentSize: CGSize): CGSize;

  viewWillTransitionToSizeWithTransitionCoordinator(size: CGSize, coordinator: UIViewControllerTransitionCoordinator): void;

  willTransitionToTraitCollectionWithTransitionCoordinator(newCollection: UITraitCollection, coordinator: UIViewControllerTransitionCoordinator): void;

  readonly preferredFocusEnvironments: NSArray;

  readonly parentFocusEnvironment: UIFocusEnvironment;

  readonly focusItemContainer: UIFocusItemContainer;

  setNeedsFocusUpdate(): void;

  updateFocusIfNeeded(): void;

  shouldUpdateFocusInContext(context: UIFocusUpdateContext): boolean;

  didUpdateFocusInContextWithAnimationCoordinator(context: UIFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  readonly preferredFocusedView: UIView;
}

declare class UIActivityIndicatorView extends UIView implements NSCoding {
  initWithActivityIndicatorStyle(style: interop.Enum<typeof UIActivityIndicatorViewStyle>): this;

  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  activityIndicatorViewStyle: interop.Enum<typeof UIActivityIndicatorViewStyle>;

  hidesWhenStopped: boolean;

  color: UIColor;

  startAnimating(): void;

  stopAnimating(): void;

  readonly isAnimating: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UIPresentationController extends NSObject implements UIAppearanceContainer, UITraitEnvironment, UIContentContainer, UIFocusEnvironment {
  readonly presentingViewController: UIViewController;

  readonly presentedViewController: UIViewController;

  readonly presentationStyle: interop.Enum<typeof UIModalPresentationStyle>;

  readonly containerView: UIView;

  delegate: UIAdaptivePresentationControllerDelegate;

  initWithPresentedViewControllerPresentingViewController(presentedViewController: UIViewController, presentingViewController: UIViewController | null): this;

  readonly adaptivePresentationStyle: interop.Enum<typeof UIModalPresentationStyle>;

  adaptivePresentationStyleForTraitCollection(traitCollection: UITraitCollection): interop.Enum<typeof UIModalPresentationStyle>;

  containerViewWillLayoutSubviews(): void;

  containerViewDidLayoutSubviews(): void;

  readonly presentedView: UIView;

  readonly frameOfPresentedViewInContainerView: CGRect;

  readonly shouldPresentInFullscreen: boolean;

  readonly shouldRemovePresentersView: boolean;

  presentationTransitionWillBegin(): void;

  presentationTransitionDidEnd(completed: boolean): void;

  dismissalTransitionWillBegin(): void;

  dismissalTransitionDidEnd(completed: boolean): void;

  overrideTraitCollection: UITraitCollection;

  readonly traitOverrides: UITraitOverrides;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  readonly traitCollection: UITraitCollection;

  traitCollectionDidChange(previousTraitCollection: UITraitCollection | null): void;

  readonly preferredContentSize: CGSize;

  preferredContentSizeDidChangeForChildContentContainer(container: UIContentContainer): void;

  systemLayoutFittingSizeDidChangeForChildContentContainer(container: UIContentContainer): void;

  sizeForChildContentContainerWithParentContainerSize(container: UIContentContainer, parentSize: CGSize): CGSize;

  viewWillTransitionToSizeWithTransitionCoordinator(size: CGSize, coordinator: UIViewControllerTransitionCoordinator): void;

  willTransitionToTraitCollectionWithTransitionCoordinator(newCollection: UITraitCollection, coordinator: UIViewControllerTransitionCoordinator): void;

  readonly preferredFocusEnvironments: NSArray;

  readonly parentFocusEnvironment: UIFocusEnvironment;

  readonly focusItemContainer: UIFocusItemContainer;

  setNeedsFocusUpdate(): void;

  updateFocusIfNeeded(): void;

  shouldUpdateFocusInContext(context: UIFocusUpdateContext): boolean;

  didUpdateFocusInContextWithAnimationCoordinator(context: UIFocusUpdateContext, coordinator: UIFocusAnimationCoordinator): void;

  readonly preferredFocusedView: UIView;

  readonly focusGroupIdentifier: string;
}

declare class UIFeedbackGenerator extends NSObject {
  static feedbackGeneratorForView<This extends abstract new (...args: any) => any>(this: This, view: UIView): InstanceType<This>;

  init(): this;

  prepare(): void;
}

declare class NSTextLayoutManager extends NSObject implements NSSecureCoding, NSTextSelectionDataSource {
  init(): this;

  initWithCoder(coder: NSCoder): this;

  delegate: NSTextLayoutManagerDelegate;

  usesFontLeading: boolean;

  limitsLayoutForSuspiciousContents: boolean;

  usesHyphenation: boolean;

  readonly textContentManager: NSTextContentManager;

  replaceTextContentManager(textContentManager: NSTextContentManager): void;

  textContainer: NSTextContainer;

  readonly usageBoundsForTextContainer: CGRect;

  readonly textViewportLayoutController: NSTextViewportLayoutController;

  layoutQueue: NSOperationQueue;

  ensureLayoutForRange(range: NSTextRange): void;

  ensureLayoutForBounds(bounds: CGRect): void;

  invalidateLayoutForRange(range: NSTextRange): void;

  textLayoutFragmentForPosition(position: CGPoint): NSTextLayoutFragment;

  textLayoutFragmentForLocation(location: NSTextLocation): NSTextLayoutFragment;

  enumerateTextLayoutFragmentsFromLocationOptionsUsingBlock(location: NSTextLocation | null, options: interop.Enum<typeof NSTextLayoutFragmentEnumerationOptions>, block: (p1: NSTextLayoutFragment) => boolean): NSTextLocation;

  get textSelections(): NSArray;
  set textSelections(value: NSArray<interop.Object> | Array<interop.Object>);

  textSelectionNavigation: NSTextSelectionNavigation;

  enumerateRenderingAttributesFromLocationReverseUsingBlock(location: NSTextLocation, reverse: boolean, block: (p1: NSTextLayoutManager, p2: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, p3: NSTextRange) => boolean): void;

  setRenderingAttributesForTextRange(renderingAttributes: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, textRange: NSTextRange): void;

  addRenderingAttributeValueForTextRange(renderingAttribute: string, value: interop.Object | null, textRange: NSTextRange): void;

  removeRenderingAttributeForTextRange(renderingAttribute: string, textRange: NSTextRange): void;

  invalidateRenderingAttributesForTextRange(textRange: NSTextRange): void;

  renderingAttributesValidator: (p1: NSTextLayoutManager, p2: NSTextLayoutFragment) => void;

  static readonly linkRenderingAttributes: NSDictionary;

  renderingAttributesForLinkAtLocation(link: interop.Object, location: NSTextLocation): NSDictionary;

  enumerateTextSegmentsInRangeTypeOptionsUsingBlock(textRange: NSTextRange, type: interop.Enum<typeof NSTextLayoutManagerSegmentType>, options: interop.Enum<typeof NSTextLayoutManagerSegmentOptions>, block: (p1: NSTextRange, p2: CGRect, p3: number, p4: NSTextContainer) => boolean | null): void;

  replaceContentsInRangeWithTextElements(range: NSTextRange, textElements: NSArray<interop.Object> | Array<interop.Object>): void;

  replaceContentsInRangeWithAttributedString(range: NSTextRange, attributedString: NSAttributedString): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  readonly documentRange: NSTextRange;

  enumerateSubstringsFromLocationOptionsUsingBlock(location: NSTextLocation, options: interop.Enum<typeof NSStringEnumerationOptions>, block: (p1: string, p2: NSTextRange, p3: NSTextRange, p4: interop.PointerConvertible) => void | null): void;

  textRangeForSelectionGranularityEnclosingLocation(selectionGranularity: interop.Enum<typeof NSTextSelectionGranularity>, location: NSTextLocation): NSTextRange;

  locationFromLocationWithOffset(location: NSTextLocation, offset: number): NSTextLocation;

  offsetFromLocationToLocation(from: NSTextLocation, to: NSTextLocation): number;

  baseWritingDirectionAtLocation(location: NSTextLocation): interop.Enum<typeof NSTextSelectionNavigationWritingDirection>;

  enumerateCaretOffsetsInLineFragmentAtLocationUsingBlock(location: NSTextLocation, block: (p1: number, p2: NSTextLocation, p3: boolean, p4: interop.PointerConvertible) => void): void;

  lineFragmentRangeForPointInContainerAtLocation(point: CGPoint, location: NSTextLocation): NSTextRange;

  enumerateContainerBoundariesFromLocationReverseUsingBlock(location: NSTextLocation, reverse: boolean, block: (p1: NSTextLocation, p2: interop.PointerConvertible) => void): void;

  textLayoutOrientationAtLocation(location: NSTextLocation): interop.Enum<typeof NSTextSelectionNavigationLayoutOrientation>;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIHoverStyle extends NSObject implements NSCopying {
  effect: UIHoverEffect;

  shape: UIShape;

  isEnabled: boolean;

  static styleWithEffectShape<This extends abstract new (...args: any) => any>(this: This, effect: UIHoverEffect, shape: UIShape | null): InstanceType<This>;

  static styleWithShape<This extends abstract new (...args: any) => any>(this: This, shape: UIShape | null): InstanceType<This>;

  static automaticStyle<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class UIUserNotificationSettings extends NSObject {
  static settingsForTypesCategories<This extends abstract new (...args: any) => any>(this: This, types: interop.Enum<typeof UIUserNotificationType>, categories: NSSet | null): InstanceType<This>;

  readonly types: interop.Enum<typeof UIUserNotificationType>;

  readonly categories: NSSet;
}

declare class NSTextElement extends NSObject {
  initWithTextContentManager(textContentManager: NSTextContentManager | null): this;

  textContentManager: NSTextContentManager;

  elementRange: NSTextRange;

  readonly childElements: NSArray;

  readonly parentElement: NSTextElement;

  readonly isRepresentedElement: boolean;
}

declare class UIScreenMode extends NSObject {
  readonly size: CGSize;

  readonly pixelAspectRatio: number;
}

declare class UIWindowSceneActivationRequestOptions extends UISceneActivationRequestOptions {
  preferredPresentationStyle: interop.Enum<typeof UIWindowScenePresentationStyle>;

  placement: UIWindowScenePlacement;
}

declare class UISimpleTextPrintFormatter extends UIPrintFormatter {
  initWithText(text: string): this;

  initWithAttributedText(attributedText: NSAttributedString): this;

  text: string;

  attributedText: NSAttributedString;

  font: UIFont;

  color: UIColor;

  textAlignment: interop.Enum<typeof NSTextAlignment>;
}

declare class UIAccessibilityElement extends UIResponder implements UIAccessibilityIdentification {
  initWithAccessibilityContainer(container: interop.Object): this;

  accessibilityContainer: interop.Object;

  isAccessibilityElement: boolean;

  accessibilityLabel: string;

  accessibilityHint: string;

  accessibilityValue: string;

  accessibilityFrame: CGRect;

  accessibilityTraits: number;

  accessibilityFrameInContainerSpace: CGRect;

  accessibilityIdentifier: string;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class UIGraphicsRendererContext extends NSObject {
  readonly CGContext: interop.Pointer;

  readonly format: UIGraphicsRendererFormat;

  fillRect(rect: CGRect): void;

  fillRectBlendMode(rect: CGRect, blendMode: interop.Enum<typeof CGBlendMode>): void;

  strokeRect(rect: CGRect): void;

  strokeRectBlendMode(rect: CGRect, blendMode: interop.Enum<typeof CGBlendMode>): void;

  clipToRect(rect: CGRect): void;
}

declare class UIPress extends NSObject {
  readonly timestamp: number;

  readonly phase: interop.Enum<typeof UIPressPhase>;

  readonly type: interop.Enum<typeof UIPressType>;

  readonly window: UIWindow;

  readonly responder: UIResponder;

  readonly gestureRecognizers: NSArray;

  readonly force: number;

  readonly key: UIKey;
}

declare class UIStoryboard extends NSObject {
  static storyboardWithNameBundle(name: string, storyboardBundleOrNil: NSBundle | null): UIStoryboard;

  instantiateInitialViewController(): UIViewController;

  instantiateInitialViewControllerWithCreator(block: (p1: NSCoder) => UIViewController | null): UIViewController;

  instantiateViewControllerWithIdentifier(identifier: string): UIViewController;

  instantiateViewControllerWithIdentifierCreator(identifier: string, block: (p1: NSCoder) => UIViewController | null): UIViewController;
}

declare class UIDropInteraction extends NSObject implements UIInteraction {
  initWithDelegate(delegate: UIDropInteractionDelegate): this;

  readonly delegate: UIDropInteractionDelegate;

  allowsSimultaneousDropSessions: boolean;

  readonly view: UIView;

  willMoveToView(view: UIView | null): void;

  didMoveToView(view: UIView | null): void;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class NSTextSelection extends NSObject implements NSSecureCoding {
  initWithRangesAffinityGranularity(textRanges: NSArray<interop.Object> | Array<interop.Object>, affinity: interop.Enum<typeof NSTextSelectionAffinity>, granularity: interop.Enum<typeof NSTextSelectionGranularity>): this;

  initWithCoder(coder: NSCoder): this;

  initWithRangeAffinityGranularity(range: NSTextRange, affinity: interop.Enum<typeof NSTextSelectionAffinity>, granularity: interop.Enum<typeof NSTextSelectionGranularity>): this;

  initWithLocationAffinity(location: NSTextLocation, affinity: interop.Enum<typeof NSTextSelectionAffinity>): this;

  readonly textRanges: NSArray;

  readonly granularity: interop.Enum<typeof NSTextSelectionGranularity>;

  readonly affinity: interop.Enum<typeof NSTextSelectionAffinity>;

  readonly isTransient: boolean;

  anchorPositionOffset: number;

  isLogical: boolean;

  secondarySelectionLocation: NSTextLocation;

  get typingAttributes(): NSDictionary;
  set typingAttributes(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  textSelectionWithTextRanges(textRanges: NSArray<interop.Object> | Array<interop.Object>): NSTextSelection;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;
}

declare class UITraitDisplayScale extends NSObject implements UICGFloatTraitDefinition {
  static readonly defaultValue: number;

  static readonly identifier: string;

  static readonly name: string;

  static readonly affectsColorAppearance: boolean;
}

declare class UICellConfigurationState extends UIViewConfigurationState {
  isEditing: boolean;

  isExpanded: boolean;

  isSwiped: boolean;

  isReordering: boolean;

  cellDragState: interop.Enum<typeof UICellConfigurationDragState>;

  cellDropState: interop.Enum<typeof UICellConfigurationDropState>;
}

declare class UIControl extends UIView {
  initWithFrame(frame: CGRect): this;

  initWithCoder(coder: NSCoder): this;

  initWithFramePrimaryAction(frame: CGRect, primaryAction: UIAction | null): this;

  isEnabled: boolean;

  isSelected: boolean;

  isHighlighted: boolean;

  contentVerticalAlignment: interop.Enum<typeof UIControlContentVerticalAlignment>;

  contentHorizontalAlignment: interop.Enum<typeof UIControlContentHorizontalAlignment>;

  readonly effectiveContentHorizontalAlignment: interop.Enum<typeof UIControlContentHorizontalAlignment>;

  readonly state: interop.Enum<typeof UIControlState>;

  readonly isTracking: boolean;

  readonly isTouchInside: boolean;

  beginTrackingWithTouchWithEvent(touch: UITouch, event: UIEvent | null): boolean;

  continueTrackingWithTouchWithEvent(touch: UITouch, event: UIEvent | null): boolean;

  endTrackingWithTouchWithEvent(touch: UITouch | null, event: UIEvent | null): void;

  cancelTrackingWithEvent(event: UIEvent | null): void;

  addTargetActionForControlEvents(target: interop.Object | null, action: string, controlEvents: interop.Enum<typeof UIControlEvents>): void;

  removeTargetActionForControlEvents(target: interop.Object | null, action: string | null, controlEvents: interop.Enum<typeof UIControlEvents>): void;

  addActionForControlEvents(action: UIAction, controlEvents: interop.Enum<typeof UIControlEvents>): void;

  removeActionForControlEvents(action: UIAction, controlEvents: interop.Enum<typeof UIControlEvents>): void;

  removeActionForIdentifierForControlEvents(actionIdentifier: string, controlEvents: interop.Enum<typeof UIControlEvents>): void;

  performPrimaryAction(): void;

  readonly allTargets: NSSet;

  readonly allControlEvents: interop.Enum<typeof UIControlEvents>;

  actionsForTargetForControlEvent(target: interop.Object | null, controlEvent: interop.Enum<typeof UIControlEvents>): NSArray;

  enumerateEventHandlers(iterator: (p1: UIAction, p2: interop.Object, p3: string, p4: interop.Enum<typeof UIControlEvents>, p5: interop.PointerConvertible) => void | null): void;

  sendActionToForEvent(action: string, target: interop.Object | null, event: UIEvent | null): void;

  sendAction(action: UIAction): void;

  sendActionsForControlEvents(controlEvents: interop.Enum<typeof UIControlEvents>): void;

  readonly contextMenuInteraction: UIContextMenuInteraction;

  isContextMenuInteractionEnabled: boolean;

  showsMenuAsPrimaryAction: boolean;

  menuAttachmentPointForConfiguration(configuration: UIContextMenuConfiguration): CGPoint;

  toolTip: string;

  readonly toolTipInteraction: UIToolTipInteraction;

  isSymbolAnimationEnabled: boolean;

  contextMenuInteractionConfigurationForMenuAtLocation(interaction: UIContextMenuInteraction, location: CGPoint): UIContextMenuConfiguration;

  contextMenuInteractionPreviewForHighlightingMenuWithConfiguration(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration): UITargetedPreview;

  contextMenuInteractionPreviewForDismissingMenuWithConfiguration(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration): UITargetedPreview;

  contextMenuInteractionWillDisplayMenuForConfigurationAnimator(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;

  contextMenuInteractionWillEndForConfigurationAnimator(interaction: UIContextMenuInteraction, configuration: UIContextMenuConfiguration, animator: UIContextMenuInteractionAnimating | null): void;
}

declare class UIGravityBehavior extends UIDynamicBehavior {
  initWithItems(items: NSArray<interop.Object> | Array<interop.Object>): this;

  addItem(item: UIDynamicItem): void;

  removeItem(item: UIDynamicItem): void;

  readonly items: NSArray;

  gravityDirection: CGVector;

  angle: number;

  magnitude: number;

  setAngleMagnitude(angle: number, magnitude: number): void;
}

declare class UISceneActivationRequestOptions extends NSObject {
  requestingScene: UIScene;
}

declare class UIActionSheet extends UIView {
  initWithTitleDelegateCancelButtonTitleDestructiveButtonTitleOtherButtonTitles(title: string | null, delegate: UIActionSheetDelegate | null, cancelButtonTitle: string | null, destructiveButtonTitle: string | null, otherButtonTitles: string | null): this;

  delegate: UIActionSheetDelegate;

  title: string;

  actionSheetStyle: interop.Enum<typeof UIActionSheetStyle>;

  addButtonWithTitle(title: string | null): number;

  buttonTitleAtIndex(buttonIndex: number): string;

  readonly numberOfButtons: number;

  cancelButtonIndex: number;

  destructiveButtonIndex: number;

  readonly firstOtherButtonIndex: number;

  readonly isVisible: boolean;

  showFromToolbar(view: UIToolbar): void;

  showFromTabBar(view: UITabBar): void;

  showFromBarButtonItemAnimated(item: UIBarButtonItem, animated: boolean): void;

  showFromRectInViewAnimated(rect: CGRect, view: UIView, animated: boolean): void;

  showInView(view: UIView): void;

  dismissWithClickedButtonIndexAnimated(buttonIndex: number, animated: boolean): void;
}

