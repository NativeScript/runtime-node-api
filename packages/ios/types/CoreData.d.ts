/// <reference types="@nativescript/objc-node-api" />
/// <reference path="./Runtime.d.ts" />
/// <reference path="./Foundation.d.ts" />

declare const NSPersistentCloudKitContainerEventUserInfoKey: string;

declare const NSPersistentCloudKitContainerEventChangedNotification: string;

declare const NSMigrationEntityPolicyKey: string;

declare const NSMigrationPropertyMappingKey: string;

declare const NSMigrationEntityMappingKey: string;

declare const NSMigrationManagerKey: string;

declare const NSPersistentStoreRebuildFromUbiquitousContentOption: string;

declare const NSPersistentStoreUbiquitousContainerIdentifierKey: string;

declare const NSPersistentStoreRemoveUbiquitousMetadataOption: string;

declare const NSPersistentStoreUbiquitousPeerTokenOption: string;

declare const NSPersistentStoreUbiquitousContentURLKey: string;

declare const NSPersistentStoreUbiquitousContentNameKey: string;

declare const NSPersistentStoreModelVersionChecksumKey: string;

declare const NSPersistentStoreRemoteChangeNotificationPostOptionKey: string;

declare const NSBinaryStoreSecureDecodingClasses: string;

declare const NSPersistentStoreFileProtectionKey: string;

declare const NSPersistentStoreStagedMigrationManagerOptionKey: string;

declare const NSPersistentStoreOSCompatibility: string;

declare const NSStoreModelVersionHashesKey: string;

declare const NSMigratePersistentStoresAutomaticallyOption: string;

declare const NSIgnorePersistentStoreVersioningOption: string;

declare const NSSQLiteAnalyzeOption: string;

declare const NSPersistentStoreTimeoutOption: string;

declare const NSUUIDChangedPersistentStoresKey: string;

declare const NSRemovedPersistentStoresKey: string;

declare const NSAddedPersistentStoresKey: string;

declare const NSPersistentStoreCoordinatorStoresDidChangeNotification: string;

declare const NSPersistentStoreCoordinatorStoresWillChangeNotification: string;

declare const NSStoreTypeKey: string;

declare const NSInMemoryStoreType: string;

declare const NSBinaryStoreType: string;

declare const NSRollbackMergePolicy: interop.Object;

declare const NSInvalidatedAllObjectsKey: string;

declare const NSManagedObjectContextQueryGenerationKey: string;

declare const NSInvalidatedObjectsKey: string;

declare const NSRefreshedObjectsKey: string;

declare const NSDeletedObjectsKey: string;

declare const NSInsertedObjectsKey: string;

declare const NSManagedObjectContextDidMergeChangesObjectIDsNotification: string;

declare const NSManagedObjectContextDidSaveObjectIDsNotification: string;

declare const NSManagedObjectContextDidSaveNotification: string;

declare const NSManagedObjectContextWillSaveNotification: string;

declare const NSManagedObjectModelReferenceNotFoundError: number;

declare const NSPersistentHistoryTokenExpiredError: number;

declare const NSInferredMappingModelError: number;

declare const NSEntityMigrationPolicyError: number;

declare const NSMigrationManagerDestinationStoreError: number;

declare const NSMigrationManagerSourceStoreError: number;

declare const NSCoreDataCoreSpotlightExporter: string;

declare const NSMigrationMissingMappingModelError: number;

declare const NSMigrationMissingSourceModelError: number;

declare const NSMigrationCancelledError: number;

declare const NSMigrationConstraintViolationError: number;

declare const NSPersistentStoreIncompatibleVersionHashError: number;

declare const NSPersistentStoreTimeoutError: number;

declare const NSPersistentStoreOpenError: number;

declare const NSPersistentStoreSaveConflictsError: number;

declare const NSPersistentStoreIncompleteSaveError: number;

declare const NSPersistentStoreInvalidTypeError: number;

declare const NSManagedObjectMergeError: number;

declare const NSPersistentStoreCoordinatorLockingError: number;

declare const NSManagedObjectContextLockingError: number;

declare const NSValidationInvalidURIError: number;

declare const NSValidationStringTooShortError: number;

declare const NSValidationStringTooLongError: number;

declare const NSValidationNumberTooLargeError: number;

declare const NSValidationRelationshipDeniedDeleteError: number;

declare const NSValidationRelationshipExceedsMaximumCountError: number;

declare const NSValidationRelationshipLacksMinimumCountError: number;

declare const NSValidationMissingMandatoryPropertyError: number;

declare const NSValidationMultipleErrorsError: number;

declare const NSManagedObjectConstraintValidationError: number;

declare const NSManagedObjectValidationError: number;

declare const NSSQLiteErrorDomain: string;

declare const NSPersistentStoreSaveConflictsErrorKey: string;

declare const NSAffectedStoresErrorKey: string;

declare const NSValidationValueErrorKey: string;

declare const NSValidationPredicateErrorKey: string;

declare const NSValidationKeyErrorKey: string;

declare const NSValidationObjectErrorKey: string;

declare const NSDetailedErrorsKey: string;

declare const NSManagedObjectConstraintMergeError: number;

declare const NSMigrationDestinationObjectKey: string;

declare const NSCoreDataError: number;

declare const NSPersistentStoreDidImportUbiquitousContentChangesNotification: string;

declare const NSSQLiteManualVacuumOption: string;

declare const NSPersistentHistoryTrackingKey: string;

declare const NSStoreModelVersionIdentifiersKey: string;

declare const NSExternalRecordImportError: number;

declare const NSPersistentStoreUnsupportedRequestTypeError: number;

declare const NSPersistentStoreTypeMismatchError: number;

declare const NSPersistentStoreForceDestroyOption: string;

declare const NSStagedMigrationFrameworkVersionMismatchError: number;

declare const NSReadOnlyPersistentStoreOption: string;

declare const NSOverwriteMergePolicy: interop.Object;

declare const NSRefreshedObjectIDsKey: string;

declare const NSStoreUUIDKey: string;

declare const NSPersistentStoreDeferredLightweightMigrationOptionKey: string;

declare const NSPersistentHistoryTokenKey: string;

declare const NSPersistentStoreCoordinatorWillRemoveStoreNotification: string;

declare const NSSQLiteStoreType: string;

declare const NSManagedObjectExternalRelationshipError: number;

declare const NSPersistentStoreOperationError: number;

declare const NSDeletedObjectIDsKey: string;

declare const NSAffectedObjectsErrorKey: string;

declare const NSPersistentStoreUbiquitousTransitionTypeKey: string;

declare const NSValidationDateTooLateError: number;

declare const NSManagedObjectContextObjectsDidChangeNotification: string;

declare const NSPersistentStoreURLKey: string;

declare const NSSQLiteError: number;

declare const NSMigrationSourceObjectKey: string;

declare const NSPersistentStoreIncompatibleSchemaError: number;

declare const NSPersistentStoreSaveError: number;

declare const NSSQLitePragmasOption: string;

declare const NSPersistentStoreConnectionPoolMaxSizeKey: string;

declare const NSUpdatedObjectsKey: string;

declare const NSCoreDataCoreSpotlightDelegateIndexDidUpdateNotification: string;

declare const NSCoreDataVersionNumber: number;

declare const NSValidationInvalidDateError: number;

declare const NSValidationDateTooSoonError: number;

declare const NSMergeByPropertyStoreTrumpMergePolicy: interop.Object;

declare const NSMigrationError: number;

declare const NSValidationStringPatternMatchingError: number;

declare const NSInsertedObjectIDsKey: string;

declare const NSInvalidatedObjectIDsKey: string;

declare const NSErrorMergePolicy: interop.Object;

declare const NSUpdatedObjectIDsKey: string;

declare const NSMergeByPropertyObjectTrumpMergePolicy: interop.Object;

declare const NSManagedObjectReferentialIntegrityError: number;

declare const NSValidationNumberTooSmallError: number;

declare const NSBinaryStoreInsecureDecodingCompatibilityOption: string;

declare const NSPersistentStoreRemoteChangeNotification: string;

declare const NSInferMappingModelAutomaticallyOption: string;

declare const NSStagedMigrationBackwardMigrationError: number;

declare const NSFetchRequestExpressionType: interop.Enum<typeof NSExpressionType>;

declare const NSPersistentCloudKitContainerEventType: {
  Setup: 0,
  Import: 1,
  Export: 2,
};

declare const NSPersistentHistoryChangeType: {
  Insert: 0,
  Update: 1,
  Delete: 2,
};

declare const NSMergePolicyType: {
  Error: 0,
  MergeByPropertyStoreTrump: 1,
  MergeByPropertyObjectTrump: 2,
  Overwrite: 3,
  Rollback: 4,
};

declare const NSPersistentCloudKitContainerEventResultType: {
  NSPersistentCloudKitContainerEventResultTypeEvents: 0,
  Count: 1,
};

declare const NSPersistentHistoryResultType: {
  StatusOnly: 0,
  ObjectIDs: 1,
  Count: 2,
  TransactionsOnly: 3,
  ChangesOnly: 4,
  TransactionsAndChanges: 5,
};

declare const NSPersistentStoreUbiquitousTransitionType: {
  AccountAdded: 1,
  AccountRemoved: 2,
  ContentRemoved: 3,
  InitialImportCompleted: 4,
};

declare const NSFetchRequestResultType: {
  ManagedObject: 0,
  ManagedObjectID: 1,
  Dictionary: 2,
  Count: 4,
};

declare const NSFetchIndexElementType: {
  Binary: 0,
  RTree: 1,
};

declare const NSDeleteRule: {
  NoAction: 0,
  Nullify: 1,
  Cascade: 2,
  Deny: 3,
};

declare const NSBatchUpdateRequestResultType: {
  StatusOnly: 0,
  UpdatedObjectIDs: 1,
  UpdatedObjectsCount: 2,
};

declare const NSSnapshotEventType: {
  UndoInsertion: 2,
  UndoDeletion: 4,
  UndoUpdate: 8,
  Rollback: 16,
  Refresh: 32,
  MergePolicy: 64,
};

declare const NSBatchDeleteRequestResultType: {
  StatusOnly: 0,
  ObjectIDs: 1,
  Count: 2,
};

declare const NSBatchInsertRequestResultType: {
  StatusOnly: 0,
  ObjectIDs: 1,
  Count: 2,
};

declare const NSPersistentCloudKitContainerSchemaInitializationOptions: {
  None: 0,
  DryRun: 2,
  PrintSchema: 4,
};

declare const NSAttributeType: {
  Undefined: 0,
  Integer16: 100,
  Integer32: 200,
  Integer64: 300,
  Decimal: 400,
  Double: 500,
  Float: 600,
  String: 700,
  Boolean: 800,
  Date: 900,
  BinaryData: 1000,
  UUID: 1100,
  URI: 1200,
  Transformable: 1800,
  ObjectID: 2000,
  Composite: 2100,
};

declare const NSPersistentStoreRequestType: {
  Fetch: 1,
  Save: 2,
  BatchInsert: 5,
  BatchUpdate: 6,
  BatchDelete: 7,
};

declare const NSEntityMappingType: {
  Undefined: 0,
  Custom: 1,
  Add: 2,
  Remove: 3,
  Copy: 4,
  Transform: 5,
};

declare const NSFetchedResultsChangeType: {
  Insert: 1,
  Delete: 2,
  Move: 3,
  Update: 4,
};

declare const NSManagedObjectContextConcurrencyType: {
  Confinement: 0,
  PrivateQueue: 1,
  MainQueue: 2,
};

declare interface NSFetchedResultsControllerDelegate extends NSObjectProtocol {
  controllerDidChangeContentWithSnapshot?(controller: NSFetchedResultsController, snapshot: NSDiffableDataSourceSnapshot): void;

  controllerDidChangeContentWithDifference?(controller: NSFetchedResultsController, diff: NSOrderedCollectionDifference): void;

  controllerDidChangeObjectAtIndexPathForChangeTypeNewIndexPath?(controller: NSFetchedResultsController, anObject: interop.Object, indexPath: NSIndexPath | null, type: interop.Enum<typeof NSFetchedResultsChangeType>, newIndexPath: NSIndexPath | null): void;

  controllerDidChangeSectionAtIndexForChangeType?(controller: NSFetchedResultsController, sectionInfo: NSFetchedResultsSectionInfo, sectionIndex: number, type: interop.Enum<typeof NSFetchedResultsChangeType>): void;

  controllerWillChangeContent?(controller: NSFetchedResultsController): void;

  controllerDidChangeContent?(controller: NSFetchedResultsController): void;

  controllerSectionIndexTitleForSectionName?(controller: NSFetchedResultsController, sectionName: string): string;
}

declare class NSFetchedResultsControllerDelegate extends NativeObject implements NSFetchedResultsControllerDelegate {
}

declare interface NSFetchedResultsSectionInfo {
  readonly name: string;

  readonly indexTitle: string;

  readonly numberOfObjects: number;

  readonly objects: NSArray;
}

declare class NSFetchedResultsSectionInfo extends NativeObject implements NSFetchedResultsSectionInfo {
}

declare interface NSFetchRequestResult extends NSObjectProtocol {
}

declare class NSFetchRequestResult extends NativeObject implements NSFetchRequestResult {
}

declare class NSManagedObjectModelReference extends NSObject {
  readonly resolvedModel: NSManagedObjectModel;

  readonly versionChecksum: string;

  initWithModelVersionChecksum(model: NSManagedObjectModel, versionChecksum: string): this;

  initWithFileURLVersionChecksum(fileURL: NSURL, versionChecksum: string): this;

  initWithEntityVersionHashesInBundleVersionChecksum(versionHash: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, bundle: NSBundle | null, versionChecksum: string): this;

  initWithNameInBundleVersionChecksum(modelName: string, bundle: NSBundle | null, versionChecksum: string): this;
}

declare class NSStagedMigrationManager extends NSObject {
  readonly stages: NSArray;

  readonly container: NSPersistentContainer;

  initWithMigrationStages(stages: NSArray<interop.Object> | Array<interop.Object>): this;
}

declare class NSPersistentCloudKitContainer extends NSPersistentContainer {
  initializeCloudKitSchemaWithOptionsError(options: interop.Enum<typeof NSPersistentCloudKitContainerSchemaInitializationOptions>, error: interop.PointerConvertible): this;

  recordForManagedObjectID(managedObjectID: NSManagedObjectID): CKRecord;

  recordsForManagedObjectIDs(managedObjectIDs: NSArray<interop.Object> | Array<interop.Object>): NSDictionary;

  recordIDForManagedObjectID(managedObjectID: NSManagedObjectID): CKRecordID;

  recordIDsForManagedObjectIDs(managedObjectIDs: NSArray<interop.Object> | Array<interop.Object>): NSDictionary;

  canUpdateRecordForManagedObjectWithID(objectID: NSManagedObjectID): boolean;

  canDeleteRecordForManagedObjectWithID(objectID: NSManagedObjectID): boolean;

  canModifyManagedObjectsInStore(store: NSPersistentStore): boolean;
}

declare class NSPersistentHistoryToken extends NSObject implements NSCopying, NSSecureCoding {
  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSPersistentHistoryChange extends NSObject implements NSCopying {
  static entityDescriptionWithContext(context: NSManagedObjectContext): NSEntityDescription;

  static readonly entityDescription: NSEntityDescription;

  static readonly fetchRequest: NSFetchRequest;

  readonly changeID: number;

  readonly changedObjectID: NSManagedObjectID;

  readonly changeType: interop.Enum<typeof NSPersistentHistoryChangeType>;

  readonly tombstone: NSDictionary;

  readonly transaction: NSPersistentHistoryTransaction;

  readonly updatedProperties: NSSet;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSQueryGenerationToken extends NSObject implements NSCopying, NSSecureCoding {
  static readonly currentQueryGenerationToken: NSQueryGenerationToken;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSFetchedResultsController<ResultType = interop.Object> extends NSObject {
  initWithFetchRequestManagedObjectContextSectionNameKeyPathCacheName(fetchRequest: NSFetchRequest, context: NSManagedObjectContext, sectionNameKeyPath: string | null, name: string | null): this;

  performFetch(error: interop.PointerConvertible): boolean;

  readonly fetchRequest: NSFetchRequest;

  readonly managedObjectContext: NSManagedObjectContext;

  readonly sectionNameKeyPath: string;

  readonly cacheName: string;

  delegate: NSFetchedResultsControllerDelegate;

  static deleteCacheWithName<ResultType>(name: string | null): void;

  readonly fetchedObjects: NSArray;

  objectAtIndexPath(indexPath: NSIndexPath): ResultType;

  indexPathForObject(object: ResultType): NSIndexPath;

  sectionIndexTitleForSectionName(sectionName: string): string;

  readonly sectionIndexTitles: NSArray;

  readonly sections: NSArray;

  sectionForSectionIndexTitleAtIndex(title: string, sectionIndex: number): number;
}

declare class NSMergePolicy extends NSObject {
  static readonly errorMergePolicy: NSMergePolicy;

  static readonly rollbackMergePolicy: NSMergePolicy;

  static readonly overwriteMergePolicy: NSMergePolicy;

  static readonly mergeByPropertyObjectTrumpMergePolicy: NSMergePolicy;

  static readonly mergeByPropertyStoreTrumpMergePolicy: NSMergePolicy;

  readonly mergeType: interop.Enum<typeof NSMergePolicyType>;

  initWithMergeType(ty: interop.Enum<typeof NSMergePolicyType>): this;

  resolveConflictsError(list: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): boolean;

  resolveOptimisticLockingVersionConflictsError(list: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): boolean;

  resolveConstraintConflictsError(list: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): boolean;
}

declare class NSConstraintConflict extends NSObject {
  readonly constraint: NSArray;

  readonly constraintValues: NSDictionary;

  readonly databaseObject: NSManagedObject;

  readonly databaseSnapshot: NSDictionary;

  readonly conflictingObjects: NSArray;

  readonly conflictingSnapshots: NSArray;

  initWithConstraintDatabaseObjectDatabaseSnapshotConflictingObjectsConflictingSnapshots(contraint: NSArray<interop.Object> | Array<interop.Object>, databaseObject: NSManagedObject | null, databaseSnapshot: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, conflictingObjects: NSArray<interop.Object> | Array<interop.Object>, conflictingSnapshots: NSArray<interop.Object> | Array<interop.Object>): this;
}

declare class NSBatchInsertRequest extends NSPersistentStoreRequest {
  readonly entityName: string;

  readonly entity: NSEntityDescription;

  get objectsToInsert(): NSArray;
  set objectsToInsert(value: NSArray<interop.Object> | Array<interop.Object>);

  dictionaryHandler: (p1: NSMutableDictionary) => boolean;

  managedObjectHandler: (p1: NSManagedObject) => boolean;

  resultType: interop.Enum<typeof NSBatchInsertRequestResultType>;

  static batchInsertRequestWithEntityNameObjects<This extends abstract new (...args: any) => any>(this: This, entityName: string, dictionaries: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  static batchInsertRequestWithEntityNameDictionaryHandler<This extends abstract new (...args: any) => any>(this: This, entityName: string, handler: (p1: NSMutableDictionary) => boolean): InstanceType<This>;

  static batchInsertRequestWithEntityNameManagedObjectHandler<This extends abstract new (...args: any) => any>(this: This, entityName: string, handler: (p1: NSManagedObject) => boolean): InstanceType<This>;

  init(): this;

  initWithEntityNameObjects(entityName: string, dictionaries: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithEntityObjects(entity: NSEntityDescription, dictionaries: NSArray<interop.Object> | Array<interop.Object>): this;

  initWithEntityDictionaryHandler(entity: NSEntityDescription, handler: (p1: NSMutableDictionary) => boolean): this;

  initWithEntityManagedObjectHandler(entity: NSEntityDescription, handler: (p1: NSManagedObject) => boolean): this;

  initWithEntityNameDictionaryHandler(entityName: string, handler: (p1: NSMutableDictionary) => boolean): this;

  initWithEntityNameManagedObjectHandler(entityName: string, handler: (p1: NSManagedObject) => boolean): this;
}

declare class NSBatchDeleteRequest extends NSPersistentStoreRequest {
  initWithFetchRequest(fetch: NSFetchRequest): this;

  initWithObjectIDs(objects: NSArray<interop.Object> | Array<interop.Object>): this;

  resultType: interop.Enum<typeof NSBatchDeleteRequestResultType>;

  readonly fetchRequest: NSFetchRequest;
}

declare class NSBatchUpdateRequest extends NSPersistentStoreRequest {
  static batchUpdateRequestWithEntityName<This extends abstract new (...args: any) => any>(this: This, entityName: string): InstanceType<This>;

  initWithEntityName(entityName: string): this;

  initWithEntity(entity: NSEntityDescription): this;

  readonly entityName: string;

  readonly entity: NSEntityDescription;

  predicate: NSPredicate;

  includesSubentities: boolean;

  resultType: interop.Enum<typeof NSBatchUpdateRequestResultType>;

  get propertiesToUpdate(): NSDictionary;
  set propertiesToUpdate(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);
}

declare class NSSaveChangesRequest extends NSPersistentStoreRequest {
  initWithInsertedObjectsUpdatedObjectsDeletedObjectsLockedObjects(insertedObjects: NSSet | null, updatedObjects: NSSet | null, deletedObjects: NSSet | null, lockedObjects: NSSet | null): this;

  readonly insertedObjects: NSSet;

  readonly updatedObjects: NSSet;

  readonly deletedObjects: NSSet;

  readonly lockedObjects: NSSet;
}

declare class NSPersistentCloudKitContainerEventResult extends NSPersistentStoreResult {
  readonly result: interop.Object;

  readonly resultType: interop.Enum<typeof NSPersistentCloudKitContainerEventResultType>;
}

declare class NSBatchInsertResult extends NSPersistentStoreResult {
  readonly result: interop.Object;

  readonly resultType: interop.Enum<typeof NSBatchInsertRequestResultType>;
}

declare class NSAsynchronousFetchResult<ResultType = interop.Object> extends NSPersistentStoreAsynchronousResult {
  readonly fetchRequest: NSAsynchronousFetchRequest;

  readonly finalResult: NSArray;
}

declare class NSPersistentStoreResult extends NSObject {
}

declare class NSMigrationManager extends NSObject {
  initWithSourceModelDestinationModel(sourceModel: NSManagedObjectModel, destinationModel: NSManagedObjectModel): this;

  migrateStoreFromURLTypeOptionsWithMappingModelToDestinationURLDestinationTypeDestinationOptionsError(sourceURL: NSURL, sStoreType: string, sOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, mappings: NSMappingModel | null, dURL: NSURL, dStoreType: string, dOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;

  usesStoreSpecificMigrationManager: boolean;

  reset(): void;

  readonly mappingModel: NSMappingModel;

  readonly sourceModel: NSManagedObjectModel;

  readonly destinationModel: NSManagedObjectModel;

  readonly sourceContext: NSManagedObjectContext;

  readonly destinationContext: NSManagedObjectContext;

  sourceEntityForEntityMapping(mEntity: NSEntityMapping): NSEntityDescription;

  destinationEntityForEntityMapping(mEntity: NSEntityMapping): NSEntityDescription;

  associateSourceInstanceWithDestinationInstanceForEntityMapping(sourceInstance: NSManagedObject, destinationInstance: NSManagedObject, entityMapping: NSEntityMapping): void;

  destinationInstancesForEntityMappingNamedSourceInstances(mappingName: string, sourceInstances: NSArray<interop.Object> | Array<interop.Object> | null): NSArray;

  sourceInstancesForEntityMappingNamedDestinationInstances(mappingName: string, destinationInstances: NSArray<interop.Object> | Array<interop.Object> | null): NSArray;

  readonly currentEntityMapping: NSEntityMapping;

  readonly migrationProgress: number;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  cancelMigrationWithError(error: NSError): void;
}

declare class NSPropertyMapping extends NSObject {
  name: string;

  valueExpression: NSExpression;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);
}

declare class NSEntityMigrationPolicy extends NSObject {
  beginEntityMappingManagerError(mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;

  createDestinationInstancesForSourceInstanceEntityMappingManagerError(sInstance: NSManagedObject, mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;

  endInstanceCreationForEntityMappingManagerError(mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;

  createRelationshipsForDestinationInstanceEntityMappingManagerError(dInstance: NSManagedObject, mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;

  endRelationshipCreationForEntityMappingManagerError(mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;

  performCustomValidationForEntityMappingManagerError(mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;

  endEntityMappingManagerError(mapping: NSEntityMapping, manager: NSMigrationManager, error: interop.PointerConvertible): boolean;
}

declare class NSPersistentStore extends NSObject {
  static metadataForPersistentStoreWithURLError(url: NSURL, error: interop.PointerConvertible): NSDictionary;

  static setMetadataForPersistentStoreWithURLError(metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, url: NSURL, error: interop.PointerConvertible): boolean;

  static migrationManagerClass(): interop.Object;

  initWithPersistentStoreCoordinatorConfigurationNameURLOptions(root: NSPersistentStoreCoordinator | null, name: string | null, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  loadMetadata(error: interop.PointerConvertible): boolean;

  readonly persistentStoreCoordinator: NSPersistentStoreCoordinator;

  readonly configurationName: string;

  readonly options: NSDictionary;

  URL: NSURL;

  identifier: string;

  readonly type: string;

  isReadOnly: boolean;

  get metadata(): NSDictionary;
  set metadata(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  didAddToPersistentStoreCoordinator(coordinator: NSPersistentStoreCoordinator): void;

  willRemoveFromPersistentStoreCoordinator(coordinator: NSPersistentStoreCoordinator | null): void;

  readonly coreSpotlightExporter: NSCoreDataCoreSpotlightDelegate;
}

declare class NSPersistentStoreCoordinator extends NSObject implements NSLocking {
  initWithManagedObjectModel(model: NSManagedObjectModel): this;

  readonly managedObjectModel: NSManagedObjectModel;

  readonly persistentStores: NSArray;

  name: string;

  persistentStoreForURL(URL: NSURL): NSPersistentStore;

  URLForPersistentStore(store: NSPersistentStore): NSURL;

  setURLForPersistentStore(url: NSURL, store: NSPersistentStore): boolean;

  addPersistentStoreWithTypeConfigurationURLOptionsError(storeType: string, configuration: string | null, storeURL: NSURL | null, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): NSPersistentStore;

  addPersistentStoreWithDescriptionCompletionHandler(storeDescription: NSPersistentStoreDescription, block: (p1: NSPersistentStoreDescription, p2: NSError) => void | null): void;

  removePersistentStoreError(store: NSPersistentStore, error: interop.PointerConvertible): boolean;

  setMetadataForPersistentStore(metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, store: NSPersistentStore): void;

  metadataForPersistentStore(store: NSPersistentStore): NSDictionary;

  managedObjectIDForURIRepresentation(url: NSURL): NSManagedObjectID;

  executeRequestWithContextError(request: NSPersistentStoreRequest, context: NSManagedObjectContext, error: interop.PointerConvertible): interop.Object;

  static readonly registeredStoreTypes: NSDictionary;

  static registerStoreClassForStoreType(storeClass: interop.Object | null, storeType: string): void;

  static metadataForPersistentStoreOfTypeURLOptionsError(storeType: string, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): NSDictionary;

  static setMetadataForPersistentStoreOfTypeURLOptionsError(metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, storeType: string, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;

  migratePersistentStoreToURLOptionsWithTypeError(store: NSPersistentStore, URL: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, storeType: string, error: interop.PointerConvertible): NSPersistentStore;

  destroyPersistentStoreAtURLWithTypeOptionsError(url: NSURL, storeType: string, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;

  replacePersistentStoreAtURLDestinationOptionsWithPersistentStoreFromURLSourceOptionsStoreTypeError(destinationURL: NSURL, destinationOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, sourceURL: NSURL, sourceOptions: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, storeType: string, error: interop.PointerConvertible): boolean;

  performBlock(block: () => void): void;

  performBlockAndWait(block: () => void): void;

  currentPersistentHistoryTokenFromStores(stores: NSArray<interop.Object> | Array<interop.Object> | null): NSPersistentHistoryToken;

  finishDeferredLightweightMigration(error: interop.PointerConvertible): boolean;

  finishDeferredLightweightMigrationTask(error: interop.PointerConvertible): boolean;

  managedObjectIDFromUTF8StringLength(utf8string: string, len: number): NSManagedObjectID;

  lock(): void;

  unlock(): void;

  tryLock(): boolean;

  static metadataForPersistentStoreOfTypeURLError(storeType: string | null, url: NSURL, error: interop.PointerConvertible): NSDictionary;

  static setMetadataForPersistentStoreOfTypeURLError(metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, storeType: string | null, url: NSURL, error: interop.PointerConvertible): boolean;

  static removeUbiquitousContentAndPersistentStoreAtURLOptionsError(storeURL: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): boolean;
}

declare class NSManagedObjectContext extends NSObject implements NSCoding, NSLocking {
  static new<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  init(): this;

  initWithConcurrencyType(ct: interop.Enum<typeof NSManagedObjectContextConcurrencyType>): this;

  performBlock(block: () => void): void;

  performBlockAndWait(block: () => void): void;

  persistentStoreCoordinator: NSPersistentStoreCoordinator;

  parentContext: NSManagedObjectContext;

  name: string;

  undoManager: NSUndoManager;

  readonly hasChanges: boolean;

  readonly userInfo: NSMutableDictionary;

  readonly concurrencyType: interop.Enum<typeof NSManagedObjectContextConcurrencyType>;

  objectRegisteredForID(objectID: NSManagedObjectID): NSManagedObject;

  objectWithID(objectID: NSManagedObjectID): NSManagedObject;

  existingObjectWithIDError(objectID: NSManagedObjectID, error: interop.PointerConvertible): NSManagedObject;

  executeFetchRequestError(request: NSFetchRequest, error: interop.PointerConvertible): NSArray;

  countForFetchRequestError(request: NSFetchRequest, error: interop.PointerConvertible): number;

  executeRequestError(request: NSPersistentStoreRequest, error: interop.PointerConvertible): NSPersistentStoreResult;

  insertObject(object: NSManagedObject): void;

  deleteObject(object: NSManagedObject): void;

  refreshObjectMergeChanges(object: NSManagedObject, flag: boolean): void;

  detectConflictsForObject(object: NSManagedObject): void;

  observeValueForKeyPathOfObjectChangeContext(keyPath: string | null, object: interop.Object | null, change: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, context: interop.PointerConvertible): void;

  processPendingChanges(): void;

  assignObjectToPersistentStore(object: interop.Object, store: NSPersistentStore): void;

  readonly insertedObjects: NSSet;

  readonly updatedObjects: NSSet;

  readonly deletedObjects: NSSet;

  readonly registeredObjects: NSSet;

  undo(): void;

  redo(): void;

  reset(): void;

  rollback(): void;

  save(error: interop.PointerConvertible): boolean;

  refreshAllObjects(): void;

  lock(): void;

  unlock(): void;

  tryLock(): boolean;

  propagatesDeletesAtEndOfEvent: boolean;

  retainsRegisteredObjects: boolean;

  shouldDeleteInaccessibleFaults: boolean;

  shouldHandleInaccessibleFaultForObjectIDTriggeredByProperty(fault: NSManagedObject, oid: NSManagedObjectID, property: NSPropertyDescription | null): boolean;

  stalenessInterval: number;

  mergePolicy: interop.Object;

  obtainPermanentIDsForObjectsError(objects: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): boolean;

  mergeChangesFromContextDidSaveNotification(notification: NSNotification): void;

  static mergeChangesFromRemoteContextSaveIntoContexts(changeNotificationData: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, contexts: NSArray<interop.Object> | Array<interop.Object>): void;

  readonly queryGenerationToken: NSQueryGenerationToken;

  setQueryGenerationFromTokenError(generation: NSQueryGenerationToken | null, error: interop.PointerConvertible): boolean;

  automaticallyMergesChangesFromParent: boolean;

  transactionAuthor: string;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class NSFetchIndexElementDescription extends NSObject implements NSCoding, NSCopying {
  initWithPropertyCollationType(property: NSPropertyDescription, collationType: interop.Enum<typeof NSFetchIndexElementType>): this;

  readonly property: NSPropertyDescription;

  readonly propertyName: string;

  collationType: interop.Enum<typeof NSFetchIndexElementType>;

  isAscending: boolean;

  readonly indexDescription: NSFetchIndexDescription;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSRelationshipDescription extends NSPropertyDescription {
  destinationEntity: NSEntityDescription;

  inverseRelationship: NSRelationshipDescription;

  maxCount: number;

  minCount: number;

  deleteRule: interop.Enum<typeof NSDeleteRule>;

  readonly isToMany: boolean;

  readonly versionHash: NSData;

  isOrdered: boolean;
}

declare class NSExpressionDescription extends NSPropertyDescription {
  expression: NSExpression;

  expressionResultType: interop.Enum<typeof NSAttributeType>;
}

declare class NSFetchedPropertyDescription extends NSPropertyDescription {
  fetchRequest: NSFetchRequest;
}

declare class NSPropertyDescription extends NSObject implements NSCoding, NSCopying {
  readonly entity: NSEntityDescription;

  name: string;

  isOptional: boolean;

  isTransient: boolean;

  readonly validationPredicates: NSArray;

  readonly validationWarnings: NSArray;

  setValidationPredicatesWithValidationWarnings(validationPredicates: NSArray<interop.Object> | Array<interop.Object> | null, validationWarnings: NSArray<interop.Object> | Array<interop.Object> | null): void;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  isIndexed: boolean;

  readonly versionHash: NSData;

  versionHashModifier: string;

  isIndexedBySpotlight: boolean;

  isStoredInExternalRecord: boolean;

  renamingIdentifier: string;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSManagedObjectID extends NSObject implements NSCopying {
  readonly entity: NSEntityDescription;

  readonly persistentStore: NSPersistentStore;

  readonly isTemporaryID: boolean;

  URIRepresentation(): NSURL;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSPersistentHistoryResult extends NSPersistentStoreResult {
  readonly result: interop.Object;

  readonly resultType: interop.Enum<typeof NSPersistentHistoryResultType>;
}

declare class NSPersistentCloudKitContainerEvent extends NSObject implements NSCopying {
  readonly identifier: NSUUID;

  readonly storeIdentifier: string;

  readonly type: interop.Enum<typeof NSPersistentCloudKitContainerEventType>;

  readonly startDate: NSDate;

  readonly endDate: NSDate;

  readonly succeeded: boolean;

  readonly error: NSError;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSMergeConflict extends NSObject {
  readonly sourceObject: NSManagedObject;

  readonly objectSnapshot: NSDictionary;

  readonly cachedSnapshot: NSDictionary;

  readonly persistedSnapshot: NSDictionary;

  readonly newVersionNumber: number;

  readonly oldVersionNumber: number;

  initWithSourceNewVersionOldVersionCachedSnapshotPersistedSnapshot(srcObject: NSManagedObject, newvers: number, oldvers: number, cachesnap: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, persnap: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;
}

declare class NSPersistentCloudKitContainerEventRequest extends NSPersistentStoreRequest {
  resultType: interop.Enum<typeof NSPersistentCloudKitContainerEventResultType>;

  static fetchEventsAfterDate<This extends abstract new (...args: any) => any>(this: This, date: NSDate): InstanceType<This>;

  static fetchEventsAfterEvent<This extends abstract new (...args: any) => any>(this: This, event: NSPersistentCloudKitContainerEvent | null): InstanceType<This>;

  static fetchEventsMatchingFetchRequest<This extends abstract new (...args: any) => any>(this: This, fetchRequest: NSFetchRequest): InstanceType<This>;

  static fetchRequestForEvents(): NSFetchRequest;
}

declare class NSCoreDataCoreSpotlightDelegate extends NSObject {
  readonly isIndexingEnabled: boolean;

  domainIdentifier(): string;

  indexName(): string;

  initForStoreWithDescriptionCoordinator(description: NSPersistentStoreDescription, psc: NSPersistentStoreCoordinator): this;

  initForStoreWithDescriptionModel(description: NSPersistentStoreDescription, model: NSManagedObjectModel): this;

  startSpotlightIndexing(): void;

  stopSpotlightIndexing(): void;

  deleteSpotlightIndexWithCompletionHandler(completionHandler: (p1: NSError) => void | null): void;

  attributeSetForObject(object: NSManagedObject): CSSearchableItemAttributeSet;

  searchableIndexReindexAllSearchableItemsWithAcknowledgementHandler(searchableIndex: CSSearchableIndex, acknowledgementHandler: () => void): void;

  searchableIndexReindexSearchableItemsWithIdentifiersAcknowledgementHandler(searchableIndex: CSSearchableIndex, identifiers: NSArray<interop.Object> | Array<interop.Object>, acknowledgementHandler: () => void): void;
}

declare class NSManagedObjectModel extends NSObject implements NSCoding, NSCopying, NSFastEnumeration {
  static mergedModelFromBundles(bundles: NSArray<interop.Object> | Array<interop.Object> | null): NSManagedObjectModel;

  static modelByMergingModels(models: NSArray<interop.Object> | Array<interop.Object> | null): NSManagedObjectModel;

  init(): this;

  initWithContentsOfURL(url: NSURL): this;

  readonly entitiesByName: NSDictionary;

  get entities(): NSArray;
  set entities(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly configurations: NSArray;

  entitiesForConfiguration(configuration: string | null): NSArray;

  setEntitiesForConfiguration(entities: NSArray<interop.Object> | Array<interop.Object>, configuration: string): void;

  setFetchRequestTemplateForName(fetchRequestTemplate: NSFetchRequest | null, name: string): void;

  fetchRequestTemplateForName(name: string): NSFetchRequest;

  fetchRequestFromTemplateWithNameSubstitutionVariables(name: string, variables: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSFetchRequest;

  get localizationDictionary(): NSDictionary;
  set localizationDictionary(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  static mergedModelFromBundlesForStoreMetadata(bundles: NSArray<interop.Object> | Array<interop.Object> | null, metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSManagedObjectModel;

  static modelByMergingModelsForStoreMetadata(models: NSArray<interop.Object> | Array<interop.Object>, metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): NSManagedObjectModel;

  readonly fetchRequestTemplatesByName: NSDictionary;

  versionIdentifiers: NSSet;

  isConfigurationCompatibleWithStoreMetadata(configuration: string | null, metadata: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): boolean;

  readonly entityVersionHashesByName: NSDictionary;

  readonly versionChecksum: string;

  static checksumsForVersionedModelAtURLError(modelURL: NSURL, error: interop.PointerConvertible): NSDictionary;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  readonly [Symbol.iterator]: () => Iterator<any>;

}

declare class NSFetchIndexDescription extends NSObject implements NSCoding, NSCopying {
  initWithNameElements(name: string, elements: NSArray<interop.Object> | Array<interop.Object> | null): this;

  name: string;

  get elements(): NSArray;
  set elements(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly entity: NSEntityDescription;

  partialIndexPredicate: NSPredicate;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSPersistentStoreDescription extends NSObject implements NSCopying {
  static persistentStoreDescriptionWithURL<This extends abstract new (...args: any) => any>(this: This, URL: NSURL): InstanceType<This>;

  type: string;

  configuration: string;

  URL: NSURL;

  readonly options: NSDictionary;

  setOptionForKey(option: NSObject | null, key: string): void;

  isReadOnly: boolean;

  timeout: number;

  readonly sqlitePragmas: NSDictionary;

  setValueForPragmaNamed(value: NSObject | null, name: string): void;

  shouldAddStoreAsynchronously: boolean;

  shouldMigrateStoreAutomatically: boolean;

  shouldInferMappingModelAutomatically: boolean;

  initWithURL(url: NSURL): this;

  cloudKitContainerOptions: NSPersistentCloudKitContainerOptions;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSPersistentCloudKitContainerOptions extends NSObject {
  readonly containerIdentifier: string;

  databaseScope: interop.Enum<typeof CKDatabaseScope>;

  initWithContainerIdentifier(containerIdentifier: string): this;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSManagedObject extends NSObject {
  static readonly contextShouldIgnoreUnmodeledPropertyChanges: boolean;

  static entity(): NSEntityDescription;

  static fetchRequest(): NSFetchRequest;

  initWithEntityInsertIntoManagedObjectContext(entity: NSEntityDescription, context: NSManagedObjectContext | null): this;

  initWithContext(moc: NSManagedObjectContext): this;

  readonly managedObjectContext: NSManagedObjectContext;

  readonly entity: NSEntityDescription;

  readonly objectID: NSManagedObjectID;

  readonly isInserted: boolean;

  readonly isUpdated: boolean;

  readonly isDeleted: boolean;

  readonly hasChanges: boolean;

  readonly hasPersistentChangedValues: boolean;

  readonly isFault: boolean;

  hasFaultForRelationshipNamed(key: string): boolean;

  objectIDsForRelationshipNamed(key: string): NSArray;

  readonly faultingState: number;

  willAccessValueForKey(key: string | null): void;

  didAccessValueForKey(key: string | null): void;

  willChangeValueForKey(key: string): void;

  didChangeValueForKey(key: string): void;

  // @ts-ignore MemberDecl.tsIgnore
  willChangeValueForKeyWithSetMutationUsingObjects(inKey: string, inMutationKind: interop.Enum<typeof NSKeyValueSetMutationKind>, inObjects: NSSet): void;

  // @ts-ignore MemberDecl.tsIgnore
  didChangeValueForKeyWithSetMutationUsingObjects(inKey: string, inMutationKind: interop.Enum<typeof NSKeyValueSetMutationKind>, inObjects: NSSet): void;

  awakeFromFetch(): void;

  awakeFromInsert(): void;

  awakeFromSnapshotEvents(flags: interop.Enum<typeof NSSnapshotEventType>): void;

  prepareForDeletion(): void;

  willSave(): void;

  didSave(): void;

  willTurnIntoFault(): void;

  didTurnIntoFault(): void;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;

  primitiveValueForKey(key: string): interop.Object;

  setPrimitiveValueForKey(value: interop.Object | null, key: string): void;

  committedValuesForKeys(keys: NSArray<interop.Object> | Array<interop.Object> | null): NSDictionary;

  changedValues(): NSDictionary;

  changedValuesForCurrentEvent(): NSDictionary;

  // @ts-ignore MemberDecl.tsIgnore
  validateValueForKeyError(value: interop.PointerConvertible, key: string, error: interop.PointerConvertible): boolean;

  validateForDelete(error: interop.PointerConvertible): boolean;

  validateForInsert(error: interop.PointerConvertible): boolean;

  validateForUpdate(error: interop.PointerConvertible): boolean;
}

declare class NSPersistentStoreAsynchronousResult extends NSPersistentStoreResult {
  readonly managedObjectContext: NSManagedObjectContext;

  readonly operationError: NSError;

  readonly progress: NSProgress;

  cancel(): void;
}

declare class NSAttributeDescription extends NSPropertyDescription {
  attributeType: interop.Enum<typeof NSAttributeType>;

  attributeValueClassName: string;

  defaultValue: interop.Object;

  readonly versionHash: NSData;

  valueTransformerName: string;

  allowsExternalBinaryDataStorage: boolean;

  preservesValueInHistoryOnDeletion: boolean;

  allowsCloudEncryption: boolean;
}

declare class NSEntityMapping extends NSObject {
  name: string;

  mappingType: interop.Enum<typeof NSEntityMappingType>;

  sourceEntityName: string;

  sourceEntityVersionHash: NSData;

  destinationEntityName: string;

  destinationEntityVersionHash: NSData;

  get attributeMappings(): NSArray;
  set attributeMappings(value: NSArray<interop.Object> | Array<interop.Object>);

  get relationshipMappings(): NSArray;
  set relationshipMappings(value: NSArray<interop.Object> | Array<interop.Object>);

  sourceExpression: NSExpression;

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  entityMigrationPolicyClassName: string;
}

declare class NSIncrementalStoreNode extends NSObject {
  initWithObjectIDWithValuesVersion(objectID: NSManagedObjectID, values: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, version: number): this;

  updateWithValuesVersion(values: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>, version: number): void;

  readonly objectID: NSManagedObjectID;

  readonly version: number;

  valueForPropertyDescription(prop: NSPropertyDescription): interop.Object;
}

declare class NSFetchRequestExpression extends NSExpression {
  static expressionForFetchContextCountOnly(fetch: NSExpression, context: NSExpression, countFlag: boolean): NSExpression;

  readonly requestExpression: NSExpression;

  readonly contextExpression: NSExpression;

  readonly isCountOnlyRequest: boolean;
}

declare class NSCompositeAttributeDescription extends NSAttributeDescription {
  get elements(): NSArray;
  set elements(value: NSArray<interop.Object> | Array<interop.Object>);
}

declare class NSEntityDescription extends NSObject implements NSCoding, NSCopying, NSFastEnumeration {
  static entityForNameInManagedObjectContext(entityName: string, context: NSManagedObjectContext): NSEntityDescription;

  static insertNewObjectForEntityForNameInManagedObjectContext(entityName: string, context: NSManagedObjectContext): NSManagedObject;

  readonly managedObjectModel: NSManagedObjectModel;

  managedObjectClassName: string;

  name: string;

  isAbstract: boolean;

  readonly subentitiesByName: NSDictionary;

  get subentities(): NSArray;
  set subentities(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly superentity: NSEntityDescription;

  readonly propertiesByName: NSDictionary;

  get properties(): NSArray;
  set properties(value: NSArray<interop.Object> | Array<interop.Object>);

  get userInfo(): NSDictionary;
  set userInfo(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  readonly attributesByName: NSDictionary;

  readonly relationshipsByName: NSDictionary;

  relationshipsWithDestinationEntity(entity: NSEntityDescription): NSArray;

  isKindOfEntity(entity: NSEntityDescription): boolean;

  readonly versionHash: NSData;

  versionHashModifier: string;

  renamingIdentifier: string;

  get indexes(): NSArray;
  set indexes(value: NSArray<interop.Object> | Array<interop.Object>);

  get uniquenessConstraints(): NSArray;
  set uniquenessConstraints(value: NSArray<interop.Object> | Array<interop.Object>);

  get compoundIndexes(): NSArray;
  set compoundIndexes(value: NSArray<interop.Object> | Array<interop.Object>);

  coreSpotlightDisplayNameExpression: NSExpression;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  countByEnumeratingWithStateObjectsCount(state: interop.PointerConvertible, buffer: interop.PointerConvertible, len: number): number;

  readonly [Symbol.iterator]: () => Iterator<any>;

}

declare class NSFetchRequest<ResultType = interop.Object> extends NSPersistentStoreRequest implements NSCoding, NSCopying {
  static fetchRequestWithEntityName<ResultType, This extends abstract new (...args: any) => any>(this: This, entityName: string): InstanceType<This>;

  init(): this;

  initWithEntityName(entityName: string): this;

  execute(error: interop.PointerConvertible): NSArray;

  entity: NSEntityDescription;

  readonly entityName: string;

  predicate: NSPredicate;

  get sortDescriptors(): NSArray;
  set sortDescriptors(value: NSArray<interop.Object> | Array<interop.Object>);

  fetchLimit: number;

  get affectedStores(): NSArray;
  set affectedStores(value: NSArray<interop.Object> | Array<interop.Object>);

  resultType: interop.Enum<typeof NSFetchRequestResultType>;

  includesSubentities: boolean;

  includesPropertyValues: boolean;

  returnsObjectsAsFaults: boolean;

  get relationshipKeyPathsForPrefetching(): NSArray;
  set relationshipKeyPathsForPrefetching(value: NSArray<interop.Object> | Array<interop.Object>);

  includesPendingChanges: boolean;

  returnsDistinctResults: boolean;

  get propertiesToFetch(): NSArray;
  set propertiesToFetch(value: NSArray<interop.Object> | Array<interop.Object>);

  fetchOffset: number;

  fetchBatchSize: number;

  shouldRefreshRefetchedObjects: boolean;

  get propertiesToGroupBy(): NSArray;
  set propertiesToGroupBy(value: NSArray<interop.Object> | Array<interop.Object>);

  havingPredicate: NSPredicate;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSAsynchronousFetchRequest<ResultType = interop.Object> extends NSPersistentStoreRequest {
  readonly fetchRequest: NSFetchRequest;

  readonly completionBlock: (p1: NSAsynchronousFetchResult) => void;

  estimatedResultCount: number;

  initWithFetchRequestCompletionBlock(request: NSFetchRequest, blk: (p1: NSAsynchronousFetchResult) => void | null): this;
}

declare class NSCustomMigrationStage extends NSMigrationStage {
  readonly currentModel: NSManagedObjectModelReference;

  readonly nextModel: NSManagedObjectModelReference;

  willMigrateHandler: (p1: NSStagedMigrationManager, p2: NSCustomMigrationStage, p3: interop.PointerConvertible) => boolean | null;

  didMigrateHandler: (p1: NSStagedMigrationManager, p2: NSCustomMigrationStage, p3: interop.PointerConvertible) => boolean | null;

  initWithCurrentModelReferenceNextModelReference(currentModel: NSManagedObjectModelReference, nextModel: NSManagedObjectModelReference): this;
}

declare class NSPersistentStoreRequest extends NSObject implements NSCopying {
  get affectedStores(): NSArray;
  set affectedStores(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly requestType: interop.Enum<typeof NSPersistentStoreRequestType>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSMigrationStage extends NSObject {
  label: string;
}

declare class NSMappingModel extends NSObject {
  static mappingModelFromBundlesForSourceModelDestinationModel(bundles: NSArray<interop.Object> | Array<interop.Object> | null, sourceModel: NSManagedObjectModel | null, destinationModel: NSManagedObjectModel | null): NSMappingModel;

  static inferredMappingModelForSourceModelDestinationModelError(sourceModel: NSManagedObjectModel, destinationModel: NSManagedObjectModel, error: interop.PointerConvertible): NSMappingModel;

  initWithContentsOfURL(url: NSURL | null): this;

  get entityMappings(): NSArray;
  set entityMappings(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly entityMappingsByName: NSDictionary;
}

// @ts-ignore ClassDecl.tsIgnore
declare class NSAtomicStore extends NSPersistentStore {
  // @ts-ignore MemberDecl.tsIgnore
  initWithPersistentStoreCoordinatorConfigurationNameURLOptions(coordinator: NSPersistentStoreCoordinator | null, configurationName: string | null, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  load(error: interop.PointerConvertible): boolean;

  save(error: interop.PointerConvertible): boolean;

  newCacheNodeForManagedObject(managedObject: NSManagedObject): NSAtomicStoreCacheNode;

  updateCacheNodeFromManagedObject(node: NSAtomicStoreCacheNode, managedObject: NSManagedObject): void;

  cacheNodes(): NSSet;

  addCacheNodes(cacheNodes: NSSet): void;

  willRemoveCacheNodes(cacheNodes: NSSet): void;

  cacheNodeForObjectID(objectID: NSManagedObjectID): NSAtomicStoreCacheNode;

  objectIDForEntityReferenceObject(entity: NSEntityDescription, data: interop.Object): NSManagedObjectID;

  newReferenceObjectForManagedObject(managedObject: NSManagedObject): interop.Object;

  referenceObjectForObjectID(objectID: NSManagedObjectID): interop.Object;
}

declare class NSIncrementalStore extends NSPersistentStore {
  loadMetadata(error: interop.PointerConvertible): boolean;

  executeRequestWithContextError(request: NSPersistentStoreRequest, context: NSManagedObjectContext | null, error: interop.PointerConvertible): interop.Object;

  newValuesForObjectWithIDWithContextError(objectID: NSManagedObjectID, context: NSManagedObjectContext, error: interop.PointerConvertible): NSIncrementalStoreNode;

  newValueForRelationshipForObjectWithIDWithContextError(relationship: NSRelationshipDescription, objectID: NSManagedObjectID, context: NSManagedObjectContext | null, error: interop.PointerConvertible): interop.Object;

  static identifierForNewStoreAtURL(storeURL: NSURL): interop.Object;

  obtainPermanentIDsForObjectsError(array: NSArray<interop.Object> | Array<interop.Object>, error: interop.PointerConvertible): NSArray;

  managedObjectContextDidRegisterObjectsWithIDs(objectIDs: NSArray<interop.Object> | Array<interop.Object>): void;

  managedObjectContextDidUnregisterObjectsWithIDs(objectIDs: NSArray<interop.Object> | Array<interop.Object>): void;

  newObjectIDForEntityReferenceObject(entity: NSEntityDescription, data: interop.Object): NSManagedObjectID;

  referenceObjectForObjectID(objectID: NSManagedObjectID): interop.Object;
}

declare class NSPersistentHistoryChangeRequest extends NSPersistentStoreRequest {
  static fetchHistoryAfterDate<This extends abstract new (...args: any) => any>(this: This, date: NSDate): InstanceType<This>;

  static fetchHistoryAfterToken<This extends abstract new (...args: any) => any>(this: This, token: NSPersistentHistoryToken | null): InstanceType<This>;

  static fetchHistoryAfterTransaction<This extends abstract new (...args: any) => any>(this: This, transaction: NSPersistentHistoryTransaction | null): InstanceType<This>;

  static fetchHistoryWithFetchRequest<This extends abstract new (...args: any) => any>(this: This, fetchRequest: NSFetchRequest): InstanceType<This>;

  static deleteHistoryBeforeDate<This extends abstract new (...args: any) => any>(this: This, date: NSDate): InstanceType<This>;

  static deleteHistoryBeforeToken<This extends abstract new (...args: any) => any>(this: This, token: NSPersistentHistoryToken | null): InstanceType<This>;

  static deleteHistoryBeforeTransaction<This extends abstract new (...args: any) => any>(this: This, transaction: NSPersistentHistoryTransaction | null): InstanceType<This>;

  resultType: interop.Enum<typeof NSPersistentHistoryResultType>;

  readonly token: NSPersistentHistoryToken;

  fetchRequest: NSFetchRequest;
}

declare class NSBatchDeleteResult extends NSPersistentStoreResult {
  readonly result: interop.Object;

  readonly resultType: interop.Enum<typeof NSBatchDeleteRequestResultType>;
}

declare class NSLightweightMigrationStage extends NSMigrationStage {
  readonly versionChecksums: NSArray;

  initWithVersionChecksums(versionChecksums: NSArray<interop.Object> | Array<interop.Object>): this;
}

declare class NSAtomicStoreCacheNode extends NSObject {
  initWithObjectID(moid: NSManagedObjectID): this;

  readonly objectID: NSManagedObjectID;

  propertyCache: NSMutableDictionary;

  valueForKey(key: string): interop.Object;

  setValueForKey(value: interop.Object | null, key: string): void;
}

declare class NSDerivedAttributeDescription extends NSAttributeDescription {
  derivationExpression: NSExpression;
}

declare class NSPersistentHistoryTransaction extends NSObject implements NSCopying {
  static entityDescriptionWithContext(context: NSManagedObjectContext): NSEntityDescription;

  static readonly entityDescription: NSEntityDescription;

  static readonly fetchRequest: NSFetchRequest;

  readonly timestamp: NSDate;

  readonly changes: NSArray;

  readonly transactionNumber: number;

  readonly storeID: string;

  readonly bundleID: string;

  readonly processID: string;

  readonly contextName: string;

  readonly author: string;

  readonly token: NSPersistentHistoryToken;

  objectIDNotification(): NSNotification;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class NSPersistentContainer extends NSObject {
  static persistentContainerWithName<This extends abstract new (...args: any) => any>(this: This, name: string): InstanceType<This>;

  static persistentContainerWithNameManagedObjectModel<This extends abstract new (...args: any) => any>(this: This, name: string, model: NSManagedObjectModel): InstanceType<This>;

  static defaultDirectoryURL(): NSURL;

  readonly name: string;

  readonly viewContext: NSManagedObjectContext;

  readonly managedObjectModel: NSManagedObjectModel;

  readonly persistentStoreCoordinator: NSPersistentStoreCoordinator;

  get persistentStoreDescriptions(): NSArray;
  set persistentStoreDescriptions(value: NSArray<interop.Object> | Array<interop.Object>);

  initWithName(name: string): this;

  initWithNameManagedObjectModel(name: string, model: NSManagedObjectModel): this;

  loadPersistentStoresWithCompletionHandler(block: (p1: NSPersistentStoreDescription, p2: NSError) => void | null): void;

  newBackgroundContext(): NSManagedObjectContext;

  performBackgroundTask(block: (p1: NSManagedObjectContext) => void): void;
}

declare class NSBatchUpdateResult extends NSPersistentStoreResult {
  readonly result: interop.Object;

  readonly resultType: interop.Enum<typeof NSBatchUpdateRequestResultType>;
}

