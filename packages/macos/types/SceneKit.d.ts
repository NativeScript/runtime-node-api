/// <reference types="@nativescript/objc-node-api" />
/// <reference path="./Runtime.d.ts" />
/// <reference path="./AppKit.d.ts" />
/// <reference path="./QuartzCore.d.ts" />

declare const SCNLightShadowFarClippingKey: string;

declare const SCNLightShadowNearClippingKey: string;

declare const SCNLightAttenuationFalloffExponentKey: string;

declare const SCNLightAttenuationEndKey: string;

declare const SCNLightAttenuationStartKey: string;

declare const SCNPhysicsTestSearchModeClosest: string;

declare const SCNPhysicsTestSearchModeAny: string;

declare const SCNPhysicsTestBackfaceCullingKey: string;

declare const SCNPhysicsShapeTypeConvexHull: string;

declare const SCNPhysicsShapeOptionCollisionMargin: string;

declare const SCNPhysicsShapeScaleKey: string;

declare const SCNPhysicsShapeKeepAsCompoundKey: string;

declare const SCNPhysicsShapeTypeKey: string;

declare const SCNParticlePropertyCharge: string;

declare const SCNParticlePropertyFrameRate: string;

declare const SCNParticlePropertyLife: string;

declare const SCNParticlePropertyPosition: string;

declare const SCNGeometrySourceSemanticBoneIndices: string;

declare const SCNGeometrySourceSemanticBoneWeights: string;

declare const SCNGeometrySourceSemanticEdgeCrease: string;

declare const SCNGeometrySourceSemanticVertexCrease: string;

declare const SCNGeometrySourceSemanticTexcoord: string;

declare const SCNGeometrySourceSemanticVertex: string;

declare const SCNLightingModelShadowOnly: string;

declare const SCNLightingModelConstant: string;

declare const SCNLightingModelBlinn: string;

declare const SCNLightTypeProbe: string;

declare const SCNLightTypeSpot: string;

declare const SCNLightTypeOmni: string;

declare const SCNLightTypeAmbient: string;

declare const SCNModelViewProjectionTransform: string;

declare const SCNModelViewTransform: string;

declare const SCNViewTransform: string;

declare const SCNModelTransform: string;

declare const SCNSceneUpAxisAttributeKey: string;

declare const SCNSceneFrameRateAttributeKey: string;

declare const SCNSceneEndTimeAttributeKey: string;

declare const SCNSceneExportDestinationURL: string;

declare const SCNConsistencyXMLSchemaValidationError: number;

declare const SCNConsistencyMissingAttributeError: number;

declare const SCNConsistencyInvalidCountError: number;

declare const SCNConsistencyElementTypeErrorKey: string;

declare const SCNConsistencyElementIDErrorKey: string;

declare const SCNDetailedErrorsKey: string;

declare const SCNSceneSourceAnimationImportPolicyPlayUsingSceneTimeBase: string;

declare const SCNSceneSourceAnimationImportPolicyDoNotPlay: string;

declare const SCNSceneSourceAnimationImportPolicyPlayRepeatedly: string;

declare const SCNSceneSourceLoadingOptionPreserveOriginalTopology: string;

declare const SCNSceneSourceAnimationImportPolicyKey: string;

declare const SCNSceneSourceConvertToYUpKey: string;

declare const SCNSceneSourceConvertUnitsToMetersKey: string;

declare const SCNSceneSourceStrictConformanceKey: string;

declare const SCNSceneSourceCreateNormalsIfAbsentKey: string;

declare const SCNSceneSourceAssetUnitMeterKey: string;

declare const SCNSceneSourceAssetUnitNameKey: string;

declare const SCNSceneSourceAssetUnitKey: string;

declare const SCNSceneSourceAssetModifiedDateKey: string;

declare const SCNSceneSourceAssetContributorsKey: string;

declare const SCNPreferredRenderingAPIKey: string;

declare const SCNShaderModifierEntryPointGeometry: string;

declare const SCNHitTestSortResultsKey: string;

declare const SCNHitTestFirstFoundOnlyKey: string;

declare const SCNHitTestOptionSearchMode: string;

declare const SCNHitTestOptionCategoryBitMask: string;

declare const SCNHitTestIgnoreHiddenNodesKey: string;

declare const SCNHitTestRootNodeKey: string;

declare const SCNHitTestIgnoreChildNodesKey: string;

declare const SCNHitTestClipToZRangeKey: string;

declare const SCNErrorDomain: string;

declare const SCNMatrix4Identity: CATransform3D;

declare const SCNHitTestOptionIgnoreLightArea: string;

declare const SCNLightingModelLambert: string;

declare const SCNLightingModelPhysicallyBased: string;

declare const SCNSceneSourceAssetAuthorKey: string;

declare const SCNPhysicsTestSearchModeAll: string;

declare const SCNShaderModifierEntryPointFragment: string;

declare const SCNPreferredDeviceKey: string;

declare const SCNLightSpotInnerAngleKey: string;

declare const SCNSceneSourceAnimationImportPolicyPlay: string;

declare const SCNParticlePropertyAngularVelocity: string;

declare const SCNSceneSourceAssetCreatedDateKey: string;

declare const SCNNormalTransform: string;

declare const SCNHitTestBoundingBoxOnlyKey: string;

declare const SCNParticlePropertyVelocity: string;

declare const SCNConsistencyMissingElementError: number;

declare const SCNConsistencyInvalidArgumentError: number;

declare const SCNProgramCompilationError: number;

declare const SCNGeometrySourceSemanticTangent: string;

declare const SCNPhysicsTestSearchModeKey: string;

declare const SCNSceneSourceCheckConsistencyKey: string;

declare const SCNVector3Zero: SCNVector3;

declare const SCNConsistencyInvalidURIError: number;

declare const SCNParticlePropertyContactPoint: string;

declare const SCNParticlePropertyAngle: string;

declare const SCNShaderModifierEntryPointLightingModel: string;

declare const SCNPreferLowPowerDeviceKey: string;

declare const SCNSceneSourceOverrideAssetURLsKey: string;

declare const SCNVector4Zero: SCNVector4;

declare const SCNShaderModifierEntryPointSurface: string;

declare const SCNSceneSourceAssetDirectoryURLsKey: string;

declare const SCNGeometrySourceSemanticNormal: string;

declare const SCNPhysicsShapeTypeConcavePolyhedron: string;

declare const SCNSceneSourceAssetAuthoringToolKey: string;

declare const SCNSceneSourceUseSafeModeKey: string;

declare const SCNParticlePropertyRotationAxis: string;

declare const SCNLightingModelPhong: string;

declare const SCNPhysicsShapeTypeBoundingBox: string;

declare const SCNParticlePropertyFriction: string;

declare const SCNConsistencyLineNumberErrorKey: string;

declare const SCNParticlePropertyOpacity: string;

declare const SCNParticlePropertyContactNormal: string;

declare const SCNProjectionTransform: string;

declare const SCNHitTestBackFaceCullingKey: string;

declare const SCNLightTypeDirectional: string;

declare const SCNLightTypeArea: string;

declare const SCNProgramMappingChannelKey: string;

declare const SCNPhysicsTestCollisionBitMaskKey: string;

declare const SCNParticlePropertyFrame: string;

declare const SCNGeometrySourceSemanticColor: string;

declare const SCNSceneStartTimeAttributeKey: string;

declare const SCNParticlePropertySize: string;

declare const SCNLightSpotOuterAngleKey: string;

declare const SCNParticlePropertyBounce: string;

declare const SCNLightTypeIES: string;

declare const SCNParticlePropertyColor: string;

declare const SCNSceneSourceAssetUpAxisKey: string;

declare const SCNSceneSourceFlattenSceneKey: string;

declare const SCNInteractionMode: {
  Fly: 0,
  OrbitTurntable: 1,
  OrbitAngleMapping: 2,
  OrbitCenteredArcball: 3,
  OrbitArcball: 4,
  Pan: 5,
  Truck: 6,
};

declare const SCNReferenceLoadingPolicy: {
  Immediate: 0,
  OnDemand: 1,
};

declare const SCNPhysicsFieldScope: {
  Inside: 0,
  Outside: 1,
};

declare const SCNParticleInputMode: {
  Life: 0,
  Distance: 1,
  OtherProperty: 2,
};

declare const SCNParticleBirthLocation: {
  Surface: 0,
  Volume: 1,
  Vertex: 2,
};

declare const SCNParticleBlendMode: {
  Additive: 0,
  Subtract: 1,
  Multiply: 2,
  Screen: 3,
  Alpha: 4,
  Replace: 5,
};

declare const SCNBillboardAxis: {
  X: 1,
  Y: 2,
  Z: 4,
  All: 7,
};

declare const SCNGeometryPrimitiveType: {
  Triangles: 0,
  TriangleStrip: 1,
  Line: 2,
  Point: 3,
  Polygon: 4,
};

declare const SCNTransparencyMode: {
  AOne: 0,
  RGBZero: 1,
  SingleLayer: 2,
  DualLayer: 3,
  Default: 0,
};

declare const SCNCullMode: {
  Back: 0,
  Front: 1,
};

declare const SCNFillMode: {
  Fill: 0,
  Lines: 1,
};

declare const SCNLightAreaType: {
  Rectangle: 1,
  Polygon: 4,
};

declare const SCNLightProbeUpdateType: {
  Never: 0,
  Realtime: 1,
};

declare const SCNLightProbeType: {
  Irradiance: 0,
  Radiance: 1,
};

declare const SCNMovabilityHint: {
  Fixed: 0,
  Movable: 1,
};

declare const SCNSceneSourceStatus: {
  Error: -1,
  Parsing: 4,
  Validating: 8,
  Processing: 12,
  Complete: 16,
};

declare const SCNBufferFrequency: {
  Frame: 0,
  Node: 1,
  Shadable: 2,
};

declare const SCNRenderingAPI: {
  Metal: 0,
  OpenGLLegacy: 1,
  OpenGLCore32: 2,
  OpenGLCore41: 3,
};

declare const SCNAntialiasingMode: {
  None: 0,
  Multisampling2X: 1,
  Multisampling4X: 2,
  Multisampling8X: 3,
  Multisampling16X: 4,
};

declare const SCNColorMask: {
  None: 0,
  Red: 8,
  Green: 4,
  Blue: 2,
  Alpha: 1,
  All: 15,
};

declare const SCNParticleOrientationMode: {
  BillboardScreenAligned: 0,
  BillboardViewAligned: 1,
  Free: 2,
  BillboardYAligned: 3,
};

declare const SCNParticleModifierStage: {
  PreDynamics: 0,
  PostDynamics: 1,
  PreCollision: 2,
  PostCollision: 3,
};

declare const SCNCameraProjectionDirection: {
  Vertical: 0,
  Horizontal: 1,
};

declare const SCNBlendMode: {
  Alpha: 0,
  Add: 1,
  Subtract: 2,
  Multiply: 3,
  Screen: 4,
  Replace: 5,
  Max: 6,
};

declare const SCNFilterMode: {
  None: 0,
  Nearest: 1,
  Linear: 2,
};

declare const SCNDebugOptions: {
  None: 0,
  ShowPhysicsShapes: 1,
  ShowBoundingBoxes: 2,
  ShowLightInfluences: 4,
  ShowLightExtents: 8,
  ShowPhysicsFields: 16,
  ShowWireframe: 32,
  RenderAsWireframe: 64,
  ShowSkeletons: 128,
  ShowCreases: 256,
  ShowConstraints: 512,
  ShowCameras: 1024,
};

declare const SCNParticleBirthDirection: {
  Constant: 0,
  SurfaceNormal: 1,
  Random: 2,
};

declare const SCNActionTimingMode: {
  Linear: 0,
  EaseIn: 1,
  EaseOut: 2,
  EaseInEaseOut: 3,
};

declare const SCNMorpherCalculationMode: {
  Normalized: 0,
  Additive: 1,
};

declare const SCNParticleSortingMode: {
  None: 0,
  ProjectedDepth: 1,
  Distance: 2,
  OldestFirst: 3,
  YoungestFirst: 4,
};

declare const SCNShadowMode: {
  Forward: 0,
  Deferred: 1,
  Modulated: 2,
};

declare const SCNWrapMode: {
  Clamp: 1,
  Repeat: 2,
  ClampToBorder: 3,
  Mirror: 4,
};

declare const SCNHitTestSearchMode: {
  Closest: 0,
  All: 1,
  Any: 2,
};

declare const SCNPhysicsBodyType: {
  Static: 0,
  Dynamic: 1,
  Kinematic: 2,
};

declare const SCNParticleEvent: {
  Birth: 0,
  Death: 1,
  Collision: 2,
};

declare const SCNChamferMode: {
  Both: 0,
  Front: 1,
  Back: 2,
};

declare const SCNNodeFocusBehavior: {
  None: 0,
  Occluding: 1,
  Focusable: 2,
};

declare const SCNTessellationSmoothingMode: {
  None: 0,
  PNTriangles: 1,
  Phong: 2,
};

declare const SCNParticleImageSequenceAnimationMode: {
  Repeat: 0,
  Clamp: 1,
  AutoReverse: 2,
};

declare const SCNPhysicsCollisionCategory: {
  Default: 1,
  Static: 2,
  All: -1,
};

declare class SCNVector3 {
  constructor(init?: SCNVector3);
  x: number;
  y: number;
  z: number;
}

declare class SCNVector4 {
  constructor(init?: SCNVector4);
  x: number;
  y: number;
  z: number;
  w: number;
}

declare function SCNVector3EqualToVector3(a: SCNVector3, b: SCNVector3): boolean;

declare function SCNVector4EqualToVector4(a: SCNVector4, b: SCNVector4): boolean;

declare function SCNMatrix4IsIdentity(m: CATransform3D): boolean;

declare function SCNMatrix4EqualToMatrix4(a: CATransform3D, b: CATransform3D): boolean;

declare function SCNMatrix4MakeRotation(angle: number, x: number, y: number, z: number): CATransform3D;

declare function SCNMatrix4Scale(m: CATransform3D, sx: number, sy: number, sz: number): CATransform3D;

declare function SCNMatrix4Rotate(m: CATransform3D, angle: number, x: number, y: number, z: number): CATransform3D;

declare function SCNMatrix4Invert(m: CATransform3D): CATransform3D;

declare function SCNMatrix4Mult(a: CATransform3D, b: CATransform3D): CATransform3D;

declare function SCNMatrix4ToGLKMatrix4(mat: CATransform3D): _GLKMatrix4;

declare function SCNMatrix4FromGLKMatrix4(mat: _GLKMatrix4): CATransform3D;

declare function SCNExportJavaScriptModule(context: JSContext): void;

declare interface SCNAnimationProtocol extends NSObjectProtocol {
}

declare class SCNAnimationProtocol extends NativeObject implements SCNAnimationProtocol {
}

declare interface SCNCameraControllerDelegate extends NSObjectProtocol {
  cameraInertiaWillStartForController?(cameraController: SCNCameraController): void;

  cameraInertiaDidEndForController?(cameraController: SCNCameraController): void;
}

declare class SCNCameraControllerDelegate extends NativeObject implements SCNCameraControllerDelegate {
}

declare interface SCNCameraControlConfiguration extends NSObjectProtocol {
  autoSwitchToFreeCamera: boolean;

  allowsTranslation: boolean;

  flyModeVelocity: number;

  panSensitivity: number;

  truckSensitivity: number;

  rotationSensitivity: number;
}

declare class SCNCameraControlConfiguration extends NativeObject implements SCNCameraControlConfiguration {
}

declare interface SCNProgramDelegate extends NSObjectProtocol {
  programBindValueForSymbolAtLocationProgramIDRenderer?(program: SCNProgram, symbol: string, location: number, programID: number, renderer: SCNRenderer): boolean;

  programUnbindValueForSymbolAtLocationProgramIDRenderer?(program: SCNProgram, symbol: string, location: number, programID: number, renderer: SCNRenderer): void;

  programHandleError?(program: SCNProgram, error: NSError): void;

  programIsOpaque?(program: SCNProgram): boolean;
}

declare class SCNProgramDelegate extends NativeObject implements SCNProgramDelegate {
}

declare interface SCNTechniqueSupport extends NSObjectProtocol {
  technique: SCNTechnique;
}

declare class SCNTechniqueSupport extends NativeObject implements SCNTechniqueSupport {
}

declare interface SCNShadable extends NSObjectProtocol {
  program?: SCNProgram;

  handleBindingOfSymbolUsingBlock?(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  handleUnbindingOfSymbolUsingBlock?(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  get shaderModifiers(): NSDictionary | undefined;
  set shaderModifiers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | undefined);

  minimumLanguageVersion?: NSNumber;
}

declare class SCNShadable extends NativeObject implements SCNShadable {
}

declare interface SCNBufferStream extends NSObjectProtocol {
  writeBytesLength(bytes: interop.PointerConvertible, length: number): void;
}

declare class SCNBufferStream extends NativeObject implements SCNBufferStream {
}

declare interface SCNSceneRenderer extends NSObjectProtocol {
  scene: SCNScene;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  isPlaying: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  isJitteringEnabled: boolean;

  isTemporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;
}

declare class SCNSceneRenderer extends NativeObject implements SCNSceneRenderer {
}

declare interface SCNSceneExportDelegate extends NSObjectProtocol {
  writeImageWithSceneDocumentURLOriginalImageURL?(image: NSImage, documentURL: NSURL, originalImageURL: NSURL | null): NSURL;
}

declare class SCNSceneExportDelegate extends NativeObject implements SCNSceneExportDelegate {
}

declare interface SCNAnimatable extends NSObjectProtocol {
  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;
}

declare class SCNAnimatable extends NativeObject implements SCNAnimatable {
}

declare interface SCNNodeRendererDelegate extends NSObjectProtocol {
  renderNodeRendererArguments?(node: SCNNode, renderer: SCNRenderer, arguments$: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): void;
}

declare class SCNNodeRendererDelegate extends NativeObject implements SCNNodeRendererDelegate {
}

declare interface SCNPhysicsContactDelegate extends NSObjectProtocol {
  physicsWorldDidBeginContact?(world: SCNPhysicsWorld, contact: SCNPhysicsContact): void;

  physicsWorldDidUpdateContact?(world: SCNPhysicsWorld, contact: SCNPhysicsContact): void;

  physicsWorldDidEndContact?(world: SCNPhysicsWorld, contact: SCNPhysicsContact): void;
}

declare class SCNPhysicsContactDelegate extends NativeObject implements SCNPhysicsContactDelegate {
}

declare interface SCNBoundingVolume extends NSObjectProtocol {
  getBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): boolean;

  setBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): void;

  getBoundingSphereCenterRadius(center: interop.PointerConvertible, radius: interop.PointerConvertible): boolean;
}

declare class SCNBoundingVolume extends NativeObject implements SCNBoundingVolume {
}

declare interface SCNActionable extends NSObjectProtocol {
  runAction(action: SCNAction): void;

  runActionCompletionHandler(action: SCNAction, block: () => void | null): void;

  runActionForKey(action: SCNAction, key: string | null): void;

  runActionForKeyCompletionHandler(action: SCNAction, key: string | null, block: () => void | null): void;

  readonly hasActions: boolean;

  actionForKey(key: string): SCNAction;

  removeActionForKey(key: string): void;

  removeAllActions(): void;

  readonly actionKeys: NSArray;
}

declare class SCNActionable extends NativeObject implements SCNActionable {
}

declare interface SCNAvoidOccluderConstraintDelegate extends NSObjectProtocol {
  avoidOccluderConstraintShouldAvoidOccluderForNode?(constraint: SCNAvoidOccluderConstraint, occluder: SCNNode, node: SCNNode): boolean;

  avoidOccluderConstraintDidAvoidOccluderForNode?(constraint: SCNAvoidOccluderConstraint, occluder: SCNNode, node: SCNNode): void;
}

declare class SCNAvoidOccluderConstraintDelegate extends NativeObject implements SCNAvoidOccluderConstraintDelegate {
}

declare interface SCNSceneRendererDelegate extends NSObjectProtocol {
  rendererUpdateAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererDidApplyAnimationsAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererDidSimulatePhysicsAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererDidApplyConstraintsAtTime?(renderer: SCNSceneRenderer, time: number): void;

  rendererWillRenderSceneAtTime?(renderer: SCNSceneRenderer, scene: SCNScene, time: number): void;

  rendererDidRenderSceneAtTime?(renderer: SCNSceneRenderer, scene: SCNScene, time: number): void;
}

declare class SCNSceneRendererDelegate extends NativeObject implements SCNSceneRendererDelegate {
}

declare class SCNPhysicsBallSocketJoint extends SCNPhysicsBehavior {
  static jointWithBodyAAnchorABodyBAnchorB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, anchorA: SCNVector3, bodyB: SCNPhysicsBody, anchorB: SCNVector3): InstanceType<This>;

  static jointWithBodyAnchor<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, anchor: SCNVector3): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  anchorA: SCNVector3;

  readonly bodyB: SCNPhysicsBody;

  anchorB: SCNVector3;
}

declare class SCNPhysicsHingeJoint extends SCNPhysicsBehavior {
  static jointWithBodyAAxisAAnchorABodyBAxisBAnchorB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3): InstanceType<This>;

  static jointWithBodyAxisAnchor<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  axisA: SCNVector3;

  anchorA: SCNVector3;

  readonly bodyB: SCNPhysicsBody;

  axisB: SCNVector3;

  anchorB: SCNVector3;
}

declare class SCNPhysicsWorld extends NSObject implements NSSecureCoding {
  gravity: SCNVector3;

  speed: number;

  timeStep: number;

  contactDelegate: SCNPhysicsContactDelegate;

  addBehavior(behavior: SCNPhysicsBehavior): void;

  removeBehavior(behavior: SCNPhysicsBehavior): void;

  removeAllBehaviors(): void;

  readonly allBehaviors: NSArray;

  rayTestWithSegmentFromPointToPointOptions(origin: SCNVector3, dest: SCNVector3, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  contactTestBetweenBodyAndBodyOptions(bodyA: SCNPhysicsBody, bodyB: SCNPhysicsBody, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  contactTestWithBodyOptions(body: SCNPhysicsBody, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  convexSweepTestWithShapeFromTransformToTransformOptions(shape: SCNPhysicsShape, from: CATransform3D, to: CATransform3D, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  updateCollisionPairs(): void;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNPhysicsShape extends NSObject implements NSCopying, NSSecureCoding {
  static shapeWithGeometryOptions<This extends abstract new (...args: any) => any>(this: This, geometry: SCNGeometry, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static shapeWithNodeOptions<This extends abstract new (...args: any) => any>(this: This, node: SCNNode, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static shapeWithShapesTransforms<This extends abstract new (...args: any) => any>(this: This, shapes: NSArray<interop.Object> | Array<interop.Object>, transforms: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  readonly options: NSDictionary;

  readonly sourceObject: interop.Object;

  readonly transforms: NSArray;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNPhysicsField extends NSObject implements NSCopying, NSSecureCoding {
  strength: number;

  falloffExponent: number;

  minimumDistance: number;

  isActive: boolean;

  isExclusive: boolean;

  halfExtent: SCNVector3;

  usesEllipsoidalExtent: boolean;

  scope: interop.Enum<typeof SCNPhysicsFieldScope>;

  offset: SCNVector3;

  direction: SCNVector3;

  categoryBitMask: number;

  static dragField(): SCNPhysicsField;

  static vortexField(): SCNPhysicsField;

  static radialGravityField(): SCNPhysicsField;

  static linearGravityField(): SCNPhysicsField;

  static noiseFieldWithSmoothnessAnimationSpeed(smoothness: number, speed: number): SCNPhysicsField;

  static turbulenceFieldWithSmoothnessAnimationSpeed(smoothness: number, speed: number): SCNPhysicsField;

  static springField(): SCNPhysicsField;

  static electricField(): SCNPhysicsField;

  static magneticField(): SCNPhysicsField;

  static customFieldWithEvaluationBlock(block: (p1: SCNVector3, p2: SCNVector3, p3: number, p4: number, p5: number) => SCNVector3): SCNPhysicsField;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNParticlePropertyController extends NSObject implements NSSecureCoding, NSCopying {
  static controllerWithAnimation<This extends abstract new (...args: any) => any>(this: This, animation: CAAnimation): InstanceType<This>;

  animation: CAAnimation;

  inputMode: interop.Enum<typeof SCNParticleInputMode>;

  inputScale: number;

  inputBias: number;

  inputOrigin: SCNNode;

  inputProperty: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;
}

declare class SCNLevelOfDetail extends NSObject implements NSCopying, NSSecureCoding {
  static levelOfDetailWithGeometryScreenSpaceRadius<This extends abstract new (...args: any) => any>(this: This, geometry: SCNGeometry | null, radius: number): InstanceType<This>;

  static levelOfDetailWithGeometryWorldSpaceDistance<This extends abstract new (...args: any) => any>(this: This, geometry: SCNGeometry | null, distance: number): InstanceType<This>;

  readonly geometry: SCNGeometry;

  readonly screenSpaceRadius: number;

  readonly worldSpaceDistance: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNDistanceConstraint extends SCNConstraint {
  static distanceConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  target: SCNNode;

  minimumDistance: number;

  maximumDistance: number;
}

declare class SCNBillboardConstraint extends SCNConstraint {
  static billboardConstraint<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  freeAxes: interop.Enum<typeof SCNBillboardAxis>;
}

declare class SCNLookAtConstraint extends SCNConstraint {
  static lookAtConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  target: SCNNode;

  targetOffset: SCNVector3;

  localFront: SCNVector3;

  worldUp: SCNVector3;

  gimbalLockEnabled: boolean;
}

declare class SCNConstraint extends NSObject implements NSCopying, NSSecureCoding, SCNAnimatable {
  isEnabled: boolean;

  influenceFactor: number;

  isIncremental: boolean;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class SCNSkinner extends NSObject implements NSSecureCoding {
  skeleton: SCNNode;

  static skinnerWithBaseGeometryBonesBoneInverseBindTransformsBoneWeightsBoneIndices<This extends abstract new (...args: any) => any>(this: This, baseGeometry: SCNGeometry | null, bones: NSArray<interop.Object> | Array<interop.Object>, boneInverseBindTransforms: NSArray<interop.Object> | Array<interop.Object> | null, boneWeights: SCNGeometrySource, boneIndices: SCNGeometrySource): InstanceType<This>;

  baseGeometry: SCNGeometry;

  baseGeometryBindTransform: CATransform3D;

  readonly boneInverseBindTransforms: NSArray;

  readonly bones: NSArray;

  readonly boneWeights: SCNGeometrySource;

  readonly boneIndices: SCNGeometrySource;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNShape extends SCNGeometry {
  static shapeWithPathExtrusionDepth<This extends abstract new (...args: any) => any>(this: This, path: NSBezierPath | null, extrusionDepth: number): InstanceType<This>;

  path: NSBezierPath;

  extrusionDepth: number;

  chamferMode: interop.Enum<typeof SCNChamferMode>;

  chamferRadius: number;

  chamferProfile: NSBezierPath;
}

declare class SCNText extends SCNGeometry {
  static textWithStringExtrusionDepth<This extends abstract new (...args: any) => any>(this: This, string: interop.Object | null, extrusionDepth: number): InstanceType<This>;

  extrusionDepth: number;

  string: interop.Object;

  font: NSFont;

  isWrapped: boolean;

  containerFrame: CGRect;

  readonly textSize: CGSize;

  truncationMode: string;

  alignmentMode: string;

  chamferRadius: number;

  chamferSegmentCount: number;

  chamferProfile: NSBezierPath;

  flatness: number;
}

declare class SCNTube extends SCNGeometry {
  static tubeWithInnerRadiusOuterRadiusHeight<This extends abstract new (...args: any) => any>(this: This, innerRadius: number, outerRadius: number, height: number): InstanceType<This>;

  innerRadius: number;

  outerRadius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;
}

declare class SCNCone extends SCNGeometry {
  static coneWithTopRadiusBottomRadiusHeight<This extends abstract new (...args: any) => any>(this: This, topRadius: number, bottomRadius: number, height: number): InstanceType<This>;

  topRadius: number;

  bottomRadius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;
}

declare class SCNBox extends SCNGeometry {
  static boxWithWidthHeightLengthChamferRadius<This extends abstract new (...args: any) => any>(this: This, width: number, height: number, length: number, chamferRadius: number): InstanceType<This>;

  width: number;

  height: number;

  length: number;

  chamferRadius: number;

  widthSegmentCount: number;

  heightSegmentCount: number;

  lengthSegmentCount: number;

  chamferSegmentCount: number;
}

declare class SCNPlane extends SCNGeometry {
  static planeWithWidthHeight<This extends abstract new (...args: any) => any>(this: This, width: number, height: number): InstanceType<This>;

  width: number;

  height: number;

  widthSegmentCount: number;

  heightSegmentCount: number;

  cornerRadius: number;

  cornerSegmentCount: number;
}

declare class SCNGeometrySource extends NSObject implements NSSecureCoding {
  static geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride<This extends abstract new (...args: any) => any>(this: This, data: NSData, semantic: string, vectorCount: number, floatComponents: boolean, componentsPerVector: number, bytesPerComponent: number, offset: number, stride: number): InstanceType<This>;

  static geometrySourceWithVerticesCount<This extends abstract new (...args: any) => any>(this: This, vertices: interop.PointerConvertible, count: number): InstanceType<This>;

  static geometrySourceWithNormalsCount<This extends abstract new (...args: any) => any>(this: This, normals: interop.PointerConvertible, count: number): InstanceType<This>;

  static geometrySourceWithTextureCoordinatesCount<This extends abstract new (...args: any) => any>(this: This, texcoord: interop.PointerConvertible, count: number): InstanceType<This>;

  static geometrySourceWithBufferVertexFormatSemanticVertexCountDataOffsetDataStride<This extends abstract new (...args: any) => any>(this: This, buffer: MTLBuffer, vertexFormat: interop.Enum<typeof MTLVertexFormat>, semantic: string, vertexCount: number, offset: number, stride: number): InstanceType<This>;

  readonly data: NSData;

  readonly semantic: string;

  readonly vectorCount: number;

  readonly floatComponents: boolean;

  readonly componentsPerVector: number;

  readonly bytesPerComponent: number;

  readonly dataOffset: number;

  readonly dataStride: number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNMaterial extends NSObject implements SCNAnimatable, SCNShadable, NSCopying, NSSecureCoding {
  static material<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  name: string;

  readonly diffuse: SCNMaterialProperty;

  readonly ambient: SCNMaterialProperty;

  readonly specular: SCNMaterialProperty;

  readonly emission: SCNMaterialProperty;

  readonly transparent: SCNMaterialProperty;

  readonly reflective: SCNMaterialProperty;

  readonly multiply: SCNMaterialProperty;

  readonly normal: SCNMaterialProperty;

  readonly displacement: SCNMaterialProperty;

  readonly ambientOcclusion: SCNMaterialProperty;

  readonly selfIllumination: SCNMaterialProperty;

  readonly metalness: SCNMaterialProperty;

  readonly roughness: SCNMaterialProperty;

  readonly clearCoat: SCNMaterialProperty;

  readonly clearCoatRoughness: SCNMaterialProperty;

  readonly clearCoatNormal: SCNMaterialProperty;

  shininess: number;

  transparency: number;

  lightingModelName: string;

  isLitPerPixel: boolean;

  isDoubleSided: boolean;

  fillMode: interop.Enum<typeof SCNFillMode>;

  cullMode: interop.Enum<typeof SCNCullMode>;

  transparencyMode: interop.Enum<typeof SCNTransparencyMode>;

  locksAmbientWithDiffuse: boolean;

  writesToDepthBuffer: boolean;

  colorBufferWriteMask: interop.Enum<typeof SCNColorMask>;

  readsFromDepthBuffer: boolean;

  fresnelExponent: number;

  blendMode: interop.Enum<typeof SCNBlendMode>;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  program: SCNProgram;

  handleBindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  handleUnbindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  get shaderModifiers(): NSDictionary;
  set shaderModifiers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  minimumLanguageVersion: NSNumber;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNNode extends NSObject implements NSCopying, NSSecureCoding, SCNAnimatable, SCNActionable, SCNBoundingVolume {
  static node<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static nodeWithGeometry(geometry: SCNGeometry | null): SCNNode;

  clone(): this;

  flattenedClone(): this;

  name: string;

  light: SCNLight;

  camera: SCNCamera;

  geometry: SCNGeometry;

  skinner: SCNSkinner;

  morpher: SCNMorpher;

  transform: CATransform3D;

  readonly worldTransform: CATransform3D;

  position: SCNVector3;

  worldPosition: SCNVector3;

  rotation: SCNVector4;

  orientation: SCNVector4;

  worldOrientation: SCNVector4;

  eulerAngles: SCNVector3;

  scale: SCNVector3;

  pivot: CATransform3D;

  isHidden: boolean;

  opacity: number;

  renderingOrder: number;

  castsShadow: boolean;

  movabilityHint: interop.Enum<typeof SCNMovabilityHint>;

  readonly parentNode: SCNNode;

  readonly childNodes: NSArray;

  addChildNode(child: SCNNode): void;

  insertChildNodeAtIndex(child: SCNNode, index: number): void;

  removeFromParentNode(): void;

  replaceChildNodeWith(oldChild: SCNNode, newChild: SCNNode): void;

  childNodeWithNameRecursively(name: string, recursively: boolean): SCNNode;

  childNodesPassingTest(predicate: (p1: SCNNode, p2: interop.PointerConvertible) => boolean): NSArray;

  enumerateChildNodesUsingBlock(block: (p1: SCNNode, p2: interop.PointerConvertible) => void): void;

  enumerateHierarchyUsingBlock(block: (p1: SCNNode, p2: interop.PointerConvertible) => void): void;

  convertPositionToNode(position: SCNVector3, node: SCNNode | null): SCNVector3;

  convertPositionFromNode(position: SCNVector3, node: SCNNode | null): SCNVector3;

  convertVectorToNode(vector: SCNVector3, node: SCNNode | null): SCNVector3;

  convertVectorFromNode(vector: SCNVector3, node: SCNNode | null): SCNVector3;

  convertTransformToNode(transform: CATransform3D, node: SCNNode | null): CATransform3D;

  convertTransformFromNode(transform: CATransform3D, node: SCNNode | null): CATransform3D;

  physicsBody: SCNPhysicsBody;

  physicsField: SCNPhysicsField;

  get constraints(): NSArray;
  set constraints(value: NSArray<interop.Object> | Array<interop.Object>);

  get filters(): NSArray;
  set filters(value: NSArray<interop.Object> | Array<interop.Object>);

  readonly presentationNode: SCNNode;

  isPaused: boolean;

  rendererDelegate: SCNNodeRendererDelegate;

  hitTestWithSegmentFromPointToPointOptions(pointA: SCNVector3, pointB: SCNVector3, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  categoryBitMask: number;

  focusBehavior: interop.Enum<typeof SCNNodeFocusBehavior>;

  static readonly localUp: SCNVector3;

  static readonly localRight: SCNVector3;

  static readonly localFront: SCNVector3;

  readonly worldUp: SCNVector3;

  readonly worldRight: SCNVector3;

  readonly worldFront: SCNVector3;

  lookAt(worldTarget: SCNVector3): void;

  lookAtUpLocalFront(worldTarget: SCNVector3, worldUp: SCNVector3, localFront: SCNVector3): void;

  localTranslateBy(translation: SCNVector3): void;

  localRotateBy(rotation: SCNVector4): void;

  rotateByAroundTarget(worldRotation: SCNVector4, worldTarget: SCNVector3): void;

  simdTransform: simd_float4x4;

  simdPosition: unknown /* ext vector */;

  simdRotation: unknown /* ext vector */;

  simdOrientation: simd_quatf;

  simdEulerAngles: unknown /* ext vector */;

  simdScale: unknown /* ext vector */;

  simdPivot: simd_float4x4;

  simdWorldPosition: unknown /* ext vector */;

  simdWorldOrientation: simd_quatf;

  simdWorldTransform: simd_float4x4;

  simdConvertPositionToNode(position: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertPositionFromNode(position: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertVectorToNode(vector: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertVectorFromNode(vector: unknown /* ext vector */, node: SCNNode | null): unknown /* ext vector */;

  simdConvertTransformToNode(transform: simd_float4x4, node: SCNNode | null): simd_float4x4;

  simdConvertTransformFromNode(transform: simd_float4x4, node: SCNNode | null): simd_float4x4;

  static readonly simdLocalUp: unknown /* ext vector */;

  static readonly simdLocalRight: unknown /* ext vector */;

  static readonly simdLocalFront: unknown /* ext vector */;

  readonly simdWorldUp: unknown /* ext vector */;

  readonly simdWorldRight: unknown /* ext vector */;

  readonly simdWorldFront: unknown /* ext vector */;

  simdLookAt(worldTarget: unknown /* ext vector */): void;

  simdLookAtUpLocalFront(worldTarget: unknown /* ext vector */, worldUp: unknown /* ext vector */, localFront: unknown /* ext vector */): void;

  simdLocalTranslateBy(translation: unknown /* ext vector */): void;

  simdLocalRotateBy(rotation: simd_quatf): void;

  simdRotateByAroundTarget(worldRotation: simd_quatf, worldTarget: unknown /* ext vector */): void;

  addParticleSystem(system: SCNParticleSystem): void;

  removeAllParticleSystems(): void;

  removeParticleSystem(system: SCNParticleSystem): void;

  readonly particleSystems: NSArray;

  addAudioPlayer(player: SCNAudioPlayer): void;

  removeAllAudioPlayers(): void;

  removeAudioPlayer(player: SCNAudioPlayer): void;

  readonly audioPlayers: NSArray;

  entity: GKEntity;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  runAction(action: SCNAction): void;

  runActionCompletionHandler(action: SCNAction, block: () => void | null): void;

  runActionForKey(action: SCNAction, key: string | null): void;

  runActionForKeyCompletionHandler(action: SCNAction, key: string | null, block: () => void | null): void;

  readonly hasActions: boolean;

  actionForKey(key: string): SCNAction;

  removeActionForKey(key: string): void;

  removeAllActions(): void;

  readonly actionKeys: NSArray;

  getBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): boolean;

  setBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): void;

  getBoundingSphereCenterRadius(center: interop.PointerConvertible, radius: interop.PointerConvertible): boolean;
}

declare class SCNAction extends NSObject implements NSCopying, NSSecureCoding {
  duration: number;

  timingMode: interop.Enum<typeof SCNActionTimingMode>;

  timingFunction: (p1: number) => number;

  speed: number;

  reversedAction(): SCNAction;

  static moveByXYZDuration(deltaX: number, deltaY: number, deltaZ: number, duration: number): SCNAction;

  static moveByDuration(delta: SCNVector3, duration: number): SCNAction;

  static moveToDuration(location: SCNVector3, duration: number): SCNAction;

  static rotateByXYZDuration(xAngle: number, yAngle: number, zAngle: number, duration: number): SCNAction;

  static rotateToXYZDuration(xAngle: number, yAngle: number, zAngle: number, duration: number): SCNAction;

  static rotateToXYZDurationShortestUnitArc(xAngle: number, yAngle: number, zAngle: number, duration: number, shortestUnitArc: boolean): SCNAction;

  static rotateByAngleAroundAxisDuration(angle: number, axis: SCNVector3, duration: number): SCNAction;

  static rotateToAxisAngleDuration(axisAngle: SCNVector4, duration: number): SCNAction;

  static scaleByDuration(scale: number, sec: number): SCNAction;

  static scaleToDuration(scale: number, sec: number): SCNAction;

  static sequence(actions: NSArray<interop.Object> | Array<interop.Object>): SCNAction;

  static group(actions: NSArray<interop.Object> | Array<interop.Object>): SCNAction;

  static repeatActionCount(action: SCNAction, count: number): SCNAction;

  static repeatActionForever(action: SCNAction): SCNAction;

  static fadeInWithDuration(sec: number): SCNAction;

  static fadeOutWithDuration(sec: number): SCNAction;

  static fadeOpacityByDuration(factor: number, sec: number): SCNAction;

  static fadeOpacityToDuration(opacity: number, sec: number): SCNAction;

  static hide(): SCNAction;

  static unhide(): SCNAction;

  static waitForDuration(sec: number): SCNAction;

  static waitForDurationWithRange(sec: number, durationRange: number): SCNAction;

  static removeFromParentNode(): SCNAction;

  static runBlock(block: (p1: SCNNode) => void): SCNAction;

  static runBlockQueue(block: (p1: SCNNode) => void, queue: NSObject): SCNAction;

  static javaScriptActionWithScriptDuration(script: string, seconds: number): SCNAction;

  static customActionWithDurationActionBlock(seconds: number, block: (p1: SCNNode, p2: number) => void): SCNAction;

  static playAudioSourceWaitForCompletion(source: SCNAudioSource, wait: boolean): SCNAction;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNScene extends NSObject implements NSSecureCoding {
  static scene<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  readonly rootNode: SCNNode;

  readonly physicsWorld: SCNPhysicsWorld;

  attributeForKey(key: string): interop.Object;

  setAttributeForKey(attribute: interop.Object | null, key: string): void;

  readonly background: SCNMaterialProperty;

  readonly lightingEnvironment: SCNMaterialProperty;

  static sceneNamed<This extends abstract new (...args: any) => any>(this: This, name: string): InstanceType<This>;

  static sceneNamedInDirectoryOptions<This extends abstract new (...args: any) => any>(this: This, name: string, directory: string | null, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static sceneWithURLOptionsError<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): InstanceType<This>;

  writeToURLOptionsDelegateProgressHandler(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, delegate: SCNSceneExportDelegate | null, progressHandler: (p1: number, p2: NSError, p3: interop.PointerConvertible) => void | null): boolean;

  fogStartDistance: number;

  fogEndDistance: number;

  fogDensityExponent: number;

  fogColor: interop.Object;

  wantsScreenSpaceReflection: boolean;

  screenSpaceReflectionSampleCount: number;

  screenSpaceReflectionMaximumDistance: number;

  screenSpaceReflectionStride: number;

  isPaused: boolean;

  addParticleSystemWithTransform(system: SCNParticleSystem, transform: CATransform3D): void;

  removeAllParticleSystems(): void;

  removeParticleSystem(system: SCNParticleSystem): void;

  readonly particleSystems: NSArray;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNAnimationPlayer extends NSObject implements SCNAnimatable, NSCopying, NSSecureCoding {
  static animationPlayerWithAnimation(animation: SCNAnimation): SCNAnimationPlayer;

  readonly animation: SCNAnimation;

  speed: number;

  blendFactor: number;

  paused: boolean;

  play(): void;

  stop(): void;

  stopWithBlendOutDuration(duration: number): void;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNAnimation extends NSObject implements SCNAnimationProtocol, NSCopying, NSSecureCoding {
  static animationWithContentsOfURL(animationUrl: NSURL): SCNAnimation;

  static animationNamed(animationName: string): SCNAnimation;

  static animationWithCAAnimation(caAnimation: CAAnimation): SCNAnimation;

  duration: number;

  keyPath: string;

  timingFunction: SCNTimingFunction;

  blendInDuration: number;

  blendOutDuration: number;

  isRemovedOnCompletion: boolean;

  isAppliedOnCompletion: boolean;

  repeatCount: number;

  autoreverses: boolean;

  startDelay: number;

  timeOffset: number;

  fillsForward: boolean;

  fillsBackward: boolean;

  usesSceneTimeBase: boolean;

  animationDidStart: (p1: SCNAnimation, p2: SCNAnimatable) => void;

  animationDidStop: (p1: SCNAnimation, p2: SCNAnimatable, p3: boolean) => void;

  get animationEvents(): NSArray;
  set animationEvents(value: NSArray<interop.Object> | Array<interop.Object>);

  isAdditive: boolean;

  isCumulative: boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNTorus extends SCNGeometry {
  static torusWithRingRadiusPipeRadius<This extends abstract new (...args: any) => any>(this: This, ringRadius: number, pipeRadius: number): InstanceType<This>;

  ringRadius: number;

  pipeRadius: number;

  ringSegmentCount: number;

  pipeSegmentCount: number;
}

declare class SCNProgram extends NSObject implements NSCopying, NSSecureCoding {
  static program<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  vertexShader: string;

  fragmentShader: string;

  tessellationControlShader: string;

  tessellationEvaluationShader: string;

  geometryShader: string;

  vertexFunctionName: string;

  fragmentFunctionName: string;

  handleBindingOfBufferNamedFrequencyUsingBlock(name: string, frequency: interop.Enum<typeof SCNBufferFrequency>, block: (p1: SCNBufferStream, p2: SCNNode, p3: SCNShadable, p4: SCNRenderer) => void): void;

  isOpaque: boolean;

  setSemanticForSymbolOptions(semantic: string | null, symbol: string, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): void;

  semanticForSymbol(symbol: string): string;

  delegate: SCNProgramDelegate;

  library: MTLLibrary;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNAnimationEvent extends NSObject {
  static animationEventWithKeyTimeBlock<This extends abstract new (...args: any) => any>(this: This, time: number, eventBlock: (p1: SCNAnimation, p2: interop.Object, p3: boolean) => void): InstanceType<This>;
}

declare class SCNFloor extends SCNGeometry {
  static floor<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  reflectivity: number;

  reflectionFalloffStart: number;

  reflectionFalloffEnd: number;

  reflectionCategoryBitMask: number;

  width: number;

  length: number;

  reflectionResolutionScaleFactor: number;
}

declare class SCNPhysicsBody extends NSObject implements NSCopying, NSSecureCoding {
  static staticBody<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static dynamicBody<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static kinematicBody<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static bodyWithTypeShape<This extends abstract new (...args: any) => any>(this: This, type: interop.Enum<typeof SCNPhysicsBodyType>, shape: SCNPhysicsShape | null): InstanceType<This>;

  type: interop.Enum<typeof SCNPhysicsBodyType>;

  mass: number;

  momentOfInertia: SCNVector3;

  usesDefaultMomentOfInertia: boolean;

  charge: number;

  friction: number;

  restitution: number;

  rollingFriction: number;

  physicsShape: SCNPhysicsShape;

  readonly isResting: boolean;

  allowsResting: boolean;

  velocity: SCNVector3;

  angularVelocity: SCNVector4;

  damping: number;

  angularDamping: number;

  velocityFactor: SCNVector3;

  angularVelocityFactor: SCNVector3;

  categoryBitMask: number;

  collisionBitMask: number;

  contactTestBitMask: number;

  isAffectedByGravity: boolean;

  applyForceImpulse(direction: SCNVector3, impulse: boolean): void;

  applyForceAtPositionImpulse(direction: SCNVector3, position: SCNVector3, impulse: boolean): void;

  applyTorqueImpulse(torque: SCNVector4, impulse: boolean): void;

  clearAllForces(): void;

  resetTransform(): void;

  setResting(resting: boolean): void;

  continuousCollisionDetectionThreshold: number;

  centerOfMassOffset: SCNVector3;

  linearRestingThreshold: number;

  angularRestingThreshold: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNGeometryElement extends NSObject implements NSSecureCoding {
  static geometryElementWithDataPrimitiveTypePrimitiveCountBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, data: NSData | null, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, bytesPerIndex: number): InstanceType<This>;

  static geometryElementWithDataPrimitiveTypePrimitiveCountIndicesChannelCountInterleavedIndicesChannelsBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, data: NSData | null, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, indicesChannelCount: number, interleavedIndicesChannels: boolean, bytesPerIndex: number): InstanceType<This>;

  static geometryElementWithBufferPrimitiveTypePrimitiveCountBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, buffer: MTLBuffer, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, bytesPerIndex: number): InstanceType<This>;

  static geometryElementWithBufferPrimitiveTypePrimitiveCountIndicesChannelCountInterleavedIndicesChannelsBytesPerIndex<This extends abstract new (...args: any) => any>(this: This, buffer: MTLBuffer, primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>, primitiveCount: number, indicesChannelCount: number, interleavedIndicesChannels: boolean, bytesPerIndex: number): InstanceType<This>;

  readonly data: NSData;

  readonly primitiveType: interop.Enum<typeof SCNGeometryPrimitiveType>;

  readonly primitiveCount: number;

  readonly hasInterleavedIndicesChannels: boolean;

  readonly indicesChannelCount: number;

  readonly bytesPerIndex: number;

  primitiveRange: _NSRange;

  pointSize: number;

  minimumPointScreenSpaceRadius: number;

  maximumPointScreenSpaceRadius: number;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNTimingFunction extends NSObject implements NSSecureCoding {
  static functionWithTimingMode(timingMode: interop.Enum<typeof SCNActionTimingMode>): SCNTimingFunction;

  static functionWithCAMediaTimingFunction(caTimingFunction: CAMediaTimingFunction): SCNTimingFunction;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNParticleSystem extends NSObject implements NSCopying, NSSecureCoding, SCNAnimatable {
  static particleSystem<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  static particleSystemNamedInDirectory<This extends abstract new (...args: any) => any>(this: This, name: string, directory: string | null): InstanceType<This>;

  emissionDuration: number;

  emissionDurationVariation: number;

  idleDuration: number;

  idleDurationVariation: number;

  loops: boolean;

  birthRate: number;

  birthRateVariation: number;

  warmupDuration: number;

  emitterShape: SCNGeometry;

  birthLocation: interop.Enum<typeof SCNParticleBirthLocation>;

  birthDirection: interop.Enum<typeof SCNParticleBirthDirection>;

  spreadingAngle: number;

  emittingDirection: SCNVector3;

  orientationDirection: SCNVector3;

  acceleration: SCNVector3;

  isLocal: boolean;

  particleAngle: number;

  particleAngleVariation: number;

  particleVelocity: number;

  particleVelocityVariation: number;

  particleAngularVelocity: number;

  particleAngularVelocityVariation: number;

  particleLifeSpan: number;

  particleLifeSpanVariation: number;

  systemSpawnedOnDying: SCNParticleSystem;

  systemSpawnedOnCollision: SCNParticleSystem;

  systemSpawnedOnLiving: SCNParticleSystem;

  particleImage: interop.Object;

  imageSequenceColumnCount: number;

  imageSequenceRowCount: number;

  imageSequenceInitialFrame: number;

  imageSequenceInitialFrameVariation: number;

  imageSequenceFrameRate: number;

  imageSequenceFrameRateVariation: number;

  imageSequenceAnimationMode: interop.Enum<typeof SCNParticleImageSequenceAnimationMode>;

  particleColor: NSColor;

  particleColorVariation: SCNVector4;

  particleSize: number;

  particleSizeVariation: number;

  particleIntensity: number;

  particleIntensityVariation: number;

  blendMode: interop.Enum<typeof SCNParticleBlendMode>;

  isBlackPassEnabled: boolean;

  orientationMode: interop.Enum<typeof SCNParticleOrientationMode>;

  sortingMode: interop.Enum<typeof SCNParticleSortingMode>;

  isLightingEnabled: boolean;

  affectedByGravity: boolean;

  affectedByPhysicsFields: boolean;

  particleDiesOnCollision: boolean;

  get colliderNodes(): NSArray;
  set colliderNodes(value: NSArray<interop.Object> | Array<interop.Object>);

  particleMass: number;

  particleMassVariation: number;

  particleBounce: number;

  particleBounceVariation: number;

  particleFriction: number;

  particleFrictionVariation: number;

  particleCharge: number;

  particleChargeVariation: number;

  dampingFactor: number;

  speedFactor: number;

  stretchFactor: number;

  fresnelExponent: number;

  writesToDepthBuffer: boolean;

  get propertyControllers(): NSDictionary;
  set propertyControllers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  reset(): void;

  handleEventForPropertiesWithBlock(event: interop.Enum<typeof SCNParticleEvent>, properties: NSArray<interop.Object> | Array<interop.Object>, block: (p1: interop.PointerConvertible, p2: interop.PointerConvertible, p3: interop.PointerConvertible, p4: number) => void): void;

  addModifierForPropertiesAtStageWithBlock(properties: NSArray<interop.Object> | Array<interop.Object>, stage: interop.Enum<typeof SCNParticleModifierStage>, block: (p1: interop.PointerConvertible, p2: interop.PointerConvertible, p3: number, p4: number, p5: number) => void): void;

  removeModifiersOfStage(stage: interop.Enum<typeof SCNParticleModifierStage>): void;

  removeAllModifiers(): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;
}

declare class SCNSphere extends SCNGeometry {
  static sphereWithRadius<This extends abstract new (...args: any) => any>(this: This, radius: number): InstanceType<This>;

  radius: number;

  isGeodesic: boolean;

  segmentCount: number;
}

declare class SCNTechnique extends NSObject implements SCNAnimatable, NSCopying, NSSecureCoding {
  static techniqueWithDictionary(dictionary: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>): SCNTechnique;

  static techniqueBySequencingTechniques(techniques: NSArray<interop.Object> | Array<interop.Object>): SCNTechnique;

  handleBindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  readonly dictionaryRepresentation: NSDictionary;

  objectForKeyedSubscript(key: interop.Object): interop.Object;

  setObjectForKeyedSubscript(obj: interop.Object | null, key: NSCopying): void;

  library: MTLLibrary;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNRenderer extends NSObject implements SCNSceneRenderer, SCNTechniqueSupport {
  static rendererWithContextOptions<This extends abstract new (...args: any) => any>(this: This, context: interop.PointerConvertible, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static rendererWithDeviceOptions<This extends abstract new (...args: any) => any>(this: This, device: MTLDevice | null, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  scene: SCNScene;

  renderAtTimeViewportCommandBufferPassDescriptor(time: number, viewport: CGRect, commandBuffer: MTLCommandBuffer, renderPassDescriptor: MTLRenderPassDescriptor): void;

  renderAtTime(time: number): void;

  updateAtTime(time: number): void;

  renderWithViewportCommandBufferPassDescriptor(viewport: CGRect, commandBuffer: MTLCommandBuffer, renderPassDescriptor: MTLRenderPassDescriptor): void;

  readonly nextFrameTime: number;

  snapshotAtTimeWithSizeAntialiasingMode(time: number, size: CGSize, antialiasingMode: interop.Enum<typeof SCNAntialiasingMode>): NSImage;

  updateProbesAtTime(lightProbes: NSArray<interop.Object> | Array<interop.Object>, time: number): void;

  render(): void;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  isPlaying: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  isJitteringEnabled: boolean;

  isTemporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;
}

declare class SCNPhysicsVehicle extends SCNPhysicsBehavior {
  static vehicleWithChassisBodyWheels<This extends abstract new (...args: any) => any>(this: This, chassisBody: SCNPhysicsBody, wheels: NSArray<interop.Object> | Array<interop.Object>): InstanceType<This>;

  readonly speedInKilometersPerHour: number;

  readonly wheels: NSArray;

  readonly chassisBody: SCNPhysicsBody;

  applyEngineForceForWheelAtIndex(value: number, index: number): void;

  setSteeringAngleForWheelAtIndex(value: number, index: number): void;

  applyBrakingForceForWheelAtIndex(value: number, index: number): void;
}

declare class SCNAudioPlayer extends NSObject {
  initWithSource(source: SCNAudioSource): this;

  initWithAVAudioNode(audioNode: AVAudioNode): this;

  static audioPlayerWithSource<This extends abstract new (...args: any) => any>(this: This, source: SCNAudioSource): InstanceType<This>;

  static audioPlayerWithAVAudioNode<This extends abstract new (...args: any) => any>(this: This, audioNode: AVAudioNode): InstanceType<This>;

  willStartPlayback: () => void;

  didFinishPlayback: () => void;

  readonly audioNode: AVAudioNode;

  readonly audioSource: SCNAudioSource;
}

declare class SCNCameraController extends NSObject {
  delegate: SCNCameraControllerDelegate;

  pointOfView: SCNNode;

  interactionMode: interop.Enum<typeof SCNInteractionMode>;

  target: SCNVector3;

  automaticTarget: boolean;

  worldUp: SCNVector3;

  inertiaEnabled: boolean;

  inertiaFriction: number;

  readonly isInertiaRunning: boolean;

  minimumVerticalAngle: number;

  maximumVerticalAngle: number;

  minimumHorizontalAngle: number;

  maximumHorizontalAngle: number;

  translateInCameraSpaceByXYZ(deltaX: number, deltaY: number, deltaZ: number): void;

  frameNodes(nodes: NSArray<interop.Object> | Array<interop.Object>): void;

  rotateByXY(deltaX: number, deltaY: number): void;

  rollByAroundScreenPointViewport(delta: number, point: CGPoint, viewport: CGSize): void;

  dollyByOnScreenPointViewport(delta: number, point: CGPoint, viewport: CGSize): void;

  rollAroundTarget(delta: number): void;

  dollyToTarget(delta: number): void;

  clearRoll(): void;

  stopInertia(): void;

  beginInteractionWithViewport(location: CGPoint, viewport: CGSize): void;

  continueInteractionWithViewportSensitivity(location: CGPoint, viewport: CGSize, sensitivity: number): void;

  endInteractionWithViewportVelocity(location: CGPoint, viewport: CGSize, velocity: CGPoint): void;
}

declare class SCNPhysicsConeTwistJoint extends SCNPhysicsBehavior {
  static jointWithBodyAFrameABodyBFrameB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, frameA: CATransform3D, bodyB: SCNPhysicsBody, frameB: CATransform3D): InstanceType<This>;

  static jointWithBodyFrame<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, frame: CATransform3D): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  frameA: CATransform3D;

  readonly bodyB: SCNPhysicsBody;

  frameB: CATransform3D;

  maximumAngularLimit1: number;

  maximumAngularLimit2: number;

  maximumTwistAngle: number;
}

declare class SCNAvoidOccluderConstraint extends SCNConstraint {
  static avoidOccluderConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  delegate: SCNAvoidOccluderConstraintDelegate;

  target: SCNNode;

  occluderCategoryBitMask: number;

  bias: number;
}

declare class SCNCylinder extends SCNGeometry {
  static cylinderWithRadiusHeight<This extends abstract new (...args: any) => any>(this: This, radius: number, height: number): InstanceType<This>;

  radius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;
}

declare class SCNAudioSource extends NSObject implements NSCopying, NSSecureCoding {
  initWithFileNamed(name: string): this;

  initWithURL(url: NSURL): this;

  static audioSourceNamed<This extends abstract new (...args: any) => any>(this: This, fileName: string): InstanceType<This>;

  isPositional: boolean;

  volume: number;

  rate: number;

  reverbBlend: number;

  loops: boolean;

  shouldStream: boolean;

  load(): void;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNMaterialProperty extends NSObject implements SCNAnimatable, NSSecureCoding {
  static materialPropertyWithContents<This extends abstract new (...args: any) => any>(this: This, contents: interop.Object): InstanceType<This>;

  contents: interop.Object;

  intensity: number;

  minificationFilter: interop.Enum<typeof SCNFilterMode>;

  magnificationFilter: interop.Enum<typeof SCNFilterMode>;

  mipFilter: interop.Enum<typeof SCNFilterMode>;

  contentsTransform: CATransform3D;

  wrapS: interop.Enum<typeof SCNWrapMode>;

  wrapT: interop.Enum<typeof SCNWrapMode>;

  mappingChannel: number;

  textureComponents: interop.Enum<typeof SCNColorMask>;

  maxAnisotropy: number;

  static precomputedLightingEnvironmentContentsWithURLError(url: NSURL, error: interop.PointerConvertible): interop.Object;

  static precomputedLightingEnvironmentContentsWithDataError(data: NSData, error: interop.PointerConvertible): interop.Object;

  static precomputedLightingEnvironmentDataForContentsDeviceError(contents: interop.Object, device: MTLDevice | null, error: interop.PointerConvertible): NSData;

  borderColor: interop.Object;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNAccelerationConstraint extends SCNConstraint {
  static accelerationConstraint<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  maximumLinearAcceleration: number;

  maximumLinearVelocity: number;

  decelerationDistance: number;

  damping: number;
}

declare class SCNHitTestResult extends NSObject {
  readonly node: SCNNode;

  readonly geometryIndex: number;

  readonly faceIndex: number;

  readonly localCoordinates: SCNVector3;

  readonly worldCoordinates: SCNVector3;

  readonly localNormal: SCNVector3;

  readonly worldNormal: SCNVector3;

  readonly modelTransform: CATransform3D;

  readonly boneNode: SCNNode;

  textureCoordinatesWithMappingChannel(channel: number): CGPoint;

  readonly simdLocalCoordinates: unknown /* ext vector */;

  readonly simdWorldCoordinates: unknown /* ext vector */;

  readonly simdLocalNormal: unknown /* ext vector */;

  readonly simdWorldNormal: unknown /* ext vector */;

  readonly simdModelTransform: simd_float4x4;
}

// @ts-ignore ClassDecl.tsIgnore
declare class SCNReferenceNode extends SCNNode {
  initWithURL(referenceURL: NSURL): this;

  // @ts-ignore MemberDecl.tsIgnore
  initWithCoder(aDecoder: NSCoder): this;

  static referenceNodeWithURL<This extends abstract new (...args: any) => any>(this: This, referenceURL: NSURL): InstanceType<This>;

  referenceURL: NSURL;

  loadingPolicy: interop.Enum<typeof SCNReferenceLoadingPolicy>;

  load(): void;

  unload(): void;

  readonly isLoaded: boolean;
}

declare class SCNGeometry extends NSObject implements SCNAnimatable, SCNBoundingVolume, SCNShadable, NSCopying, NSSecureCoding {
  static geometry<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  name: string;

  get materials(): NSArray;
  set materials(value: NSArray<interop.Object> | Array<interop.Object>);

  firstMaterial: SCNMaterial;

  insertMaterialAtIndex(material: SCNMaterial, index: number): void;

  removeMaterialAtIndex(index: number): void;

  replaceMaterialAtIndexWithMaterial(index: number, material: SCNMaterial): void;

  materialWithName(name: string): SCNMaterial;

  static geometryWithSourcesElements<This extends abstract new (...args: any) => any>(this: This, sources: NSArray<interop.Object> | Array<interop.Object>, elements: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  static geometryWithSourcesElementsSourceChannels<This extends abstract new (...args: any) => any>(this: This, sources: NSArray<interop.Object> | Array<interop.Object>, elements: NSArray<interop.Object> | Array<interop.Object> | null, sourceChannels: NSArray<interop.Object> | Array<interop.Object> | null): InstanceType<This>;

  readonly geometrySources: NSArray;

  geometrySourcesForSemantic(semantic: string): NSArray;

  readonly geometryElements: NSArray;

  readonly geometryElementCount: number;

  geometryElementAtIndex(elementIndex: number): SCNGeometryElement;

  readonly geometrySourceChannels: NSArray;

  get levelsOfDetail(): NSArray;
  set levelsOfDetail(value: NSArray<interop.Object> | Array<interop.Object>);

  tessellator: SCNGeometryTessellator;

  subdivisionLevel: number;

  wantsAdaptiveSubdivision: boolean;

  edgeCreasesElement: SCNGeometryElement;

  edgeCreasesSource: SCNGeometrySource;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  getBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): boolean;

  setBoundingBoxMinMax(min: interop.PointerConvertible, max: interop.PointerConvertible): void;

  getBoundingSphereCenterRadius(center: interop.PointerConvertible, radius: interop.PointerConvertible): boolean;

  program: SCNProgram;

  handleBindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  handleUnbindingOfSymbolUsingBlock(symbol: string, block: (p1: number, p2: number, p3: SCNNode, p4: SCNRenderer) => void | null): void;

  get shaderModifiers(): NSDictionary;
  set shaderModifiers(value: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object>);

  minimumLanguageVersion: NSNumber;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNMorpher extends NSObject implements SCNAnimatable, NSSecureCoding {
  get targets(): NSArray;
  set targets(value: NSArray<interop.Object> | Array<interop.Object>);

  get weights(): NSArray;
  set weights(value: NSArray<interop.Object> | Array<interop.Object>);

  setWeightForTargetAtIndex(weight: number, targetIndex: number): void;

  weightForTargetAtIndex(targetIndex: number): number;

  setWeightForTargetNamed(weight: number, targetName: string): void;

  weightForTargetNamed(targetName: string): number;

  calculationMode: interop.Enum<typeof SCNMorpherCalculationMode>;

  unifiesNormals: boolean;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNView extends NSView implements SCNSceneRenderer, SCNTechniqueSupport {
  initWithFrameOptions(frame: CGRect, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  scene: SCNScene;

  rendersContinuously: boolean;

  backgroundColor: NSColor;

  allowsCameraControl: boolean;

  readonly cameraControlConfiguration: SCNCameraControlConfiguration;

  readonly defaultCameraController: SCNCameraController;

  snapshot(): NSImage;

  play(sender: interop.Object | null): void;

  pause(sender: interop.Object | null): void;

  stop(sender: interop.Object | null): void;

  preferredFramesPerSecond: number;

  drawableResizesAsynchronously: boolean;

  openGLContext: NSOpenGLContext;

  antialiasingMode: interop.Enum<typeof SCNAntialiasingMode>;

  pixelFormat: NSOpenGLPixelFormat;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  isPlaying: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  isJitteringEnabled: boolean;

  isTemporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;
}

// @ts-ignore ClassDecl.tsIgnore
declare class SCNLayer extends CAOpenGLLayer implements SCNSceneRenderer, SCNTechniqueSupport {
  scene: SCNScene;

  presentSceneWithTransitionIncomingPointOfViewCompletionHandler(scene: SCNScene, transition: SKTransition, pointOfView: SCNNode | null, completionHandler: () => void | null): void;

  sceneTime: number;

  // @ts-ignore MemberDecl.tsIgnore
  delegate: SCNSceneRendererDelegate;

  hitTestOptions(point: CGPoint, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): NSArray;

  isNodeInsideFrustumWithPointOfView(node: SCNNode, pointOfView: SCNNode): boolean;

  nodesInsideFrustumWithPointOfView(pointOfView: SCNNode): NSArray;

  projectPoint(point: SCNVector3): SCNVector3;

  unprojectPoint(point: SCNVector3): SCNVector3;

  isPlaying: boolean;

  loops: boolean;

  pointOfView: SCNNode;

  autoenablesDefaultLighting: boolean;

  isJitteringEnabled: boolean;

  isTemporalAntialiasingEnabled: boolean;

  prepareObjectShouldAbortBlock(object: interop.Object, block: () => boolean | null): boolean;

  prepareObjectsWithCompletionHandler(objects: NSArray<interop.Object> | Array<interop.Object>, completionHandler: (p1: boolean) => void | null): void;

  showsStatistics: boolean;

  debugOptions: interop.Enum<typeof SCNDebugOptions>;

  overlaySKScene: SKScene;

  readonly renderingAPI: interop.Enum<typeof SCNRenderingAPI>;

  readonly workingColorSpace: interop.Pointer;

  readonly context: interop.Pointer;

  readonly currentRenderCommandEncoder: MTLRenderCommandEncoder;

  readonly currentRenderPassDescriptor: MTLRenderPassDescriptor;

  readonly device: MTLDevice;

  readonly colorPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly depthPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly stencilPixelFormat: interop.Enum<typeof MTLPixelFormat>;

  readonly commandQueue: MTLCommandQueue;

  readonly audioEngine: AVAudioEngine;

  readonly audioEnvironmentNode: AVAudioEnvironmentNode;

  audioListener: SCNNode;

  readonly currentViewport: CGRect;

  currentTime: number;

  usesReverseZ: boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;
}

declare class SCNPhysicsBehavior extends NSObject implements NSSecureCoding {
  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNCamera extends NSObject implements SCNAnimatable, SCNTechniqueSupport, NSCopying, NSSecureCoding {
  static camera<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  name: string;

  fieldOfView: number;

  projectionDirection: interop.Enum<typeof SCNCameraProjectionDirection>;

  focalLength: number;

  sensorHeight: number;

  zNear: number;

  zFar: number;

  automaticallyAdjustsZRange: boolean;

  usesOrthographicProjection: boolean;

  orthographicScale: number;

  projectionTransform: CATransform3D;

  projectionTransformWithViewportSize(viewportSize: CGSize): CATransform3D;

  wantsDepthOfField: boolean;

  focusDistance: number;

  focalBlurSampleCount: number;

  fStop: number;

  apertureBladeCount: number;

  motionBlurIntensity: number;

  screenSpaceAmbientOcclusionIntensity: number;

  screenSpaceAmbientOcclusionRadius: number;

  screenSpaceAmbientOcclusionBias: number;

  screenSpaceAmbientOcclusionDepthThreshold: number;

  screenSpaceAmbientOcclusionNormalThreshold: number;

  wantsHDR: boolean;

  exposureOffset: number;

  averageGray: number;

  whitePoint: number;

  wantsExposureAdaptation: boolean;

  exposureAdaptationBrighteningSpeedFactor: number;

  exposureAdaptationDarkeningSpeedFactor: number;

  minimumExposure: number;

  maximumExposure: number;

  bloomThreshold: number;

  bloomIterationCount: number;

  bloomIterationSpread: number;

  bloomIntensity: number;

  bloomBlurRadius: number;

  vignettingPower: number;

  vignettingIntensity: number;

  colorFringeStrength: number;

  colorFringeIntensity: number;

  saturation: number;

  contrast: number;

  grainIntensity: number;

  grainScale: number;

  grainIsColored: boolean;

  whiteBalanceTemperature: number;

  whiteBalanceTint: number;

  readonly colorGrading: SCNMaterialProperty;

  categoryBitMask: number;

  focalBlurRadius: number;

  xFov: number;

  yFov: number;

  aperture: number;

  focalSize: number;

  focalDistance: number;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  technique: SCNTechnique;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNPhysicsSliderJoint extends SCNPhysicsBehavior {
  static jointWithBodyAAxisAAnchorABodyBAxisBAnchorB<This extends abstract new (...args: any) => any>(this: This, bodyA: SCNPhysicsBody, axisA: SCNVector3, anchorA: SCNVector3, bodyB: SCNPhysicsBody, axisB: SCNVector3, anchorB: SCNVector3): InstanceType<This>;

  static jointWithBodyAxisAnchor<This extends abstract new (...args: any) => any>(this: This, body: SCNPhysicsBody, axis: SCNVector3, anchor: SCNVector3): InstanceType<This>;

  readonly bodyA: SCNPhysicsBody;

  axisA: SCNVector3;

  anchorA: SCNVector3;

  readonly bodyB: SCNPhysicsBody;

  axisB: SCNVector3;

  anchorB: SCNVector3;

  minimumLinearLimit: number;

  maximumLinearLimit: number;

  minimumAngularLimit: number;

  maximumAngularLimit: number;

  motorTargetLinearVelocity: number;

  motorMaximumForce: number;

  motorTargetAngularVelocity: number;

  motorMaximumTorque: number;
}

declare class SCNTransaction extends NSObject {
  static begin(): void;

  static commit(): void;

  static flush(): void;

  static lock(): void;

  static unlock(): void;

  static animationDuration: number;

  static animationTimingFunction: CAMediaTimingFunction;

  static disableActions: boolean;

  static completionBlock: () => void;

  static valueForKey(key: string): interop.Object;

  static setValueForKey(value: interop.Object | null, key: string): void;
}

declare class SCNPyramid extends SCNGeometry {
  static pyramidWithWidthHeightLength<This extends abstract new (...args: any) => any>(this: This, width: number, height: number, length: number): InstanceType<This>;

  width: number;

  height: number;

  length: number;

  widthSegmentCount: number;

  heightSegmentCount: number;

  lengthSegmentCount: number;
}

declare class SCNTransformConstraint extends SCNConstraint {
  static transformConstraintInWorldSpaceWithBlock<This extends abstract new (...args: any) => any>(this: This, world: boolean, block: (p1: SCNNode, p2: CATransform3D) => CATransform3D): InstanceType<This>;

  static positionConstraintInWorldSpaceWithBlock<This extends abstract new (...args: any) => any>(this: This, world: boolean, block: (p1: SCNNode, p2: SCNVector3) => SCNVector3): InstanceType<This>;

  static orientationConstraintInWorldSpaceWithBlock<This extends abstract new (...args: any) => any>(this: This, world: boolean, block: (p1: SCNNode, p2: SCNVector4) => SCNVector4): InstanceType<This>;
}

declare class SCNPhysicsVehicleWheel extends NSObject implements NSCopying, NSSecureCoding {
  static wheelWithNode<This extends abstract new (...args: any) => any>(this: This, node: SCNNode): InstanceType<This>;

  readonly node: SCNNode;

  suspensionStiffness: number;

  suspensionCompression: number;

  suspensionDamping: number;

  maximumSuspensionTravel: number;

  frictionSlip: number;

  maximumSuspensionForce: number;

  connectionPosition: SCNVector3;

  steeringAxis: SCNVector3;

  axle: SCNVector3;

  radius: number;

  suspensionRestLength: number;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNLight extends NSObject implements SCNAnimatable, NSCopying, NSSecureCoding {
  static light<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  type: string;

  color: interop.Object;

  temperature: number;

  intensity: number;

  name: string;

  castsShadow: boolean;

  shadowColor: interop.Object;

  shadowRadius: number;

  shadowMapSize: CGSize;

  shadowSampleCount: number;

  shadowMode: interop.Enum<typeof SCNShadowMode>;

  shadowBias: number;

  automaticallyAdjustsShadowProjection: boolean;

  maximumShadowDistance: number;

  forcesBackFaceCasters: boolean;

  sampleDistributedShadowMaps: boolean;

  shadowCascadeCount: number;

  shadowCascadeSplittingFactor: number;

  orthographicScale: number;

  zNear: number;

  zFar: number;

  attenuationStartDistance: number;

  attenuationEndDistance: number;

  attenuationFalloffExponent: number;

  spotInnerAngle: number;

  spotOuterAngle: number;

  IESProfileURL: NSURL;

  readonly sphericalHarmonicsCoefficients: NSData;

  probeType: interop.Enum<typeof SCNLightProbeType>;

  probeUpdateType: interop.Enum<typeof SCNLightProbeUpdateType>;

  probeExtents: unknown /* ext vector */;

  probeOffset: unknown /* ext vector */;

  parallaxCorrectionEnabled: boolean;

  parallaxExtentsFactor: unknown /* ext vector */;

  parallaxCenterOffset: unknown /* ext vector */;

  readonly probeEnvironment: SCNMaterialProperty;

  areaType: interop.Enum<typeof SCNLightAreaType>;

  areaExtents: unknown /* ext vector */;

  get areaPolygonVertices(): NSArray;
  set areaPolygonVertices(value: NSArray<interop.Object> | Array<interop.Object>);

  drawsArea: boolean;

  doubleSided: boolean;

  readonly gobo: SCNMaterialProperty;

  categoryBitMask: number;

  attributeForKey(key: string): interop.Object;

  setAttributeForKey(attribute: interop.Object | null, key: string): void;

  addAnimationForKey(animation: SCNAnimation, key: string | null): void;

  addAnimationPlayerForKey(player: SCNAnimationPlayer, key: string | null): void;

  removeAllAnimations(): void;

  removeAllAnimationsWithBlendOutDuration(duration: number): void;

  removeAnimationForKey(key: string): void;

  removeAnimationForKeyBlendOutDuration(key: string, duration: number): void;

  readonly animationKeys: NSArray;

  animationPlayerForKey(key: string): SCNAnimationPlayer;

  removeAnimationForKeyFadeOutDuration(key: string, duration: number): void;

  animationForKey(key: string): CAAnimation;

  pauseAnimationForKey(key: string): void;

  resumeAnimationForKey(key: string): void;

  setSpeedForAnimationKey(speed: number, key: string): void;

  isAnimationForKeyPaused(key: string): boolean;

  isEqual(object: interop.Object): boolean;

  readonly hash: number;

  readonly superclass: interop.Object;

  class(): interop.Object;

  self(): this;

  performSelector(aSelector: string): interop.Object;

  performSelectorWithObject(aSelector: string, object: interop.Object): interop.Object;

  performSelectorWithObjectWithObject(aSelector: string, object1: interop.Object, object2: interop.Object): interop.Object;

  readonly isProxy: boolean;

  isKindOfClass(aClass: interop.Object): boolean;

  isMemberOfClass(aClass: interop.Object): boolean;

  conformsToProtocol(aProtocol: interop.PointerConvertible): boolean;

  respondsToSelector(aSelector: string): boolean;

  retain(): this;

  release(): void;

  autorelease(): this;

  retainCount(): number;

  readonly zone: interop.Pointer;

  readonly description: string;

  readonly debugDescription: string;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNGeometryTessellator extends NSObject implements NSCopying, NSSecureCoding {
  tessellationFactorScale: number;

  tessellationPartitionMode: interop.Enum<typeof MTLTessellationPartitionMode>;

  isAdaptive: boolean;

  isScreenSpace: boolean;

  edgeTessellationFactor: number;

  insideTessellationFactor: number;

  maximumEdgeLength: number;

  smoothingMode: interop.Enum<typeof SCNTessellationSmoothingMode>;

  copyWithZone(zone: interop.PointerConvertible): interop.Object;

  static readonly supportsSecureCoding: boolean;

  encodeWithCoder(coder: NSCoder): void;

  initWithCoder(coder: NSCoder): this;
}

declare class SCNSliderConstraint extends SCNConstraint {
  static sliderConstraint<This extends abstract new (...args: any) => any>(this: This): InstanceType<This>;

  collisionCategoryBitMask: number;

  radius: number;

  offset: SCNVector3;
}

declare class SCNIKConstraint extends SCNConstraint {
  initWithChainRootNode(chainRootNode: SCNNode): this;

  static inverseKinematicsConstraintWithChainRootNode<This extends abstract new (...args: any) => any>(this: This, chainRootNode: SCNNode): InstanceType<This>;

  readonly chainRootNode: SCNNode;

  targetPosition: SCNVector3;

  setMaxAllowedRotationAngleForJoint(angle: number, node: SCNNode): void;

  maxAllowedRotationAngleForJoint(node: SCNNode): number;
}

declare class SCNSceneSource extends NSObject {
  static sceneSourceWithURLOptions<This extends abstract new (...args: any) => any>(this: This, url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  static sceneSourceWithDataOptions<This extends abstract new (...args: any) => any>(this: This, data: NSData, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): InstanceType<This>;

  initWithURLOptions(url: NSURL, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  initWithDataOptions(data: NSData, options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null): this;

  readonly url: NSURL;

  readonly data: NSData;

  sceneWithOptionsStatusHandler(options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, statusHandler: (p1: number, p2: interop.Enum<typeof SCNSceneSourceStatus>, p3: NSError, p4: interop.PointerConvertible) => void | null): SCNScene;

  sceneWithOptionsError(options: NSDictionary<interop.Object, interop.Object> | Record<interop.Object, interop.Object> | null, error: interop.PointerConvertible): SCNScene;

  propertyForKey(key: string): interop.Object;

  entryWithIdentifierWithClass(uid: string, entryClass: interop.Object): interop.Object;

  identifiersOfEntriesWithClass(entryClass: interop.Object): NSArray;

  entriesPassingTest(predicate: (p1: interop.Object, p2: string, p3: interop.PointerConvertible) => boolean): NSArray;
}

declare class SCNCapsule extends SCNGeometry {
  static capsuleWithCapRadiusHeight<This extends abstract new (...args: any) => any>(this: This, capRadius: number, height: number): InstanceType<This>;

  capRadius: number;

  height: number;

  radialSegmentCount: number;

  heightSegmentCount: number;

  capSegmentCount: number;
}

declare class SCNPhysicsContact extends NSObject {
  readonly nodeA: SCNNode;

  readonly nodeB: SCNNode;

  readonly contactPoint: SCNVector3;

  readonly contactNormal: SCNVector3;

  readonly collisionImpulse: number;

  readonly penetrationDistance: number;

  readonly sweepTestFraction: number;
}

declare class SCNReplicatorConstraint extends SCNConstraint {
  static replicatorConstraintWithTarget<This extends abstract new (...args: any) => any>(this: This, target: SCNNode | null): InstanceType<This>;

  target: SCNNode;

  replicatesOrientation: boolean;

  replicatesPosition: boolean;

  replicatesScale: boolean;

  orientationOffset: SCNVector4;

  positionOffset: SCNVector3;

  scaleOffset: SCNVector3;
}

